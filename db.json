{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":0},{"_id":"themes/huxblog/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.css","path":"css/hux-blog.css","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"b21454a0079dff7c8535082e746f08247e8c9c67","modified":1517554150000},{"_id":"themes/huxblog/_config.yml","hash":"5d235aa7716657282795ee86d9c9db2374197a66","modified":1517554150000},{"_id":"source/_posts/Parcel Vs Webpack.md","hash":"33b36e5814b7637923bdf1dc441d6bac1861008d","modified":1542170368651},{"_id":"source/_posts/ReactNative三端同构实战.md","hash":"ce173e891c83c812200d38bbba990b672b20aaca","modified":1542170368652},{"_id":"source/_posts/WebAssembly 现状与实战.md","hash":"630d1d36c48b1280ac7ba8ea633c92d504708883","modified":1542170368652},{"_id":"source/_posts/webpack2 终极优化.md","hash":"0b1530a3a84a5dfc58262cc8872e00901cd6e32e","modified":1542170368649},{"_id":"source/_posts/webpack原理与实战.md","hash":"9e5efc91aff27a47b2f9463f90a448bc44003ef0","modified":1542170368649},{"_id":"source/_posts/使用HeadlessChrome做单页应用SEO.md","hash":"957cdd22f78017fa7b55ba298fe0f610e667022b","modified":1542170368650},{"_id":"source/_posts/你也能写个 Shadowsocks.md","hash":"83d97133655800a2266fedcecaed9523e3cc5ce6","modified":1542170368651},{"_id":"source/_posts/快速优雅的为React组件生成文档.md","hash":"7cc0bafb64e7b8a52927929e13a5173be720d89b","modified":1542170368648},{"_id":"source/_posts/使用flv.js做直播.md","hash":"aa729e1aa873c2fd348b5cb044209094041feaa8","modified":1542170368649},{"_id":"source/_posts/加速 Webpack.md","hash":"23b6916bf63a367e62ff6d8d7dc4ad708118982d","modified":1542170368652},{"_id":"source/_posts/音视频技术参考资料.md","hash":"10bc996c4b9bcd542686392800714c11867ccdc4","modified":1542170368649},{"_id":"source/_posts/基于HeadlessChrome的网页自动化测试系统-FinalTest.md","hash":"1259df42b6dd6f2f7e24c7f6a70c765d85c0e774","modified":1542170368650},{"_id":"source/_posts/流媒体加密.md","hash":"26e6ce2858c895003f57ae13d8ee4eb0402cd207","modified":1542170368650},{"_id":"source/_posts/调试利器-SSH隧道.md","hash":"bc1fd88f4578d159db561bb5a067ccc6fde73185","modified":1542170368650},{"_id":"source/about/index.md","hash":"6988df4ddbf5bb2808d327ea44bf83dc19788c25","modified":1517554150000},{"_id":"source/archives/index.md","hash":"7a0743a2d7f19beb03cff46b27c9f370a948564f","modified":1517554150000},{"_id":"source/tags/index.md","hash":"e061d1a8ea99d766c9c4b3fcf4fc44df3f0e7de0","modified":1517554150000},{"_id":"themes/huxblog/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1517554150000},{"_id":"themes/huxblog/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1517554150000},{"_id":"themes/huxblog/layout/about.ejs","hash":"7f56c71383ef6c156b56d79b3984e07cc466606a","modified":1517554150000},{"_id":"themes/huxblog/layout/archive.ejs","hash":"6c3ed5d914379319efe835a4aa505abbc616c328","modified":1517554150000},{"_id":"themes/huxblog/layout/archives.ejs","hash":"f0046e58cc1dd876133be2bf927aed2b1821cb3e","modified":1517554150000},{"_id":"themes/huxblog/layout/index.ejs","hash":"70ac58c46625300a70791e210daf446afa6d1cd4","modified":1517554150000},{"_id":"themes/huxblog/layout/layout.ejs","hash":"8202887ae05e0971d79ec50fb32c0e452f4e7bf9","modified":1517628270124},{"_id":"themes/huxblog/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1517554150000},{"_id":"themes/huxblog/layout/page.ejs","hash":"44c74e8a3c8d3b20a2f2f07f7646961a59f22922","modified":1518076718210},{"_id":"themes/huxblog/layout/tags.ejs","hash":"a51bf2828af20939d702de1fdae067439a1153c0","modified":1517554150000},{"_id":"themes/huxblog/layout/post.ejs","hash":"09b8c3822f59e6a8bfdcd67fd0f0893aee041612","modified":1542188101524},{"_id":"source/img/bg.jpg","hash":"8844274a812ae19e8f2a3b7e4e465342e63eb852","modified":1517554150000},{"_id":"themes/huxblog/layout/_partial/head.ejs","hash":"87c544a64ea49b835330135a616deb2e9fd39bbb","modified":1517554150000},{"_id":"themes/huxblog/layout/_partial/footer.ejs","hash":"910a961328b89727bcc538107d484b5885fe5d48","modified":1519370257286},{"_id":"themes/huxblog/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1517554150000},{"_id":"themes/huxblog/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1517554150000},{"_id":"themes/huxblog/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1517554150000},{"_id":"themes/huxblog/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1517554150000},{"_id":"themes/huxblog/source/css/hux-blog.css","hash":"08dcd2e34d2406d98b24ae6b732551af4f0929ac","modified":1542170265861},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1517554150000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1517554150000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1517554150000},{"_id":"themes/huxblog/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1517554150000},{"_id":"themes/huxblog/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1517554150000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1517554150000},{"_id":"themes/huxblog/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1517554150000},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1517554150000},{"_id":"themes/huxblog/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1517554150000},{"_id":"themes/huxblog/source/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1517554150000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1517554150000},{"_id":"themes/huxblog/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1517554150000},{"_id":"themes/huxblog/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1517554150000},{"_id":"themes/huxblog/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1517554150000},{"_id":"themes/huxblog/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1517554150000}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/bg.jpg\"\n---\n","date":"2018-02-02T06:50:23.603Z","updated":"2018-02-02T06:49:10.000Z","path":"404.html","title":"","comments":1,"_id":"cjogs0kdd0000g5tc5zh2skv3","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"关于","date":"2016-04-20T20:48:33.000Z","description":"Hi，我是浩麟","header-img":"img/bg.jpg","_content":"\n前端工程师，目前就职于美团成都，曾就职于腾讯深圳。\n\n### [我的在线简历](http://resume.wuhaolin.cn/)\n\n### 我出版的图书\n<a href=\"http://webpack.wuhaolin.cn/\">\n    <img src=\"http://ou8vcvyuy.bkt.clouddn.com/dive-into-webpack.png\" width=\"306px\" height=\"411px\"/>\n</a>\n\n\n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"关于\"\ndate: 2016-04-21 04:48:33\ndescription: \"Hi，我是浩麟\"\nheader-img: \"img/bg.jpg\"\n---\n\n前端工程师，目前就职于美团成都，曾就职于腾讯深圳。\n\n### [我的在线简历](http://resume.wuhaolin.cn/)\n\n### 我出版的图书\n<a href=\"http://webpack.wuhaolin.cn/\">\n    <img src=\"http://ou8vcvyuy.bkt.clouddn.com/dive-into-webpack.png\" width=\"306px\" height=\"411px\"/>\n</a>\n\n\n\n","updated":"2018-02-02T06:49:10.000Z","path":"about/index.html","comments":1,"_id":"cjogs0kfg0011g5tcpb6d6r8i","content":"<p>前端工程师，目前就职于美团成都，曾就职于腾讯深圳。</p>\n<h3 id=\"我的在线简历\"><a href=\"#我的在线简历\" class=\"headerlink\" title=\"我的在线简历\"></a><a href=\"http://resume.wuhaolin.cn/\" target=\"_blank\" rel=\"noopener\">我的在线简历</a></h3><h3 id=\"我出版的图书\"><a href=\"#我出版的图书\" class=\"headerlink\" title=\"我出版的图书\"></a>我出版的图书</h3><p><a href=\"http://webpack.wuhaolin.cn/\" target=\"_blank\" rel=\"noopener\"><br>    <img src=\"http://ou8vcvyuy.bkt.clouddn.com/dive-into-webpack.png\" width=\"306px\" height=\"411px\"><br></a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>前端工程师，目前就职于美团成都，曾就职于腾讯深圳。</p>\n<h3 id=\"我的在线简历\"><a href=\"#我的在线简历\" class=\"headerlink\" title=\"我的在线简历\"></a><a href=\"http://resume.wuhaolin.cn/\" target=\"_blank\" rel=\"noopener\">我的在线简历</a></h3><h3 id=\"我出版的图书\"><a href=\"#我出版的图书\" class=\"headerlink\" title=\"我出版的图书\"></a>我出版的图书</h3><p><a href=\"http://webpack.wuhaolin.cn/\" target=\"_blank\" rel=\"noopener\"><br>    <img src=\"http://ou8vcvyuy.bkt.clouddn.com/dive-into-webpack.png\" width=\"306px\" height=\"411px\"><br></a></p>\n"},{"layout":"archives","title":"归档","description":"历年的文章","header-img":"img/bg.jpg","_content":"","source":"archives/index.md","raw":"---\nlayout: \"archives\"\ntitle: \"归档\"\ndescription: \"历年的文章\"\nheader-img: \"img/bg.jpg\"\n---\n","date":"2018-02-02T06:50:23.609Z","updated":"2018-02-02T06:49:10.000Z","path":"archives/index.html","comments":1,"_id":"cjogs0kfi0012g5tcchrur0rb","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"标签","description":"把文章按照标签分类","header-img":"img/bg.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"标签\"\ndescription: \"把文章按照标签分类\"\nheader-img: \"img/bg.jpg\"\n---\n","date":"2018-02-02T06:50:23.596Z","updated":"2018-02-02T06:49:10.000Z","path":"tags/index.html","comments":1,"_id":"cjogs0kfi0014g5tcj3ocx762","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Parcel Vs Webpack","date":"2017-12-27T05:21:56.000Z","url":"https://github.com/gwuhaolin/blog/issues/13","_content":"\n> 爱折腾的前端圈时常会有新轮子诞生，只要是好东西就能快速获得大量关注，资历再好的大哥只要不如新人也很快会被替代。\n\n横空出世的[Parcel](https://parceljs.org/)近日成为了前端圈的又一大热点，在短短几周内就获得了13K的Star。\n作为前端构建工具新人的Parcel为什么能在短期内获得这么多赞同？他和老大哥Webpack比起来到底有什么优势呢？\n\n我花了6个月的时间写了一本全面介绍Webpack的图书[《深入浅出 Webpack》](http://webpack.wuhaolin.cn/)近日刚出版，感觉被新出的Parcel给腰斩了。\n但本文将本着公平公正的心态来详细对比一下他两，让你能明白他们直接的异同和优缺点对比，好决定是选Parcel还是Webpack。\n\n为了对比他两，我们从实际出发举一个实战项目为例子，分别用Parcel和Webpack去实现，实战项目要求如下：\n\n- 项目采用TypeScript+React+SCSS；\n- 项目采用了[Antd](https://ant.design) UI组件库，但要做到按需加载只用到了的组件，而不是所有组件都打包进去；\n- 项目使用了[Lodash](https://lodash.com)库，用于检查构建是否有剔除无用代码的能力(TreeShaking)；\n- 构建需要支持模块热替换功能，以提高开发效率；\n- 支持SourceMap，以方便调试；\n- 对比他们的首次启动速度和监听变化时的构建速度；\n- 在生成环境下需要压缩JS、CSS，CSS需要提取到单独到文件，并对比他们在生产环境下构建出文件大小；\n- 需要生成自动会加载对应资源的HTML文件；\n\n\n### Parcel让人眼前一亮\n在用了很久Webpack后用Parcel的感觉就像用了很久Android机后用iPhone，不用再去操心细节和配置，大多数时候Parcel刚刚够用而且用的很舒服。\n\n用Parcel去完成以上项目的要求，我只是专心去写项目页面所必须的代码，Parcel智能快速的帮我构建出了能正常运行的结果。\n\n以下是Parcel让我心动的点：\n- Parcel能做到无配置完成以上项目构建要求；\n- Parcel内置了常见场景的构建方案及其依赖，无需再安装各种依赖；\n- Parcel能以HTML为入口，自动检测和打包依赖资源；\n- Parcel默认支持模块热替换，真正的开箱即用；\n\n而反观Webpack，比Parcel要麻烦很多：\n- 需要写[一堆配置](https://github.com/gwuhaolin/parcel-vs-webpack/blob/master/webpack.config.js)；\n- 需要再安装[一堆依赖](https://github.com/gwuhaolin/parcel-vs-webpack/blob/master/package.json)；\n- 不能简单的自动生成HTML；\n\n这个项目我用Parcel时花在构建配置上的时间不到一分钟，而用Webpack构建时花了5分钟去配置。\n\n### Parcel还需要时间去打磨\n通过以上项目实践，发现Parcel目前有如下明显的缺点：\n\n- **不支持SourceMap**：在开发模式下，Parcel也不会输出SourceMap，目前只能去调试可读性极低的代码；\n- **不支持剔除无效代码(TreeShaking)**：很多时候我们只用到了库中的一个函数，结果Parcel把整个库都打包了进来；\n- **一些依赖会让Parcel出错**：当你的项目依赖了一些Npm上的模块时，有些Npm模块会让Parcel运行错误；\n\n\n### Parcel需要为零配置付出代价\n零配置其实是把各种常见的场景做为默认值来实现的，这虽然能节省很多工作量，快速上手，但这同时会带来一些问题：\n\n- **不守规矩的node_module**：有些依赖的库在发布到Npm上时可能不小心把`.babelrc` `postcss.config.js` `tsconfig.json`这些配置文件也一起发布上去了，\n由于目前Parcel只要在目录中发现这些配置文件就会认为该项目中的代码需要被处理。例如mini-store这个库中就把`.babelrc`文件发布到了Npm上，项目依赖的本来是lib中已经编译成了ES5的JS代码了，但Parcel还会去用Babel处理一遍。\nNpm官方并没有规定发布到Npm上的包需要符合哪些规范，这会让Parcel很为难。\n- **不灵活的配置**：零配置的Parcel关闭了很多配置项，在一些需要的配置的场景下无法改变。例如：\n    - 无法控制对部分文件的特殊处理，以实现诸如按需加载这样的需求；\n    - 无法控制[输出文件名的Hash值和名称](http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-2Output.html)；\n    - 无法控制构建输出目录结构；\n    - 无法[映射路径以缩短导入语句](http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-4Resolve.html)；\n    - HTTP开发服务器不支持[HistoryApi](http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-6DevServer.html)；\n\n### Parcel使用场景受限\n目前Parcel**只能用来构建用于运行在浏览器中的网页**，这也是他的出发点和专注点。\n在软件行业不可能存在即使用简单又可以适应各种场景的方案，就算所谓的人工智能也许能解决这个问题，但人工智能不能保证100%的正确性。\n\n反观Webpack除了用于构建网页，还可以做：\n\n- [打包发布到Npm上的库](http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-13%E6%9E%84%E5%BB%BANpm%E6%A8%A1%E5%9D%97.html)\n- [构建Node.js应用(同构应用)](http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-11%E6%9E%84%E5%BB%BA%E5%90%8C%E6%9E%84%E5%BA%94%E7%94%A8.html)\n- [构建Electron应用](http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-12%E6%9E%84%E5%BB%BAElectron%E5%BA%94%E7%94%A8.html)\n- [构建离线应用(ServiceWorkers)](http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-14%E6%9E%84%E5%BB%BA%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8.html)\n\n### 构建速度和输出文件大小对比\n分别去用Parcel和Webpack构建以上项目，收集的数据如下：\n\n| 数据项 | Parcel | Webpack |\n| --- |--- | --- |\n| 生成环境构建时间 | 8.310s | 9.58s |\n| 开发环境启动时间 | 5.42s | 8.06s |\n| 监听变化构建时间 | 3.17s | 2.87s |\n| 生成环境输出JS文件大小 | 544K | 274K |\n| 生成环境输出CSS文件大小 | 23K | 23K |\n\n从以上数据可以看出：**Parcel构建速度快，但Parcel输出文件大**\n\n导致Parcel构建速度快的原因和iOS比Android用起来更流畅的原因类似：\n- Parcel因为一体化内置，所以集成和优化的更好，而Webpack通过插件和Loader机制去让第三方扩展这会拉低性能；\n- Parcel内置多进程并行构建，而Webpack默认是单进程构建（[Webpack也支持多进程](http://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-3%E4%BD%BF%E7%94%A8HappyPack.html)）；\n\n导致Parcel输出JS文件大的原因在于：\n- 不支持TreeShaking \n- 构建出的JS中出现了所有文件的名称，如图：\n    ![](https://user-images.githubusercontent.com/5773264/34382680-8bd638e0-eb4b-11e7-9edf-9cbdf5c36b93.png)\n\n> 以上[项目完整源码可下载](https://github.com/gwuhaolin/parcel-vs-webpack)\n\n### 总结\n现阶段的Parcel就像beta版的iPhone，看上去很美好但还不能用于生成环境，如果你现在就把Parcel用于生成环境，相信我你一定会踩很多坑。\n踩坑不要紧，要命的是无法在网上找到解决方法以快速解决问题。\n\n我不是不鼓励大家使用Parcel，历史总需要先驱去推动，就像乔布斯义无反顾的引领了一个时代，我们也需要去实践Parcel，坑都是一个个填平的，所以我鼓励大家在一些个人小项目中使用Parcel。\n\n如果Parcel能解决上面提到的这些问题，我会毫不犹豫的在我的下一个项目中使用他。\n\n[阅读原文](http://wuhaolin.cn/2017/12/27/Parcel%20Vs%20Webpack/)","source":"_posts/Parcel Vs Webpack.md","raw":"---\ntitle: Parcel Vs Webpack\ndate: 2017-12-27T13:21:56Z\nurl: https://github.com/gwuhaolin/blog/issues/13\ntags:\n    - webpack\n---\n\n> 爱折腾的前端圈时常会有新轮子诞生，只要是好东西就能快速获得大量关注，资历再好的大哥只要不如新人也很快会被替代。\n\n横空出世的[Parcel](https://parceljs.org/)近日成为了前端圈的又一大热点，在短短几周内就获得了13K的Star。\n作为前端构建工具新人的Parcel为什么能在短期内获得这么多赞同？他和老大哥Webpack比起来到底有什么优势呢？\n\n我花了6个月的时间写了一本全面介绍Webpack的图书[《深入浅出 Webpack》](http://webpack.wuhaolin.cn/)近日刚出版，感觉被新出的Parcel给腰斩了。\n但本文将本着公平公正的心态来详细对比一下他两，让你能明白他们直接的异同和优缺点对比，好决定是选Parcel还是Webpack。\n\n为了对比他两，我们从实际出发举一个实战项目为例子，分别用Parcel和Webpack去实现，实战项目要求如下：\n\n- 项目采用TypeScript+React+SCSS；\n- 项目采用了[Antd](https://ant.design) UI组件库，但要做到按需加载只用到了的组件，而不是所有组件都打包进去；\n- 项目使用了[Lodash](https://lodash.com)库，用于检查构建是否有剔除无用代码的能力(TreeShaking)；\n- 构建需要支持模块热替换功能，以提高开发效率；\n- 支持SourceMap，以方便调试；\n- 对比他们的首次启动速度和监听变化时的构建速度；\n- 在生成环境下需要压缩JS、CSS，CSS需要提取到单独到文件，并对比他们在生产环境下构建出文件大小；\n- 需要生成自动会加载对应资源的HTML文件；\n\n\n### Parcel让人眼前一亮\n在用了很久Webpack后用Parcel的感觉就像用了很久Android机后用iPhone，不用再去操心细节和配置，大多数时候Parcel刚刚够用而且用的很舒服。\n\n用Parcel去完成以上项目的要求，我只是专心去写项目页面所必须的代码，Parcel智能快速的帮我构建出了能正常运行的结果。\n\n以下是Parcel让我心动的点：\n- Parcel能做到无配置完成以上项目构建要求；\n- Parcel内置了常见场景的构建方案及其依赖，无需再安装各种依赖；\n- Parcel能以HTML为入口，自动检测和打包依赖资源；\n- Parcel默认支持模块热替换，真正的开箱即用；\n\n而反观Webpack，比Parcel要麻烦很多：\n- 需要写[一堆配置](https://github.com/gwuhaolin/parcel-vs-webpack/blob/master/webpack.config.js)；\n- 需要再安装[一堆依赖](https://github.com/gwuhaolin/parcel-vs-webpack/blob/master/package.json)；\n- 不能简单的自动生成HTML；\n\n这个项目我用Parcel时花在构建配置上的时间不到一分钟，而用Webpack构建时花了5分钟去配置。\n\n### Parcel还需要时间去打磨\n通过以上项目实践，发现Parcel目前有如下明显的缺点：\n\n- **不支持SourceMap**：在开发模式下，Parcel也不会输出SourceMap，目前只能去调试可读性极低的代码；\n- **不支持剔除无效代码(TreeShaking)**：很多时候我们只用到了库中的一个函数，结果Parcel把整个库都打包了进来；\n- **一些依赖会让Parcel出错**：当你的项目依赖了一些Npm上的模块时，有些Npm模块会让Parcel运行错误；\n\n\n### Parcel需要为零配置付出代价\n零配置其实是把各种常见的场景做为默认值来实现的，这虽然能节省很多工作量，快速上手，但这同时会带来一些问题：\n\n- **不守规矩的node_module**：有些依赖的库在发布到Npm上时可能不小心把`.babelrc` `postcss.config.js` `tsconfig.json`这些配置文件也一起发布上去了，\n由于目前Parcel只要在目录中发现这些配置文件就会认为该项目中的代码需要被处理。例如mini-store这个库中就把`.babelrc`文件发布到了Npm上，项目依赖的本来是lib中已经编译成了ES5的JS代码了，但Parcel还会去用Babel处理一遍。\nNpm官方并没有规定发布到Npm上的包需要符合哪些规范，这会让Parcel很为难。\n- **不灵活的配置**：零配置的Parcel关闭了很多配置项，在一些需要的配置的场景下无法改变。例如：\n    - 无法控制对部分文件的特殊处理，以实现诸如按需加载这样的需求；\n    - 无法控制[输出文件名的Hash值和名称](http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-2Output.html)；\n    - 无法控制构建输出目录结构；\n    - 无法[映射路径以缩短导入语句](http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-4Resolve.html)；\n    - HTTP开发服务器不支持[HistoryApi](http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-6DevServer.html)；\n\n### Parcel使用场景受限\n目前Parcel**只能用来构建用于运行在浏览器中的网页**，这也是他的出发点和专注点。\n在软件行业不可能存在即使用简单又可以适应各种场景的方案，就算所谓的人工智能也许能解决这个问题，但人工智能不能保证100%的正确性。\n\n反观Webpack除了用于构建网页，还可以做：\n\n- [打包发布到Npm上的库](http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-13%E6%9E%84%E5%BB%BANpm%E6%A8%A1%E5%9D%97.html)\n- [构建Node.js应用(同构应用)](http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-11%E6%9E%84%E5%BB%BA%E5%90%8C%E6%9E%84%E5%BA%94%E7%94%A8.html)\n- [构建Electron应用](http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-12%E6%9E%84%E5%BB%BAElectron%E5%BA%94%E7%94%A8.html)\n- [构建离线应用(ServiceWorkers)](http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-14%E6%9E%84%E5%BB%BA%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8.html)\n\n### 构建速度和输出文件大小对比\n分别去用Parcel和Webpack构建以上项目，收集的数据如下：\n\n| 数据项 | Parcel | Webpack |\n| --- |--- | --- |\n| 生成环境构建时间 | 8.310s | 9.58s |\n| 开发环境启动时间 | 5.42s | 8.06s |\n| 监听变化构建时间 | 3.17s | 2.87s |\n| 生成环境输出JS文件大小 | 544K | 274K |\n| 生成环境输出CSS文件大小 | 23K | 23K |\n\n从以上数据可以看出：**Parcel构建速度快，但Parcel输出文件大**\n\n导致Parcel构建速度快的原因和iOS比Android用起来更流畅的原因类似：\n- Parcel因为一体化内置，所以集成和优化的更好，而Webpack通过插件和Loader机制去让第三方扩展这会拉低性能；\n- Parcel内置多进程并行构建，而Webpack默认是单进程构建（[Webpack也支持多进程](http://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-3%E4%BD%BF%E7%94%A8HappyPack.html)）；\n\n导致Parcel输出JS文件大的原因在于：\n- 不支持TreeShaking \n- 构建出的JS中出现了所有文件的名称，如图：\n    ![](https://user-images.githubusercontent.com/5773264/34382680-8bd638e0-eb4b-11e7-9edf-9cbdf5c36b93.png)\n\n> 以上[项目完整源码可下载](https://github.com/gwuhaolin/parcel-vs-webpack)\n\n### 总结\n现阶段的Parcel就像beta版的iPhone，看上去很美好但还不能用于生成环境，如果你现在就把Parcel用于生成环境，相信我你一定会踩很多坑。\n踩坑不要紧，要命的是无法在网上找到解决方法以快速解决问题。\n\n我不是不鼓励大家使用Parcel，历史总需要先驱去推动，就像乔布斯义无反顾的引领了一个时代，我们也需要去实践Parcel，坑都是一个个填平的，所以我鼓励大家在一些个人小项目中使用Parcel。\n\n如果Parcel能解决上面提到的这些问题，我会毫不犹豫的在我的下一个项目中使用他。\n\n[阅读原文](http://wuhaolin.cn/2017/12/27/Parcel%20Vs%20Webpack/)","slug":"Parcel Vs Webpack","published":1,"updated":"2018-11-14T04:39:28.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjogs0kds0001g5tc31zpbenn","content":"<blockquote>\n<p>爱折腾的前端圈时常会有新轮子诞生，只要是好东西就能快速获得大量关注，资历再好的大哥只要不如新人也很快会被替代。</p>\n</blockquote>\n<p>横空出世的<a href=\"https://parceljs.org/\" target=\"_blank\" rel=\"noopener\">Parcel</a>近日成为了前端圈的又一大热点，在短短几周内就获得了13K的Star。<br>作为前端构建工具新人的Parcel为什么能在短期内获得这么多赞同？他和老大哥Webpack比起来到底有什么优势呢？</p>\n<p>我花了6个月的时间写了一本全面介绍Webpack的图书<a href=\"http://webpack.wuhaolin.cn/\" target=\"_blank\" rel=\"noopener\">《深入浅出 Webpack》</a>近日刚出版，感觉被新出的Parcel给腰斩了。<br>但本文将本着公平公正的心态来详细对比一下他两，让你能明白他们直接的异同和优缺点对比，好决定是选Parcel还是Webpack。</p>\n<p>为了对比他两，我们从实际出发举一个实战项目为例子，分别用Parcel和Webpack去实现，实战项目要求如下：</p>\n<ul>\n<li>项目采用TypeScript+React+SCSS；</li>\n<li>项目采用了<a href=\"https://ant.design\" target=\"_blank\" rel=\"noopener\">Antd</a> UI组件库，但要做到按需加载只用到了的组件，而不是所有组件都打包进去；</li>\n<li>项目使用了<a href=\"https://lodash.com\" target=\"_blank\" rel=\"noopener\">Lodash</a>库，用于检查构建是否有剔除无用代码的能力(TreeShaking)；</li>\n<li>构建需要支持模块热替换功能，以提高开发效率；</li>\n<li>支持SourceMap，以方便调试；</li>\n<li>对比他们的首次启动速度和监听变化时的构建速度；</li>\n<li>在生成环境下需要压缩JS、CSS，CSS需要提取到单独到文件，并对比他们在生产环境下构建出文件大小；</li>\n<li>需要生成自动会加载对应资源的HTML文件；</li>\n</ul>\n<h3 id=\"Parcel让人眼前一亮\"><a href=\"#Parcel让人眼前一亮\" class=\"headerlink\" title=\"Parcel让人眼前一亮\"></a>Parcel让人眼前一亮</h3><p>在用了很久Webpack后用Parcel的感觉就像用了很久Android机后用iPhone，不用再去操心细节和配置，大多数时候Parcel刚刚够用而且用的很舒服。</p>\n<p>用Parcel去完成以上项目的要求，我只是专心去写项目页面所必须的代码，Parcel智能快速的帮我构建出了能正常运行的结果。</p>\n<p>以下是Parcel让我心动的点：</p>\n<ul>\n<li>Parcel能做到无配置完成以上项目构建要求；</li>\n<li>Parcel内置了常见场景的构建方案及其依赖，无需再安装各种依赖；</li>\n<li>Parcel能以HTML为入口，自动检测和打包依赖资源；</li>\n<li>Parcel默认支持模块热替换，真正的开箱即用；</li>\n</ul>\n<p>而反观Webpack，比Parcel要麻烦很多：</p>\n<ul>\n<li>需要写<a href=\"https://github.com/gwuhaolin/parcel-vs-webpack/blob/master/webpack.config.js\" target=\"_blank\" rel=\"noopener\">一堆配置</a>；</li>\n<li>需要再安装<a href=\"https://github.com/gwuhaolin/parcel-vs-webpack/blob/master/package.json\" target=\"_blank\" rel=\"noopener\">一堆依赖</a>；</li>\n<li>不能简单的自动生成HTML；</li>\n</ul>\n<p>这个项目我用Parcel时花在构建配置上的时间不到一分钟，而用Webpack构建时花了5分钟去配置。</p>\n<h3 id=\"Parcel还需要时间去打磨\"><a href=\"#Parcel还需要时间去打磨\" class=\"headerlink\" title=\"Parcel还需要时间去打磨\"></a>Parcel还需要时间去打磨</h3><p>通过以上项目实践，发现Parcel目前有如下明显的缺点：</p>\n<ul>\n<li><strong>不支持SourceMap</strong>：在开发模式下，Parcel也不会输出SourceMap，目前只能去调试可读性极低的代码；</li>\n<li><strong>不支持剔除无效代码(TreeShaking)</strong>：很多时候我们只用到了库中的一个函数，结果Parcel把整个库都打包了进来；</li>\n<li><strong>一些依赖会让Parcel出错</strong>：当你的项目依赖了一些Npm上的模块时，有些Npm模块会让Parcel运行错误；</li>\n</ul>\n<h3 id=\"Parcel需要为零配置付出代价\"><a href=\"#Parcel需要为零配置付出代价\" class=\"headerlink\" title=\"Parcel需要为零配置付出代价\"></a>Parcel需要为零配置付出代价</h3><p>零配置其实是把各种常见的场景做为默认值来实现的，这虽然能节省很多工作量，快速上手，但这同时会带来一些问题：</p>\n<ul>\n<li><strong>不守规矩的node_module</strong>：有些依赖的库在发布到Npm上时可能不小心把<code>.babelrc</code> <code>postcss.config.js</code> <code>tsconfig.json</code>这些配置文件也一起发布上去了，<br>由于目前Parcel只要在目录中发现这些配置文件就会认为该项目中的代码需要被处理。例如mini-store这个库中就把<code>.babelrc</code>文件发布到了Npm上，项目依赖的本来是lib中已经编译成了ES5的JS代码了，但Parcel还会去用Babel处理一遍。<br>Npm官方并没有规定发布到Npm上的包需要符合哪些规范，这会让Parcel很为难。</li>\n<li><strong>不灵活的配置</strong>：零配置的Parcel关闭了很多配置项，在一些需要的配置的场景下无法改变。例如：<ul>\n<li>无法控制对部分文件的特殊处理，以实现诸如按需加载这样的需求；</li>\n<li>无法控制<a href=\"http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-2Output.html\" target=\"_blank\" rel=\"noopener\">输出文件名的Hash值和名称</a>；</li>\n<li>无法控制构建输出目录结构；</li>\n<li>无法<a href=\"http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-4Resolve.html\" target=\"_blank\" rel=\"noopener\">映射路径以缩短导入语句</a>；</li>\n<li>HTTP开发服务器不支持<a href=\"http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-6DevServer.html\" target=\"_blank\" rel=\"noopener\">HistoryApi</a>；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Parcel使用场景受限\"><a href=\"#Parcel使用场景受限\" class=\"headerlink\" title=\"Parcel使用场景受限\"></a>Parcel使用场景受限</h3><p>目前Parcel<strong>只能用来构建用于运行在浏览器中的网页</strong>，这也是他的出发点和专注点。<br>在软件行业不可能存在即使用简单又可以适应各种场景的方案，就算所谓的人工智能也许能解决这个问题，但人工智能不能保证100%的正确性。</p>\n<p>反观Webpack除了用于构建网页，还可以做：</p>\n<ul>\n<li><a href=\"http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-13%E6%9E%84%E5%BB%BANpm%E6%A8%A1%E5%9D%97.html\" target=\"_blank\" rel=\"noopener\">打包发布到Npm上的库</a></li>\n<li><a href=\"http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-11%E6%9E%84%E5%BB%BA%E5%90%8C%E6%9E%84%E5%BA%94%E7%94%A8.html\" target=\"_blank\" rel=\"noopener\">构建Node.js应用(同构应用)</a></li>\n<li><a href=\"http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-12%E6%9E%84%E5%BB%BAElectron%E5%BA%94%E7%94%A8.html\" target=\"_blank\" rel=\"noopener\">构建Electron应用</a></li>\n<li><a href=\"http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-14%E6%9E%84%E5%BB%BA%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8.html\" target=\"_blank\" rel=\"noopener\">构建离线应用(ServiceWorkers)</a></li>\n</ul>\n<h3 id=\"构建速度和输出文件大小对比\"><a href=\"#构建速度和输出文件大小对比\" class=\"headerlink\" title=\"构建速度和输出文件大小对比\"></a>构建速度和输出文件大小对比</h3><p>分别去用Parcel和Webpack构建以上项目，收集的数据如下：</p>\n<table>\n<thead>\n<tr>\n<th>数据项</th>\n<th>Parcel</th>\n<th>Webpack</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>生成环境构建时间</td>\n<td>8.310s</td>\n<td>9.58s</td>\n</tr>\n<tr>\n<td>开发环境启动时间</td>\n<td>5.42s</td>\n<td>8.06s</td>\n</tr>\n<tr>\n<td>监听变化构建时间</td>\n<td>3.17s</td>\n<td>2.87s</td>\n</tr>\n<tr>\n<td>生成环境输出JS文件大小</td>\n<td>544K</td>\n<td>274K</td>\n</tr>\n<tr>\n<td>生成环境输出CSS文件大小</td>\n<td>23K</td>\n<td>23K</td>\n</tr>\n</tbody>\n</table>\n<p>从以上数据可以看出：<strong>Parcel构建速度快，但Parcel输出文件大</strong></p>\n<p>导致Parcel构建速度快的原因和iOS比Android用起来更流畅的原因类似：</p>\n<ul>\n<li>Parcel因为一体化内置，所以集成和优化的更好，而Webpack通过插件和Loader机制去让第三方扩展这会拉低性能；</li>\n<li>Parcel内置多进程并行构建，而Webpack默认是单进程构建（<a href=\"http://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-3%E4%BD%BF%E7%94%A8HappyPack.html\" target=\"_blank\" rel=\"noopener\">Webpack也支持多进程</a>）；</li>\n</ul>\n<p>导致Parcel输出JS文件大的原因在于：</p>\n<ul>\n<li>不支持TreeShaking </li>\n<li>构建出的JS中出现了所有文件的名称，如图：<br>  <img src=\"https://user-images.githubusercontent.com/5773264/34382680-8bd638e0-eb4b-11e7-9edf-9cbdf5c36b93.png\" alt=\"\"></li>\n</ul>\n<blockquote>\n<p>以上<a href=\"https://github.com/gwuhaolin/parcel-vs-webpack\" target=\"_blank\" rel=\"noopener\">项目完整源码可下载</a></p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>现阶段的Parcel就像beta版的iPhone，看上去很美好但还不能用于生成环境，如果你现在就把Parcel用于生成环境，相信我你一定会踩很多坑。<br>踩坑不要紧，要命的是无法在网上找到解决方法以快速解决问题。</p>\n<p>我不是不鼓励大家使用Parcel，历史总需要先驱去推动，就像乔布斯义无反顾的引领了一个时代，我们也需要去实践Parcel，坑都是一个个填平的，所以我鼓励大家在一些个人小项目中使用Parcel。</p>\n<p>如果Parcel能解决上面提到的这些问题，我会毫不犹豫的在我的下一个项目中使用他。</p>\n<p><a href=\"http://wuhaolin.cn/2017/12/27/Parcel%20Vs%20Webpack/\">阅读原文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>爱折腾的前端圈时常会有新轮子诞生，只要是好东西就能快速获得大量关注，资历再好的大哥只要不如新人也很快会被替代。</p>\n</blockquote>\n<p>横空出世的<a href=\"https://parceljs.org/\" target=\"_blank\" rel=\"noopener\">Parcel</a>近日成为了前端圈的又一大热点，在短短几周内就获得了13K的Star。<br>作为前端构建工具新人的Parcel为什么能在短期内获得这么多赞同？他和老大哥Webpack比起来到底有什么优势呢？</p>\n<p>我花了6个月的时间写了一本全面介绍Webpack的图书<a href=\"http://webpack.wuhaolin.cn/\" target=\"_blank\" rel=\"noopener\">《深入浅出 Webpack》</a>近日刚出版，感觉被新出的Parcel给腰斩了。<br>但本文将本着公平公正的心态来详细对比一下他两，让你能明白他们直接的异同和优缺点对比，好决定是选Parcel还是Webpack。</p>\n<p>为了对比他两，我们从实际出发举一个实战项目为例子，分别用Parcel和Webpack去实现，实战项目要求如下：</p>\n<ul>\n<li>项目采用TypeScript+React+SCSS；</li>\n<li>项目采用了<a href=\"https://ant.design\" target=\"_blank\" rel=\"noopener\">Antd</a> UI组件库，但要做到按需加载只用到了的组件，而不是所有组件都打包进去；</li>\n<li>项目使用了<a href=\"https://lodash.com\" target=\"_blank\" rel=\"noopener\">Lodash</a>库，用于检查构建是否有剔除无用代码的能力(TreeShaking)；</li>\n<li>构建需要支持模块热替换功能，以提高开发效率；</li>\n<li>支持SourceMap，以方便调试；</li>\n<li>对比他们的首次启动速度和监听变化时的构建速度；</li>\n<li>在生成环境下需要压缩JS、CSS，CSS需要提取到单独到文件，并对比他们在生产环境下构建出文件大小；</li>\n<li>需要生成自动会加载对应资源的HTML文件；</li>\n</ul>\n<h3 id=\"Parcel让人眼前一亮\"><a href=\"#Parcel让人眼前一亮\" class=\"headerlink\" title=\"Parcel让人眼前一亮\"></a>Parcel让人眼前一亮</h3><p>在用了很久Webpack后用Parcel的感觉就像用了很久Android机后用iPhone，不用再去操心细节和配置，大多数时候Parcel刚刚够用而且用的很舒服。</p>\n<p>用Parcel去完成以上项目的要求，我只是专心去写项目页面所必须的代码，Parcel智能快速的帮我构建出了能正常运行的结果。</p>\n<p>以下是Parcel让我心动的点：</p>\n<ul>\n<li>Parcel能做到无配置完成以上项目构建要求；</li>\n<li>Parcel内置了常见场景的构建方案及其依赖，无需再安装各种依赖；</li>\n<li>Parcel能以HTML为入口，自动检测和打包依赖资源；</li>\n<li>Parcel默认支持模块热替换，真正的开箱即用；</li>\n</ul>\n<p>而反观Webpack，比Parcel要麻烦很多：</p>\n<ul>\n<li>需要写<a href=\"https://github.com/gwuhaolin/parcel-vs-webpack/blob/master/webpack.config.js\" target=\"_blank\" rel=\"noopener\">一堆配置</a>；</li>\n<li>需要再安装<a href=\"https://github.com/gwuhaolin/parcel-vs-webpack/blob/master/package.json\" target=\"_blank\" rel=\"noopener\">一堆依赖</a>；</li>\n<li>不能简单的自动生成HTML；</li>\n</ul>\n<p>这个项目我用Parcel时花在构建配置上的时间不到一分钟，而用Webpack构建时花了5分钟去配置。</p>\n<h3 id=\"Parcel还需要时间去打磨\"><a href=\"#Parcel还需要时间去打磨\" class=\"headerlink\" title=\"Parcel还需要时间去打磨\"></a>Parcel还需要时间去打磨</h3><p>通过以上项目实践，发现Parcel目前有如下明显的缺点：</p>\n<ul>\n<li><strong>不支持SourceMap</strong>：在开发模式下，Parcel也不会输出SourceMap，目前只能去调试可读性极低的代码；</li>\n<li><strong>不支持剔除无效代码(TreeShaking)</strong>：很多时候我们只用到了库中的一个函数，结果Parcel把整个库都打包了进来；</li>\n<li><strong>一些依赖会让Parcel出错</strong>：当你的项目依赖了一些Npm上的模块时，有些Npm模块会让Parcel运行错误；</li>\n</ul>\n<h3 id=\"Parcel需要为零配置付出代价\"><a href=\"#Parcel需要为零配置付出代价\" class=\"headerlink\" title=\"Parcel需要为零配置付出代价\"></a>Parcel需要为零配置付出代价</h3><p>零配置其实是把各种常见的场景做为默认值来实现的，这虽然能节省很多工作量，快速上手，但这同时会带来一些问题：</p>\n<ul>\n<li><strong>不守规矩的node_module</strong>：有些依赖的库在发布到Npm上时可能不小心把<code>.babelrc</code> <code>postcss.config.js</code> <code>tsconfig.json</code>这些配置文件也一起发布上去了，<br>由于目前Parcel只要在目录中发现这些配置文件就会认为该项目中的代码需要被处理。例如mini-store这个库中就把<code>.babelrc</code>文件发布到了Npm上，项目依赖的本来是lib中已经编译成了ES5的JS代码了，但Parcel还会去用Babel处理一遍。<br>Npm官方并没有规定发布到Npm上的包需要符合哪些规范，这会让Parcel很为难。</li>\n<li><strong>不灵活的配置</strong>：零配置的Parcel关闭了很多配置项，在一些需要的配置的场景下无法改变。例如：<ul>\n<li>无法控制对部分文件的特殊处理，以实现诸如按需加载这样的需求；</li>\n<li>无法控制<a href=\"http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-2Output.html\" target=\"_blank\" rel=\"noopener\">输出文件名的Hash值和名称</a>；</li>\n<li>无法控制构建输出目录结构；</li>\n<li>无法<a href=\"http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-4Resolve.html\" target=\"_blank\" rel=\"noopener\">映射路径以缩短导入语句</a>；</li>\n<li>HTTP开发服务器不支持<a href=\"http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-6DevServer.html\" target=\"_blank\" rel=\"noopener\">HistoryApi</a>；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Parcel使用场景受限\"><a href=\"#Parcel使用场景受限\" class=\"headerlink\" title=\"Parcel使用场景受限\"></a>Parcel使用场景受限</h3><p>目前Parcel<strong>只能用来构建用于运行在浏览器中的网页</strong>，这也是他的出发点和专注点。<br>在软件行业不可能存在即使用简单又可以适应各种场景的方案，就算所谓的人工智能也许能解决这个问题，但人工智能不能保证100%的正确性。</p>\n<p>反观Webpack除了用于构建网页，还可以做：</p>\n<ul>\n<li><a href=\"http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-13%E6%9E%84%E5%BB%BANpm%E6%A8%A1%E5%9D%97.html\" target=\"_blank\" rel=\"noopener\">打包发布到Npm上的库</a></li>\n<li><a href=\"http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-11%E6%9E%84%E5%BB%BA%E5%90%8C%E6%9E%84%E5%BA%94%E7%94%A8.html\" target=\"_blank\" rel=\"noopener\">构建Node.js应用(同构应用)</a></li>\n<li><a href=\"http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-12%E6%9E%84%E5%BB%BAElectron%E5%BA%94%E7%94%A8.html\" target=\"_blank\" rel=\"noopener\">构建Electron应用</a></li>\n<li><a href=\"http://webpack.wuhaolin.cn/3%E5%AE%9E%E6%88%98/3-14%E6%9E%84%E5%BB%BA%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8.html\" target=\"_blank\" rel=\"noopener\">构建离线应用(ServiceWorkers)</a></li>\n</ul>\n<h3 id=\"构建速度和输出文件大小对比\"><a href=\"#构建速度和输出文件大小对比\" class=\"headerlink\" title=\"构建速度和输出文件大小对比\"></a>构建速度和输出文件大小对比</h3><p>分别去用Parcel和Webpack构建以上项目，收集的数据如下：</p>\n<table>\n<thead>\n<tr>\n<th>数据项</th>\n<th>Parcel</th>\n<th>Webpack</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>生成环境构建时间</td>\n<td>8.310s</td>\n<td>9.58s</td>\n</tr>\n<tr>\n<td>开发环境启动时间</td>\n<td>5.42s</td>\n<td>8.06s</td>\n</tr>\n<tr>\n<td>监听变化构建时间</td>\n<td>3.17s</td>\n<td>2.87s</td>\n</tr>\n<tr>\n<td>生成环境输出JS文件大小</td>\n<td>544K</td>\n<td>274K</td>\n</tr>\n<tr>\n<td>生成环境输出CSS文件大小</td>\n<td>23K</td>\n<td>23K</td>\n</tr>\n</tbody>\n</table>\n<p>从以上数据可以看出：<strong>Parcel构建速度快，但Parcel输出文件大</strong></p>\n<p>导致Parcel构建速度快的原因和iOS比Android用起来更流畅的原因类似：</p>\n<ul>\n<li>Parcel因为一体化内置，所以集成和优化的更好，而Webpack通过插件和Loader机制去让第三方扩展这会拉低性能；</li>\n<li>Parcel内置多进程并行构建，而Webpack默认是单进程构建（<a href=\"http://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-3%E4%BD%BF%E7%94%A8HappyPack.html\" target=\"_blank\" rel=\"noopener\">Webpack也支持多进程</a>）；</li>\n</ul>\n<p>导致Parcel输出JS文件大的原因在于：</p>\n<ul>\n<li>不支持TreeShaking </li>\n<li>构建出的JS中出现了所有文件的名称，如图：<br>  <img src=\"https://user-images.githubusercontent.com/5773264/34382680-8bd638e0-eb4b-11e7-9edf-9cbdf5c36b93.png\" alt=\"\"></li>\n</ul>\n<blockquote>\n<p>以上<a href=\"https://github.com/gwuhaolin/parcel-vs-webpack\" target=\"_blank\" rel=\"noopener\">项目完整源码可下载</a></p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>现阶段的Parcel就像beta版的iPhone，看上去很美好但还不能用于生成环境，如果你现在就把Parcel用于生成环境，相信我你一定会踩很多坑。<br>踩坑不要紧，要命的是无法在网上找到解决方法以快速解决问题。</p>\n<p>我不是不鼓励大家使用Parcel，历史总需要先驱去推动，就像乔布斯义无反顾的引领了一个时代，我们也需要去实践Parcel，坑都是一个个填平的，所以我鼓励大家在一些个人小项目中使用Parcel。</p>\n<p>如果Parcel能解决上面提到的这些问题，我会毫不犹豫的在我的下一个项目中使用他。</p>\n<p><a href=\"http://wuhaolin.cn/2017/12/27/Parcel%20Vs%20Webpack/\">阅读原文</a></p>\n"},{"title":"ReactNative三端同构实战","date":"2018-11-13T20:21:47.000Z","url":"https://github.com/gwuhaolin/blog/issues/18","_content":"\n## 认识ReactNative三端同构\n\nReactNative三端同构是指在不改动原ReactNative的代码下，让其在浏览器中运行出和在ReactNative环境下一样的页面。\n\nReactNative三端同构的应用场景包括：\n\n- 在ReactNative页面崩溃时用对应的Web页兜底，以保证用户可以正常使用页面；\n- 对于需要分享到社交网络的页面，例如需要分享到微信朋友圈、微博的页面，不可避免的需要Web网页。\n\n对于使用ReactNative开发的页面，如果又单独为Web平台重复写一份代码代价是极其大的，而ReactNative三端同构能以零花费快速做到一份代码三端复用。\n\n## ReactNative三端同构基础原理\n\nReactNative就像一套新的浏览器标准，ReactNative提供了大量内置的原生UI元素和系统API，对应着浏览器中的div、img等标签以及BOM API；但是ReactNative目前只专注于移动App平台，只适配了iOS和Android两大系统，而浏览器则是适配了各种操作系统，由于ReactNative需要适配的平台更少所以性能会比浏览器要好。\n\n我们编写的React组件经过render后会以虚拟DOM的形式存储在内存中，React只负责UI层面的抽象和组件的状态管理，各平台都可用虚拟DOM去渲染出不同的结果，React架构如下：\n\n<img width=\"719\" alt=\"react\" src=\"https://user-images.githubusercontent.com/5773264/48459964-77f8a880-e807-11e8-9e5f-37f4145e7efe.png\">\n\n\n由此可见虚拟DOM这层中间抽象在实现React渲染到多端时发挥了很大的作用。\n\n## ReactNative三端同构方案对比\n\n目前社区中已经有多个ReactNative三端同构方案，比较成熟的有[react-native-web](https://github.com/necolas/react-native-web)和[reactxp](https://github.com/Microsoft/reactxp)，下来从多方面对比二者以帮助你做出合适的选择。\n\n#### 认识reactxp\n\nreactxp是一个跨平台的UI库，由微软Skype团队维护和开源，Skype产品中就大量使用了它来实现写一份代码运行在多个平台上。目前reactxp支持以下平台：\n\n- iOS（基于react-native渲染）；\n- Android（基于react-native渲染）；\n- Web（基于react-dom渲染）；\n- [UWP](https://en.wikipedia.org/wiki/Universal_Windows_Platform) (基于[react-native-windows](https://github.com/Microsoft/react-native-windows)渲染)；\n- 对于剩下的平台，诸如Mac、Windows10以下系统、Linux桌面，则采用基于Web渲染的[Electron](https://electron.atom.io/)。\n\n#### reactxp实现原理\n\nreactxp充份发挥了react虚拟DOM的优势，它其实只是充当胶水的作用，把各个平台的渲染引擎整合起来，对外暴露平台一致的接口。\n\nreactxp为各个平台都实现了一份代码，在构建的过程中构建工具会自动选择平台相关的代码进行打包输出。\n\n![reactxp arch](https://user-images.githubusercontent.com/5773264/48459985-88a91e80-e807-11e8-81ee-8d5e0f3856eb.png)\n\n\n#### reactxp和react-native的异同点\n\n从使用层面来说它们最大的区别在于：**reactxp是为了一份代码在多个平台运行，而react-native是为了学一遍可为多个平台编写原生应用**。\n\n这一点从reactxp和react-native暴露出的API就可以看出来：react-native中大量诸如SegmentedControlIOS、PermissionsAndroid这样针对特定平台的API，而reactxp中所有的API在所有端中都可以正常调用。\n\n事实上react-native也在为多端接口统一做努力，react-native中的大多数接口是可以在多端运行一致的，但为了保证灵活性react-native也提供了平台相关的接口。而reactxp磨平了多端接口的差异，但这也导致reactxp灵活性降低。\n\n他们的相同点是都采用了react框架编程的思想，由于reactxp是基于react-native封装的导致他们大多数API的使用方式都是一致的。\n\n#### react-native-web原理\n\nreact-native-web实现了在不修改react-native代码的情况下渲染在浏览器里的功能，其实现原理如下：\n\n在用webpack构建用于运行在浏览器里的代码时，会把react-native的导入路径替换为react-native-web的导入路径，在react-native-web内部则会以和react-native目录结构一致的方式实现了一致的react-native组件。在react-native-web组件的内部，则把react-native的API映射成了浏览器支持的API。\n\n![react-native-web arch](https://user-images.githubusercontent.com/5773264/48459994-952d7700-e807-11e8-976f-4e4777a8b1c5.png)\n\n\n#### react-native-web和reactxp异同点\n\n它们的目的都是为了实现多端同构，但react-native-web只专注于Web平台的适配，而reactxp则还需要适配UWP平台。\n\n在实现Web平台的适配过程中它们都采用了类似的原理：把对外暴露的API或组件映射到Web平台去。\n\n但在实现Web平台的样式适配时有细微区别：\n\n- reactxp全部通过内联样式实现；\n- react-native-web通过为每条不同的样式生产一个className，对于重复出现的样式则通过复用className实现。\n\n对于这两种不同的实现方式，我更看好react-native-web的实现方式，原因有两个：\n\n1. 通过复用className节省网络传输字节，如果你需要做服务端渲染这个优势会凸显出来；\n2. 通过className的方式浏览器渲染性能更好，原因是浏览器有做样式计算缓存优化，有人专门写了[性能对比测试页面](https://jsperf.com/inline-style-vs-css-class/2)。\n\n#### reactxp优点\n\n- 写一份代码就可实现多端渲染，对于有多端需求的产品可以减少代码量和人力；\n- 由微软Skype团队维护并且用于Skype产品中，有大公司投入资源支持；\n- 基于TypeScript编写，对IDE友好；\n\n#### reactxp缺点\n\n- 为了抹平多端平台差异导致灵活性降低，暴露的组件和API较react-native要少很多；\n- 需要兼容UWP平台导致包袱更重，而目前会针对Windows桌面或手机开发应用的产品也再渐渐减少，大多数产品不需要支持Windows平台；\n- 需要多导入reactxp这个库，导致打包输出的bundle会变大；并且由于多了一层适配，运行时性能肯定是不如直接使用react-native。\n\n其中最为致命的缺点可能在于目前reactxp支持的组件和API相当匮乏，一些比较细的操作无法控制；如果你在reactxp项目中确实有需求超出reactxp的能力范围，可以通过导入和使用react-native实现，但这会导致整个项目脱离reactxp体系，因此reactxp为我们实现的多端同构将会无法实现；\n\nreactxp只保证在它的体型内实现多端同构，但在它的体系内却有很多API不可用。\n\nreactxp更像是微软为了挽救其奄奄一息的[Windows Phone](https://en.wikipedia.org/wiki/Windows_Phone)系统在做努力，但事实上微软已经失去了移动操作系统市场，无人愿意为用户量很少的WP系统开发APP。\n\n#### react-native-web和reactxp对比表\n\n|                | reactxp                                                      | react-native-web                                             | 对比                                                         |\n| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 维护人         | 微软Skype团队和GitHub社区                                    | 来自Twitter的个人[necolas](https://github.com/necolas)和GitHub社区 | reactxp小胜                                                  |\n| 服务端渲染支持 | [官方没有明确要支持](https://github.com/Microsoft/reactxp/issues/201) | 完全支持                                                     | react-native-web胜                                           |\n| Web端包大小    | 435KB                                                        | 354.4KB                                                      | react-native-web胜                                           |\n| 写代码效率     | 针对reactxp暴露的API去实现多端适配                           | 需要自己去验证代码在多端的表现是否一致                       | reactxp胜                                                    |\n| 学习成本       | 除了需要学习reactxp外，不可避免的还需要学习react-native      | 只需学习react-native即可                                     | react-native-web胜                                           |\n| Github数据     | start=2017年4月 star=6521 issues=23/739 commits=814          | start=2017年7月 star=10151 issues=45/1034 commits=1248       | react-native-web用户更多，代码变动频率更大。reactxp问题响应速度更快。 |\n\n#### 如何选择\n\n如果你开发的产品有适配UWP平台的需求就选择reactxp，否则选择react-native-web，因为reactxp相比于react-native-web除了多支持Windows平台外，并无其它明显优势。\n\n## react-native-web接入\n\n为了给你现有的ReactNative接入react-native-web，实现ReactNative三端同构的能力，你需要做以下事情：\n\n1. 安装新的依赖：\n\n   ```base\n   # 运行时依赖\n   npm i react react-dom react-native-web react-art\n   # 构建工具\n   npm i -D webpack webpack-dev-server webpack-cli babel-loader babel-plugin-transform-runtime\n   ```\n\n2. 为Web平台写一份Webpack配置文件webpack.config.js，内容如下:\n\n   ```js\n   module.exports = {\n     module: {\n       rules: [\n         {\n           // 支持图片等静态文件的加载\n           test: /\\.(gif|jpe?g|png|svg)$/,\n           use: {\n             loader: 'file-loader'\n           }\n         },\n         {\n   \t\t// react-native包中有很多es6语法的js，需要用babel转换后才能在浏览器中运行\n           test: /\\.js$/,\n           use: {\n             loader: 'babel-loader',\n             options: {\n               cacheDirectory: false,\n               presets: ['react-native'],\n               plugins: [\n                 // 支持 async/await 语法\n                 'transform-runtime'\n               ]\n             }\n           }\n         }\n       ]\n     },\n     resolve: {\n       // 优先加载以web.js结尾的针对web平台的文件\n       extensions: {\n           '.web.js',\n           '.js',\n           '.json',\n       },\n       alias: {\n          // 把react-native包映射成react-native-web\n         'react-native$': 'react-native-web'\n       }\n     }\n   }\n   ```\n\n3. 写一个针对Web平台启动入口文件index.web.js：\n\n   ```js\n   import { AppRegistry } from 'react-native';\n   \n   // 注册组件\n   AppRegistry.registerComponent('App', () => App);\n   \n   // 启动App组件\n   AppRegistry.runApplication('App', {\n     // 启动时传给App组件的属性\n     initialProps: {},\n     // 渲染App的DOM容器\n     rootTag: document.getElementById('react-app')\n   });\n   ```\n\n4. 写一个index.html文件，引入Webpack构建出的JavaScript，以在Web平台运行：\n\n   ```html\n   <html>\n   <head>\n       <meta charset=\"UTF-8\">\n       <meta name=\"viewport\"\n             content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n       <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n       <!--以下是正常运行所需的必须样式-->\n       <style>\n           html,body,#react-root{\n               height: 100%;\n           }\n           #react-root{\n               display:flex;\n           }\n       </style>\n   </head>\n   <body>\n   <div id=\"react-root\"></div>\n   <script src=\"main.js\"></script>\n   </body>\n   </html>\n   ```\n\n完成以上步骤后重新执行webpack构建，再在浏览器中打开index.html你就可以看到ReactNative转出的Web网页了。\n\n完整的例子可以参考react-native-web的[官方例子](https://github.com/necolas/react-native-web/tree/master/packages/examples)。\n\n## reactxp接入\n\n由于reactxp所有暴露的API都是支持在Web平台和ReactNative平台同时正常运行的，因此为reactxp应用转Web的方法非常简单，只需为项目加入Webpack构建和运行Web页面的index.html文件。\n\nWebpack配置文件如下：\n\n```js\nmodule.exports = {\n  entry: \"./src/index.tsx\",\n  mode: \"development\",\n  output: {\n    filename: \"bundle.js\",\n    path: __dirname + \"/dist\"\n  },\n  resolve: {\n    // 优先加载web.js后缀的文件\n    extensions: [\".web.js\", \".ts\", \".tsx\", \".js\"]\n  },\n\n  module: {\n    rules: [\n  \t  // 转换TypeScript文件    \n      { test: /\\.tsx?$/, loader: \"awesome-typescript-loader\" }\n    ]\n  }\n};\n```\n\n再写一个运行Web页面的index.html文件：\n\n```html\n<!doctype html>\n<html>\n<head>\n  <meta charset='utf-8'>\n  <style>\n    html, body, .app-container {\n      width: 100%;\n      height: 100%;\n      padding: 0;\n      border: none;\n      margin: 0;\n    }\n    *:focus {\n        outline: 0;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app-container\"></div>\n  <script src=\"dist/bundle.js\"></script>\n</body>\n</html>\n```\n\n完整的例子可以参考reactxp的[官方例子](https://github.com/Microsoft/reactxp/tree/master/samples/hello-world)。\n\n## 适配你项目中自定义的NativeModules\n\nReactNative开发的App中经常会出现ReactNative官方提供的NativeModules不够用的情况，这时你会在项目中开发自己的NativeModules，然后在JavaScript中去调用自己的NativeModules。这在ReactNative环境下运行没有问题，但转成Web后执行时会报错说NativeModules上找不到对应的模块，这时因为在浏览器环境下是不存在这些自定义的NativeModules。为了让页面能正常在浏览器中运行，需要为Web平台也实现一份自定义的NativeModules，实现方法可以web平台的执行入口的最开头注入以下polyfill：\n\n```js\nimport { NativeModules } from 'react-native';\nimport MyModule from './MyModule'; // 实现自定义NativeModules的地方\n\nNativeModules.MyModule = MyModule; // 挂载MyModule\n```\n\n这段代码的作用是把针对Web平台编写的自定义原生模块挂载到NativeModules对象上成为其属性，以让JavaScript代码在访问自定义NativeModules时访问到针对Web平台编写模块。\n\n## 编写特定平台的代码\n\n为了让ReactNative三端同构能正常的运行，在有些情况下你不得不编写平台特点的代码，因为有些代码只能在特点平台下才能运行，编写Web平台特定的代码的方法有以下三种：\n\n1. ReactNative.Platform.OS：所有端的代码都在一个文件中，通过以下代码来写web平台专属代码:\n\n   ```js\n   import { Platform } from 'react-native';\n   \n   if(Platform.OS==='web'){\n     // web平台专属代码\n   }\n   ```\n\n2. process.env.platform：通过Webpack注入的环境变量来区分\n\n   ```js\n   if (process.env.platform === 'web') {\n     // web平台专属代码\n   }\n   ```\n\n   这段代码只会在web平台下被打包进去，这和`ReactNative.Platform`的区别是：\n\n   `ReactNative.Platform`的代码会打包进所有的平台。\n\n   要使用这种方法需要你在webpack.config.js文件中注入环境变量：\n\n   ```js\n   plugins: [\n   \tnew webpack.DefinePlugin({\n   \t\t'process.env': {\n   \t\t\tplatform: JSON.stringify(platform),\n   \t\t\t__DEV__: mode === 'development'\n   \t}),\n   ]\n   ```\n\n3. .web.js: 在web模式下会优先加载.web.js文件，当.web.js文件不存在时才使用.js文件。\n\n## 总结\n\nReactNative三端同构在理论上虽然可行，并且有现成的方案，但实践是还是会遇到一些问题，例如：\n\n- 在Web平台运行出的样式和ReactNative平台不一致，针对这种情况一般是react-native-web库的适配问题，可以在github上提issus或pr；\n- 有些ReactNative提供的API在Web平台不可能实现适配，例如调摄像头、振动等，对于这种问题只有在Web平台裁剪掉这些功能或使用其它交互方式替代。\n\nReactNative三端同构虽然无法实现100%和ReactNative环境运行一致，但能快速简单的转换大多数场景，以低成本的方式为你的项目带来收益。\n\n\n> 本文首发于[IBM Dev社区](https://www.ibm.com/developerworks/cn/web/wa-universal-react-native/index.html)\n\n\n","source":"_posts/ReactNative三端同构实战.md","raw":"---\ntitle: ReactNative三端同构实战\ndate: 2018-11-14T04:21:47Z\nurl: https://github.com/gwuhaolin/blog/issues/18\ntags:\n    - react\n---\n\n## 认识ReactNative三端同构\n\nReactNative三端同构是指在不改动原ReactNative的代码下，让其在浏览器中运行出和在ReactNative环境下一样的页面。\n\nReactNative三端同构的应用场景包括：\n\n- 在ReactNative页面崩溃时用对应的Web页兜底，以保证用户可以正常使用页面；\n- 对于需要分享到社交网络的页面，例如需要分享到微信朋友圈、微博的页面，不可避免的需要Web网页。\n\n对于使用ReactNative开发的页面，如果又单独为Web平台重复写一份代码代价是极其大的，而ReactNative三端同构能以零花费快速做到一份代码三端复用。\n\n## ReactNative三端同构基础原理\n\nReactNative就像一套新的浏览器标准，ReactNative提供了大量内置的原生UI元素和系统API，对应着浏览器中的div、img等标签以及BOM API；但是ReactNative目前只专注于移动App平台，只适配了iOS和Android两大系统，而浏览器则是适配了各种操作系统，由于ReactNative需要适配的平台更少所以性能会比浏览器要好。\n\n我们编写的React组件经过render后会以虚拟DOM的形式存储在内存中，React只负责UI层面的抽象和组件的状态管理，各平台都可用虚拟DOM去渲染出不同的结果，React架构如下：\n\n<img width=\"719\" alt=\"react\" src=\"https://user-images.githubusercontent.com/5773264/48459964-77f8a880-e807-11e8-9e5f-37f4145e7efe.png\">\n\n\n由此可见虚拟DOM这层中间抽象在实现React渲染到多端时发挥了很大的作用。\n\n## ReactNative三端同构方案对比\n\n目前社区中已经有多个ReactNative三端同构方案，比较成熟的有[react-native-web](https://github.com/necolas/react-native-web)和[reactxp](https://github.com/Microsoft/reactxp)，下来从多方面对比二者以帮助你做出合适的选择。\n\n#### 认识reactxp\n\nreactxp是一个跨平台的UI库，由微软Skype团队维护和开源，Skype产品中就大量使用了它来实现写一份代码运行在多个平台上。目前reactxp支持以下平台：\n\n- iOS（基于react-native渲染）；\n- Android（基于react-native渲染）；\n- Web（基于react-dom渲染）；\n- [UWP](https://en.wikipedia.org/wiki/Universal_Windows_Platform) (基于[react-native-windows](https://github.com/Microsoft/react-native-windows)渲染)；\n- 对于剩下的平台，诸如Mac、Windows10以下系统、Linux桌面，则采用基于Web渲染的[Electron](https://electron.atom.io/)。\n\n#### reactxp实现原理\n\nreactxp充份发挥了react虚拟DOM的优势，它其实只是充当胶水的作用，把各个平台的渲染引擎整合起来，对外暴露平台一致的接口。\n\nreactxp为各个平台都实现了一份代码，在构建的过程中构建工具会自动选择平台相关的代码进行打包输出。\n\n![reactxp arch](https://user-images.githubusercontent.com/5773264/48459985-88a91e80-e807-11e8-81ee-8d5e0f3856eb.png)\n\n\n#### reactxp和react-native的异同点\n\n从使用层面来说它们最大的区别在于：**reactxp是为了一份代码在多个平台运行，而react-native是为了学一遍可为多个平台编写原生应用**。\n\n这一点从reactxp和react-native暴露出的API就可以看出来：react-native中大量诸如SegmentedControlIOS、PermissionsAndroid这样针对特定平台的API，而reactxp中所有的API在所有端中都可以正常调用。\n\n事实上react-native也在为多端接口统一做努力，react-native中的大多数接口是可以在多端运行一致的，但为了保证灵活性react-native也提供了平台相关的接口。而reactxp磨平了多端接口的差异，但这也导致reactxp灵活性降低。\n\n他们的相同点是都采用了react框架编程的思想，由于reactxp是基于react-native封装的导致他们大多数API的使用方式都是一致的。\n\n#### react-native-web原理\n\nreact-native-web实现了在不修改react-native代码的情况下渲染在浏览器里的功能，其实现原理如下：\n\n在用webpack构建用于运行在浏览器里的代码时，会把react-native的导入路径替换为react-native-web的导入路径，在react-native-web内部则会以和react-native目录结构一致的方式实现了一致的react-native组件。在react-native-web组件的内部，则把react-native的API映射成了浏览器支持的API。\n\n![react-native-web arch](https://user-images.githubusercontent.com/5773264/48459994-952d7700-e807-11e8-976f-4e4777a8b1c5.png)\n\n\n#### react-native-web和reactxp异同点\n\n它们的目的都是为了实现多端同构，但react-native-web只专注于Web平台的适配，而reactxp则还需要适配UWP平台。\n\n在实现Web平台的适配过程中它们都采用了类似的原理：把对外暴露的API或组件映射到Web平台去。\n\n但在实现Web平台的样式适配时有细微区别：\n\n- reactxp全部通过内联样式实现；\n- react-native-web通过为每条不同的样式生产一个className，对于重复出现的样式则通过复用className实现。\n\n对于这两种不同的实现方式，我更看好react-native-web的实现方式，原因有两个：\n\n1. 通过复用className节省网络传输字节，如果你需要做服务端渲染这个优势会凸显出来；\n2. 通过className的方式浏览器渲染性能更好，原因是浏览器有做样式计算缓存优化，有人专门写了[性能对比测试页面](https://jsperf.com/inline-style-vs-css-class/2)。\n\n#### reactxp优点\n\n- 写一份代码就可实现多端渲染，对于有多端需求的产品可以减少代码量和人力；\n- 由微软Skype团队维护并且用于Skype产品中，有大公司投入资源支持；\n- 基于TypeScript编写，对IDE友好；\n\n#### reactxp缺点\n\n- 为了抹平多端平台差异导致灵活性降低，暴露的组件和API较react-native要少很多；\n- 需要兼容UWP平台导致包袱更重，而目前会针对Windows桌面或手机开发应用的产品也再渐渐减少，大多数产品不需要支持Windows平台；\n- 需要多导入reactxp这个库，导致打包输出的bundle会变大；并且由于多了一层适配，运行时性能肯定是不如直接使用react-native。\n\n其中最为致命的缺点可能在于目前reactxp支持的组件和API相当匮乏，一些比较细的操作无法控制；如果你在reactxp项目中确实有需求超出reactxp的能力范围，可以通过导入和使用react-native实现，但这会导致整个项目脱离reactxp体系，因此reactxp为我们实现的多端同构将会无法实现；\n\nreactxp只保证在它的体型内实现多端同构，但在它的体系内却有很多API不可用。\n\nreactxp更像是微软为了挽救其奄奄一息的[Windows Phone](https://en.wikipedia.org/wiki/Windows_Phone)系统在做努力，但事实上微软已经失去了移动操作系统市场，无人愿意为用户量很少的WP系统开发APP。\n\n#### react-native-web和reactxp对比表\n\n|                | reactxp                                                      | react-native-web                                             | 对比                                                         |\n| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 维护人         | 微软Skype团队和GitHub社区                                    | 来自Twitter的个人[necolas](https://github.com/necolas)和GitHub社区 | reactxp小胜                                                  |\n| 服务端渲染支持 | [官方没有明确要支持](https://github.com/Microsoft/reactxp/issues/201) | 完全支持                                                     | react-native-web胜                                           |\n| Web端包大小    | 435KB                                                        | 354.4KB                                                      | react-native-web胜                                           |\n| 写代码效率     | 针对reactxp暴露的API去实现多端适配                           | 需要自己去验证代码在多端的表现是否一致                       | reactxp胜                                                    |\n| 学习成本       | 除了需要学习reactxp外，不可避免的还需要学习react-native      | 只需学习react-native即可                                     | react-native-web胜                                           |\n| Github数据     | start=2017年4月 star=6521 issues=23/739 commits=814          | start=2017年7月 star=10151 issues=45/1034 commits=1248       | react-native-web用户更多，代码变动频率更大。reactxp问题响应速度更快。 |\n\n#### 如何选择\n\n如果你开发的产品有适配UWP平台的需求就选择reactxp，否则选择react-native-web，因为reactxp相比于react-native-web除了多支持Windows平台外，并无其它明显优势。\n\n## react-native-web接入\n\n为了给你现有的ReactNative接入react-native-web，实现ReactNative三端同构的能力，你需要做以下事情：\n\n1. 安装新的依赖：\n\n   ```base\n   # 运行时依赖\n   npm i react react-dom react-native-web react-art\n   # 构建工具\n   npm i -D webpack webpack-dev-server webpack-cli babel-loader babel-plugin-transform-runtime\n   ```\n\n2. 为Web平台写一份Webpack配置文件webpack.config.js，内容如下:\n\n   ```js\n   module.exports = {\n     module: {\n       rules: [\n         {\n           // 支持图片等静态文件的加载\n           test: /\\.(gif|jpe?g|png|svg)$/,\n           use: {\n             loader: 'file-loader'\n           }\n         },\n         {\n   \t\t// react-native包中有很多es6语法的js，需要用babel转换后才能在浏览器中运行\n           test: /\\.js$/,\n           use: {\n             loader: 'babel-loader',\n             options: {\n               cacheDirectory: false,\n               presets: ['react-native'],\n               plugins: [\n                 // 支持 async/await 语法\n                 'transform-runtime'\n               ]\n             }\n           }\n         }\n       ]\n     },\n     resolve: {\n       // 优先加载以web.js结尾的针对web平台的文件\n       extensions: {\n           '.web.js',\n           '.js',\n           '.json',\n       },\n       alias: {\n          // 把react-native包映射成react-native-web\n         'react-native$': 'react-native-web'\n       }\n     }\n   }\n   ```\n\n3. 写一个针对Web平台启动入口文件index.web.js：\n\n   ```js\n   import { AppRegistry } from 'react-native';\n   \n   // 注册组件\n   AppRegistry.registerComponent('App', () => App);\n   \n   // 启动App组件\n   AppRegistry.runApplication('App', {\n     // 启动时传给App组件的属性\n     initialProps: {},\n     // 渲染App的DOM容器\n     rootTag: document.getElementById('react-app')\n   });\n   ```\n\n4. 写一个index.html文件，引入Webpack构建出的JavaScript，以在Web平台运行：\n\n   ```html\n   <html>\n   <head>\n       <meta charset=\"UTF-8\">\n       <meta name=\"viewport\"\n             content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n       <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n       <!--以下是正常运行所需的必须样式-->\n       <style>\n           html,body,#react-root{\n               height: 100%;\n           }\n           #react-root{\n               display:flex;\n           }\n       </style>\n   </head>\n   <body>\n   <div id=\"react-root\"></div>\n   <script src=\"main.js\"></script>\n   </body>\n   </html>\n   ```\n\n完成以上步骤后重新执行webpack构建，再在浏览器中打开index.html你就可以看到ReactNative转出的Web网页了。\n\n完整的例子可以参考react-native-web的[官方例子](https://github.com/necolas/react-native-web/tree/master/packages/examples)。\n\n## reactxp接入\n\n由于reactxp所有暴露的API都是支持在Web平台和ReactNative平台同时正常运行的，因此为reactxp应用转Web的方法非常简单，只需为项目加入Webpack构建和运行Web页面的index.html文件。\n\nWebpack配置文件如下：\n\n```js\nmodule.exports = {\n  entry: \"./src/index.tsx\",\n  mode: \"development\",\n  output: {\n    filename: \"bundle.js\",\n    path: __dirname + \"/dist\"\n  },\n  resolve: {\n    // 优先加载web.js后缀的文件\n    extensions: [\".web.js\", \".ts\", \".tsx\", \".js\"]\n  },\n\n  module: {\n    rules: [\n  \t  // 转换TypeScript文件    \n      { test: /\\.tsx?$/, loader: \"awesome-typescript-loader\" }\n    ]\n  }\n};\n```\n\n再写一个运行Web页面的index.html文件：\n\n```html\n<!doctype html>\n<html>\n<head>\n  <meta charset='utf-8'>\n  <style>\n    html, body, .app-container {\n      width: 100%;\n      height: 100%;\n      padding: 0;\n      border: none;\n      margin: 0;\n    }\n    *:focus {\n        outline: 0;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app-container\"></div>\n  <script src=\"dist/bundle.js\"></script>\n</body>\n</html>\n```\n\n完整的例子可以参考reactxp的[官方例子](https://github.com/Microsoft/reactxp/tree/master/samples/hello-world)。\n\n## 适配你项目中自定义的NativeModules\n\nReactNative开发的App中经常会出现ReactNative官方提供的NativeModules不够用的情况，这时你会在项目中开发自己的NativeModules，然后在JavaScript中去调用自己的NativeModules。这在ReactNative环境下运行没有问题，但转成Web后执行时会报错说NativeModules上找不到对应的模块，这时因为在浏览器环境下是不存在这些自定义的NativeModules。为了让页面能正常在浏览器中运行，需要为Web平台也实现一份自定义的NativeModules，实现方法可以web平台的执行入口的最开头注入以下polyfill：\n\n```js\nimport { NativeModules } from 'react-native';\nimport MyModule from './MyModule'; // 实现自定义NativeModules的地方\n\nNativeModules.MyModule = MyModule; // 挂载MyModule\n```\n\n这段代码的作用是把针对Web平台编写的自定义原生模块挂载到NativeModules对象上成为其属性，以让JavaScript代码在访问自定义NativeModules时访问到针对Web平台编写模块。\n\n## 编写特定平台的代码\n\n为了让ReactNative三端同构能正常的运行，在有些情况下你不得不编写平台特点的代码，因为有些代码只能在特点平台下才能运行，编写Web平台特定的代码的方法有以下三种：\n\n1. ReactNative.Platform.OS：所有端的代码都在一个文件中，通过以下代码来写web平台专属代码:\n\n   ```js\n   import { Platform } from 'react-native';\n   \n   if(Platform.OS==='web'){\n     // web平台专属代码\n   }\n   ```\n\n2. process.env.platform：通过Webpack注入的环境变量来区分\n\n   ```js\n   if (process.env.platform === 'web') {\n     // web平台专属代码\n   }\n   ```\n\n   这段代码只会在web平台下被打包进去，这和`ReactNative.Platform`的区别是：\n\n   `ReactNative.Platform`的代码会打包进所有的平台。\n\n   要使用这种方法需要你在webpack.config.js文件中注入环境变量：\n\n   ```js\n   plugins: [\n   \tnew webpack.DefinePlugin({\n   \t\t'process.env': {\n   \t\t\tplatform: JSON.stringify(platform),\n   \t\t\t__DEV__: mode === 'development'\n   \t}),\n   ]\n   ```\n\n3. .web.js: 在web模式下会优先加载.web.js文件，当.web.js文件不存在时才使用.js文件。\n\n## 总结\n\nReactNative三端同构在理论上虽然可行，并且有现成的方案，但实践是还是会遇到一些问题，例如：\n\n- 在Web平台运行出的样式和ReactNative平台不一致，针对这种情况一般是react-native-web库的适配问题，可以在github上提issus或pr；\n- 有些ReactNative提供的API在Web平台不可能实现适配，例如调摄像头、振动等，对于这种问题只有在Web平台裁剪掉这些功能或使用其它交互方式替代。\n\nReactNative三端同构虽然无法实现100%和ReactNative环境运行一致，但能快速简单的转换大多数场景，以低成本的方式为你的项目带来收益。\n\n\n> 本文首发于[IBM Dev社区](https://www.ibm.com/developerworks/cn/web/wa-universal-react-native/index.html)\n\n\n","slug":"ReactNative三端同构实战","published":1,"updated":"2018-11-14T04:39:28.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjogs0kdy0002g5tchsposa0z","content":"<h2 id=\"认识ReactNative三端同构\"><a href=\"#认识ReactNative三端同构\" class=\"headerlink\" title=\"认识ReactNative三端同构\"></a>认识ReactNative三端同构</h2><p>ReactNative三端同构是指在不改动原ReactNative的代码下，让其在浏览器中运行出和在ReactNative环境下一样的页面。</p>\n<p>ReactNative三端同构的应用场景包括：</p>\n<ul>\n<li>在ReactNative页面崩溃时用对应的Web页兜底，以保证用户可以正常使用页面；</li>\n<li>对于需要分享到社交网络的页面，例如需要分享到微信朋友圈、微博的页面，不可避免的需要Web网页。</li>\n</ul>\n<p>对于使用ReactNative开发的页面，如果又单独为Web平台重复写一份代码代价是极其大的，而ReactNative三端同构能以零花费快速做到一份代码三端复用。</p>\n<h2 id=\"ReactNative三端同构基础原理\"><a href=\"#ReactNative三端同构基础原理\" class=\"headerlink\" title=\"ReactNative三端同构基础原理\"></a>ReactNative三端同构基础原理</h2><p>ReactNative就像一套新的浏览器标准，ReactNative提供了大量内置的原生UI元素和系统API，对应着浏览器中的div、img等标签以及BOM API；但是ReactNative目前只专注于移动App平台，只适配了iOS和Android两大系统，而浏览器则是适配了各种操作系统，由于ReactNative需要适配的平台更少所以性能会比浏览器要好。</p>\n<p>我们编写的React组件经过render后会以虚拟DOM的形式存储在内存中，React只负责UI层面的抽象和组件的状态管理，各平台都可用虚拟DOM去渲染出不同的结果，React架构如下：</p>\n<p><img width=\"719\" alt=\"react\" src=\"https://user-images.githubusercontent.com/5773264/48459964-77f8a880-e807-11e8-9e5f-37f4145e7efe.png\"></p>\n<p>由此可见虚拟DOM这层中间抽象在实现React渲染到多端时发挥了很大的作用。</p>\n<h2 id=\"ReactNative三端同构方案对比\"><a href=\"#ReactNative三端同构方案对比\" class=\"headerlink\" title=\"ReactNative三端同构方案对比\"></a>ReactNative三端同构方案对比</h2><p>目前社区中已经有多个ReactNative三端同构方案，比较成熟的有<a href=\"https://github.com/necolas/react-native-web\" target=\"_blank\" rel=\"noopener\">react-native-web</a>和<a href=\"https://github.com/Microsoft/reactxp\" target=\"_blank\" rel=\"noopener\">reactxp</a>，下来从多方面对比二者以帮助你做出合适的选择。</p>\n<h4 id=\"认识reactxp\"><a href=\"#认识reactxp\" class=\"headerlink\" title=\"认识reactxp\"></a>认识reactxp</h4><p>reactxp是一个跨平台的UI库，由微软Skype团队维护和开源，Skype产品中就大量使用了它来实现写一份代码运行在多个平台上。目前reactxp支持以下平台：</p>\n<ul>\n<li>iOS（基于react-native渲染）；</li>\n<li>Android（基于react-native渲染）；</li>\n<li>Web（基于react-dom渲染）；</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Universal_Windows_Platform\" target=\"_blank\" rel=\"noopener\">UWP</a> (基于<a href=\"https://github.com/Microsoft/react-native-windows\" target=\"_blank\" rel=\"noopener\">react-native-windows</a>渲染)；</li>\n<li>对于剩下的平台，诸如Mac、Windows10以下系统、Linux桌面，则采用基于Web渲染的<a href=\"https://electron.atom.io/\" target=\"_blank\" rel=\"noopener\">Electron</a>。</li>\n</ul>\n<h4 id=\"reactxp实现原理\"><a href=\"#reactxp实现原理\" class=\"headerlink\" title=\"reactxp实现原理\"></a>reactxp实现原理</h4><p>reactxp充份发挥了react虚拟DOM的优势，它其实只是充当胶水的作用，把各个平台的渲染引擎整合起来，对外暴露平台一致的接口。</p>\n<p>reactxp为各个平台都实现了一份代码，在构建的过程中构建工具会自动选择平台相关的代码进行打包输出。</p>\n<p><img src=\"https://user-images.githubusercontent.com/5773264/48459985-88a91e80-e807-11e8-81ee-8d5e0f3856eb.png\" alt=\"reactxp arch\"></p>\n<h4 id=\"reactxp和react-native的异同点\"><a href=\"#reactxp和react-native的异同点\" class=\"headerlink\" title=\"reactxp和react-native的异同点\"></a>reactxp和react-native的异同点</h4><p>从使用层面来说它们最大的区别在于：<strong>reactxp是为了一份代码在多个平台运行，而react-native是为了学一遍可为多个平台编写原生应用</strong>。</p>\n<p>这一点从reactxp和react-native暴露出的API就可以看出来：react-native中大量诸如SegmentedControlIOS、PermissionsAndroid这样针对特定平台的API，而reactxp中所有的API在所有端中都可以正常调用。</p>\n<p>事实上react-native也在为多端接口统一做努力，react-native中的大多数接口是可以在多端运行一致的，但为了保证灵活性react-native也提供了平台相关的接口。而reactxp磨平了多端接口的差异，但这也导致reactxp灵活性降低。</p>\n<p>他们的相同点是都采用了react框架编程的思想，由于reactxp是基于react-native封装的导致他们大多数API的使用方式都是一致的。</p>\n<h4 id=\"react-native-web原理\"><a href=\"#react-native-web原理\" class=\"headerlink\" title=\"react-native-web原理\"></a>react-native-web原理</h4><p>react-native-web实现了在不修改react-native代码的情况下渲染在浏览器里的功能，其实现原理如下：</p>\n<p>在用webpack构建用于运行在浏览器里的代码时，会把react-native的导入路径替换为react-native-web的导入路径，在react-native-web内部则会以和react-native目录结构一致的方式实现了一致的react-native组件。在react-native-web组件的内部，则把react-native的API映射成了浏览器支持的API。</p>\n<p><img src=\"https://user-images.githubusercontent.com/5773264/48459994-952d7700-e807-11e8-976f-4e4777a8b1c5.png\" alt=\"react-native-web arch\"></p>\n<h4 id=\"react-native-web和reactxp异同点\"><a href=\"#react-native-web和reactxp异同点\" class=\"headerlink\" title=\"react-native-web和reactxp异同点\"></a>react-native-web和reactxp异同点</h4><p>它们的目的都是为了实现多端同构，但react-native-web只专注于Web平台的适配，而reactxp则还需要适配UWP平台。</p>\n<p>在实现Web平台的适配过程中它们都采用了类似的原理：把对外暴露的API或组件映射到Web平台去。</p>\n<p>但在实现Web平台的样式适配时有细微区别：</p>\n<ul>\n<li>reactxp全部通过内联样式实现；</li>\n<li>react-native-web通过为每条不同的样式生产一个className，对于重复出现的样式则通过复用className实现。</li>\n</ul>\n<p>对于这两种不同的实现方式，我更看好react-native-web的实现方式，原因有两个：</p>\n<ol>\n<li>通过复用className节省网络传输字节，如果你需要做服务端渲染这个优势会凸显出来；</li>\n<li>通过className的方式浏览器渲染性能更好，原因是浏览器有做样式计算缓存优化，有人专门写了<a href=\"https://jsperf.com/inline-style-vs-css-class/2\" target=\"_blank\" rel=\"noopener\">性能对比测试页面</a>。</li>\n</ol>\n<h4 id=\"reactxp优点\"><a href=\"#reactxp优点\" class=\"headerlink\" title=\"reactxp优点\"></a>reactxp优点</h4><ul>\n<li>写一份代码就可实现多端渲染，对于有多端需求的产品可以减少代码量和人力；</li>\n<li>由微软Skype团队维护并且用于Skype产品中，有大公司投入资源支持；</li>\n<li>基于TypeScript编写，对IDE友好；</li>\n</ul>\n<h4 id=\"reactxp缺点\"><a href=\"#reactxp缺点\" class=\"headerlink\" title=\"reactxp缺点\"></a>reactxp缺点</h4><ul>\n<li>为了抹平多端平台差异导致灵活性降低，暴露的组件和API较react-native要少很多；</li>\n<li>需要兼容UWP平台导致包袱更重，而目前会针对Windows桌面或手机开发应用的产品也再渐渐减少，大多数产品不需要支持Windows平台；</li>\n<li>需要多导入reactxp这个库，导致打包输出的bundle会变大；并且由于多了一层适配，运行时性能肯定是不如直接使用react-native。</li>\n</ul>\n<p>其中最为致命的缺点可能在于目前reactxp支持的组件和API相当匮乏，一些比较细的操作无法控制；如果你在reactxp项目中确实有需求超出reactxp的能力范围，可以通过导入和使用react-native实现，但这会导致整个项目脱离reactxp体系，因此reactxp为我们实现的多端同构将会无法实现；</p>\n<p>reactxp只保证在它的体型内实现多端同构，但在它的体系内却有很多API不可用。</p>\n<p>reactxp更像是微软为了挽救其奄奄一息的<a href=\"https://en.wikipedia.org/wiki/Windows_Phone\" target=\"_blank\" rel=\"noopener\">Windows Phone</a>系统在做努力，但事实上微软已经失去了移动操作系统市场，无人愿意为用户量很少的WP系统开发APP。</p>\n<h4 id=\"react-native-web和reactxp对比表\"><a href=\"#react-native-web和reactxp对比表\" class=\"headerlink\" title=\"react-native-web和reactxp对比表\"></a>react-native-web和reactxp对比表</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>reactxp</th>\n<th>react-native-web</th>\n<th>对比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>维护人</td>\n<td>微软Skype团队和GitHub社区</td>\n<td>来自Twitter的个人<a href=\"https://github.com/necolas\" target=\"_blank\" rel=\"noopener\">necolas</a>和GitHub社区</td>\n<td>reactxp小胜</td>\n</tr>\n<tr>\n<td>服务端渲染支持</td>\n<td><a href=\"https://github.com/Microsoft/reactxp/issues/201\" target=\"_blank\" rel=\"noopener\">官方没有明确要支持</a></td>\n<td>完全支持</td>\n<td>react-native-web胜</td>\n</tr>\n<tr>\n<td>Web端包大小</td>\n<td>435KB</td>\n<td>354.4KB</td>\n<td>react-native-web胜</td>\n</tr>\n<tr>\n<td>写代码效率</td>\n<td>针对reactxp暴露的API去实现多端适配</td>\n<td>需要自己去验证代码在多端的表现是否一致</td>\n<td>reactxp胜</td>\n</tr>\n<tr>\n<td>学习成本</td>\n<td>除了需要学习reactxp外，不可避免的还需要学习react-native</td>\n<td>只需学习react-native即可</td>\n<td>react-native-web胜</td>\n</tr>\n<tr>\n<td>Github数据</td>\n<td>start=2017年4月 star=6521 issues=23/739 commits=814</td>\n<td>start=2017年7月 star=10151 issues=45/1034 commits=1248</td>\n<td>react-native-web用户更多，代码变动频率更大。reactxp问题响应速度更快。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"如何选择\"><a href=\"#如何选择\" class=\"headerlink\" title=\"如何选择\"></a>如何选择</h4><p>如果你开发的产品有适配UWP平台的需求就选择reactxp，否则选择react-native-web，因为reactxp相比于react-native-web除了多支持Windows平台外，并无其它明显优势。</p>\n<h2 id=\"react-native-web接入\"><a href=\"#react-native-web接入\" class=\"headerlink\" title=\"react-native-web接入\"></a>react-native-web接入</h2><p>为了给你现有的ReactNative接入react-native-web，实现ReactNative三端同构的能力，你需要做以下事情：</p>\n<ol>\n<li><p>安装新的依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 运行时依赖</span><br><span class=\"line\">npm i react react-dom react-native-web react-art</span><br><span class=\"line\"># 构建工具</span><br><span class=\"line\">npm i -D webpack webpack-dev-server webpack-cli babel-loader babel-plugin-transform-runtime</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为Web平台写一份Webpack配置文件webpack.config.js，内容如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 支持图片等静态文件的加载</span></span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(gif|jpe?g|png|svg)$/</span>,</span><br><span class=\"line\">        use: &#123;</span><br><span class=\"line\">          loader: <span class=\"string\">'file-loader'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// react-native包中有很多es6语法的js，需要用babel转换后才能在浏览器中运行</span></span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        use: &#123;</span><br><span class=\"line\">          loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">          options: &#123;</span><br><span class=\"line\">            cacheDirectory: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            presets: [<span class=\"string\">'react-native'</span>],</span><br><span class=\"line\">            plugins: [</span><br><span class=\"line\">              <span class=\"comment\">// 支持 async/await 语法</span></span><br><span class=\"line\">              <span class=\"string\">'transform-runtime'</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 优先加载以web.js结尾的针对web平台的文件</span></span><br><span class=\"line\">    extensions: &#123;</span><br><span class=\"line\">        <span class=\"string\">'.web.js'</span>,</span><br><span class=\"line\">        <span class=\"string\">'.js'</span>,</span><br><span class=\"line\">        <span class=\"string\">'.json'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 把react-native包映射成react-native-web</span></span><br><span class=\"line\">      <span class=\"string\">'react-native$'</span>: <span class=\"string\">'react-native-web'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>写一个针对Web平台启动入口文件index.web.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; AppRegistry &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册组件</span></span><br><span class=\"line\">AppRegistry.registerComponent(<span class=\"string\">'App'</span>, () =&gt; App);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动App组件</span></span><br><span class=\"line\">AppRegistry.runApplication(<span class=\"string\">'App'</span>, &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 启动时传给App组件的属性</span></span><br><span class=\"line\">  initialProps: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 渲染App的DOM容器</span></span><br><span class=\"line\">  rootTag: <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'react-app'</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>写一个index.html文件，引入Webpack构建出的JavaScript，以在Web平台运行：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--以下是正常运行所需的必须样式--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        html,body,#react-root&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            height: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        #react-root&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            display:flex;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"react-root\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"main.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>完成以上步骤后重新执行webpack构建，再在浏览器中打开index.html你就可以看到ReactNative转出的Web网页了。</p>\n<p>完整的例子可以参考react-native-web的<a href=\"https://github.com/necolas/react-native-web/tree/master/packages/examples\" target=\"_blank\" rel=\"noopener\">官方例子</a>。</p>\n<h2 id=\"reactxp接入\"><a href=\"#reactxp接入\" class=\"headerlink\" title=\"reactxp接入\"></a>reactxp接入</h2><p>由于reactxp所有暴露的API都是支持在Web平台和ReactNative平台同时正常运行的，因此为reactxp应用转Web的方法非常简单，只需为项目加入Webpack构建和运行Web页面的index.html文件。</p>\n<p>Webpack配置文件如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">\"./src/index.tsx\"</span>,</span><br><span class=\"line\">  mode: <span class=\"string\">\"development\"</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">\"bundle.js\"</span>,</span><br><span class=\"line\">    path: __dirname + <span class=\"string\">\"/dist\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 优先加载web.js后缀的文件</span></span><br><span class=\"line\">    extensions: [<span class=\"string\">\".web.js\"</span>, <span class=\"string\">\".ts\"</span>, <span class=\"string\">\".tsx\"</span>, <span class=\"string\">\".js\"</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">  \t  <span class=\"comment\">// 转换TypeScript文件    </span></span><br><span class=\"line\">      &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.tsx?$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">\"awesome-typescript-loader\"</span> &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>再写一个运行Web页面的index.html文件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!doctype html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">'utf-8'</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    html, body, .app-container &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">      width: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">      height: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">      padding: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">      border: none;</span></span><br><span class=\"line\"><span class=\"undefined\">      margin: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    *:focus &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        outline: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"app-container\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"dist/bundle.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>完整的例子可以参考reactxp的<a href=\"https://github.com/Microsoft/reactxp/tree/master/samples/hello-world\" target=\"_blank\" rel=\"noopener\">官方例子</a>。</p>\n<h2 id=\"适配你项目中自定义的NativeModules\"><a href=\"#适配你项目中自定义的NativeModules\" class=\"headerlink\" title=\"适配你项目中自定义的NativeModules\"></a>适配你项目中自定义的NativeModules</h2><p>ReactNative开发的App中经常会出现ReactNative官方提供的NativeModules不够用的情况，这时你会在项目中开发自己的NativeModules，然后在JavaScript中去调用自己的NativeModules。这在ReactNative环境下运行没有问题，但转成Web后执行时会报错说NativeModules上找不到对应的模块，这时因为在浏览器环境下是不存在这些自定义的NativeModules。为了让页面能正常在浏览器中运行，需要为Web平台也实现一份自定义的NativeModules，实现方法可以web平台的执行入口的最开头注入以下polyfill：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; NativeModules &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> MyModule <span class=\"keyword\">from</span> <span class=\"string\">'./MyModule'</span>; <span class=\"comment\">// 实现自定义NativeModules的地方</span></span><br><span class=\"line\"></span><br><span class=\"line\">NativeModules.MyModule = MyModule; <span class=\"comment\">// 挂载MyModule</span></span><br></pre></td></tr></table></figure>\n<p>这段代码的作用是把针对Web平台编写的自定义原生模块挂载到NativeModules对象上成为其属性，以让JavaScript代码在访问自定义NativeModules时访问到针对Web平台编写模块。</p>\n<h2 id=\"编写特定平台的代码\"><a href=\"#编写特定平台的代码\" class=\"headerlink\" title=\"编写特定平台的代码\"></a>编写特定平台的代码</h2><p>为了让ReactNative三端同构能正常的运行，在有些情况下你不得不编写平台特点的代码，因为有些代码只能在特点平台下才能运行，编写Web平台特定的代码的方法有以下三种：</p>\n<ol>\n<li><p>ReactNative.Platform.OS：所有端的代码都在一个文件中，通过以下代码来写web平台专属代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Platform &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(Platform.OS===<span class=\"string\">'web'</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// web平台专属代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>process.env.platform：通过Webpack注入的环境变量来区分</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (process.env.platform === <span class=\"string\">'web'</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// web平台专属代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码只会在web平台下被打包进去，这和<code>ReactNative.Platform</code>的区别是：</p>\n<p><code>ReactNative.Platform</code>的代码会打包进所有的平台。</p>\n<p>要使用这种方法需要你在webpack.config.js文件中注入环境变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">\t<span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">'process.env'</span>: &#123;</span><br><span class=\"line\">\t\t\tplatform: <span class=\"built_in\">JSON</span>.stringify(platform),</span><br><span class=\"line\">\t\t\t__DEV__: mode === <span class=\"string\">'development'</span></span><br><span class=\"line\">\t&#125;),</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>.web.js: 在web模式下会优先加载.web.js文件，当.web.js文件不存在时才使用.js文件。</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>ReactNative三端同构在理论上虽然可行，并且有现成的方案，但实践是还是会遇到一些问题，例如：</p>\n<ul>\n<li>在Web平台运行出的样式和ReactNative平台不一致，针对这种情况一般是react-native-web库的适配问题，可以在github上提issus或pr；</li>\n<li>有些ReactNative提供的API在Web平台不可能实现适配，例如调摄像头、振动等，对于这种问题只有在Web平台裁剪掉这些功能或使用其它交互方式替代。</li>\n</ul>\n<p>ReactNative三端同构虽然无法实现100%和ReactNative环境运行一致，但能快速简单的转换大多数场景，以低成本的方式为你的项目带来收益。</p>\n<blockquote>\n<p>本文首发于<a href=\"https://www.ibm.com/developerworks/cn/web/wa-universal-react-native/index.html\" target=\"_blank\" rel=\"noopener\">IBM Dev社区</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"认识ReactNative三端同构\"><a href=\"#认识ReactNative三端同构\" class=\"headerlink\" title=\"认识ReactNative三端同构\"></a>认识ReactNative三端同构</h2><p>ReactNative三端同构是指在不改动原ReactNative的代码下，让其在浏览器中运行出和在ReactNative环境下一样的页面。</p>\n<p>ReactNative三端同构的应用场景包括：</p>\n<ul>\n<li>在ReactNative页面崩溃时用对应的Web页兜底，以保证用户可以正常使用页面；</li>\n<li>对于需要分享到社交网络的页面，例如需要分享到微信朋友圈、微博的页面，不可避免的需要Web网页。</li>\n</ul>\n<p>对于使用ReactNative开发的页面，如果又单独为Web平台重复写一份代码代价是极其大的，而ReactNative三端同构能以零花费快速做到一份代码三端复用。</p>\n<h2 id=\"ReactNative三端同构基础原理\"><a href=\"#ReactNative三端同构基础原理\" class=\"headerlink\" title=\"ReactNative三端同构基础原理\"></a>ReactNative三端同构基础原理</h2><p>ReactNative就像一套新的浏览器标准，ReactNative提供了大量内置的原生UI元素和系统API，对应着浏览器中的div、img等标签以及BOM API；但是ReactNative目前只专注于移动App平台，只适配了iOS和Android两大系统，而浏览器则是适配了各种操作系统，由于ReactNative需要适配的平台更少所以性能会比浏览器要好。</p>\n<p>我们编写的React组件经过render后会以虚拟DOM的形式存储在内存中，React只负责UI层面的抽象和组件的状态管理，各平台都可用虚拟DOM去渲染出不同的结果，React架构如下：</p>\n<p><img width=\"719\" alt=\"react\" src=\"https://user-images.githubusercontent.com/5773264/48459964-77f8a880-e807-11e8-9e5f-37f4145e7efe.png\"></p>\n<p>由此可见虚拟DOM这层中间抽象在实现React渲染到多端时发挥了很大的作用。</p>\n<h2 id=\"ReactNative三端同构方案对比\"><a href=\"#ReactNative三端同构方案对比\" class=\"headerlink\" title=\"ReactNative三端同构方案对比\"></a>ReactNative三端同构方案对比</h2><p>目前社区中已经有多个ReactNative三端同构方案，比较成熟的有<a href=\"https://github.com/necolas/react-native-web\" target=\"_blank\" rel=\"noopener\">react-native-web</a>和<a href=\"https://github.com/Microsoft/reactxp\" target=\"_blank\" rel=\"noopener\">reactxp</a>，下来从多方面对比二者以帮助你做出合适的选择。</p>\n<h4 id=\"认识reactxp\"><a href=\"#认识reactxp\" class=\"headerlink\" title=\"认识reactxp\"></a>认识reactxp</h4><p>reactxp是一个跨平台的UI库，由微软Skype团队维护和开源，Skype产品中就大量使用了它来实现写一份代码运行在多个平台上。目前reactxp支持以下平台：</p>\n<ul>\n<li>iOS（基于react-native渲染）；</li>\n<li>Android（基于react-native渲染）；</li>\n<li>Web（基于react-dom渲染）；</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Universal_Windows_Platform\" target=\"_blank\" rel=\"noopener\">UWP</a> (基于<a href=\"https://github.com/Microsoft/react-native-windows\" target=\"_blank\" rel=\"noopener\">react-native-windows</a>渲染)；</li>\n<li>对于剩下的平台，诸如Mac、Windows10以下系统、Linux桌面，则采用基于Web渲染的<a href=\"https://electron.atom.io/\" target=\"_blank\" rel=\"noopener\">Electron</a>。</li>\n</ul>\n<h4 id=\"reactxp实现原理\"><a href=\"#reactxp实现原理\" class=\"headerlink\" title=\"reactxp实现原理\"></a>reactxp实现原理</h4><p>reactxp充份发挥了react虚拟DOM的优势，它其实只是充当胶水的作用，把各个平台的渲染引擎整合起来，对外暴露平台一致的接口。</p>\n<p>reactxp为各个平台都实现了一份代码，在构建的过程中构建工具会自动选择平台相关的代码进行打包输出。</p>\n<p><img src=\"https://user-images.githubusercontent.com/5773264/48459985-88a91e80-e807-11e8-81ee-8d5e0f3856eb.png\" alt=\"reactxp arch\"></p>\n<h4 id=\"reactxp和react-native的异同点\"><a href=\"#reactxp和react-native的异同点\" class=\"headerlink\" title=\"reactxp和react-native的异同点\"></a>reactxp和react-native的异同点</h4><p>从使用层面来说它们最大的区别在于：<strong>reactxp是为了一份代码在多个平台运行，而react-native是为了学一遍可为多个平台编写原生应用</strong>。</p>\n<p>这一点从reactxp和react-native暴露出的API就可以看出来：react-native中大量诸如SegmentedControlIOS、PermissionsAndroid这样针对特定平台的API，而reactxp中所有的API在所有端中都可以正常调用。</p>\n<p>事实上react-native也在为多端接口统一做努力，react-native中的大多数接口是可以在多端运行一致的，但为了保证灵活性react-native也提供了平台相关的接口。而reactxp磨平了多端接口的差异，但这也导致reactxp灵活性降低。</p>\n<p>他们的相同点是都采用了react框架编程的思想，由于reactxp是基于react-native封装的导致他们大多数API的使用方式都是一致的。</p>\n<h4 id=\"react-native-web原理\"><a href=\"#react-native-web原理\" class=\"headerlink\" title=\"react-native-web原理\"></a>react-native-web原理</h4><p>react-native-web实现了在不修改react-native代码的情况下渲染在浏览器里的功能，其实现原理如下：</p>\n<p>在用webpack构建用于运行在浏览器里的代码时，会把react-native的导入路径替换为react-native-web的导入路径，在react-native-web内部则会以和react-native目录结构一致的方式实现了一致的react-native组件。在react-native-web组件的内部，则把react-native的API映射成了浏览器支持的API。</p>\n<p><img src=\"https://user-images.githubusercontent.com/5773264/48459994-952d7700-e807-11e8-976f-4e4777a8b1c5.png\" alt=\"react-native-web arch\"></p>\n<h4 id=\"react-native-web和reactxp异同点\"><a href=\"#react-native-web和reactxp异同点\" class=\"headerlink\" title=\"react-native-web和reactxp异同点\"></a>react-native-web和reactxp异同点</h4><p>它们的目的都是为了实现多端同构，但react-native-web只专注于Web平台的适配，而reactxp则还需要适配UWP平台。</p>\n<p>在实现Web平台的适配过程中它们都采用了类似的原理：把对外暴露的API或组件映射到Web平台去。</p>\n<p>但在实现Web平台的样式适配时有细微区别：</p>\n<ul>\n<li>reactxp全部通过内联样式实现；</li>\n<li>react-native-web通过为每条不同的样式生产一个className，对于重复出现的样式则通过复用className实现。</li>\n</ul>\n<p>对于这两种不同的实现方式，我更看好react-native-web的实现方式，原因有两个：</p>\n<ol>\n<li>通过复用className节省网络传输字节，如果你需要做服务端渲染这个优势会凸显出来；</li>\n<li>通过className的方式浏览器渲染性能更好，原因是浏览器有做样式计算缓存优化，有人专门写了<a href=\"https://jsperf.com/inline-style-vs-css-class/2\" target=\"_blank\" rel=\"noopener\">性能对比测试页面</a>。</li>\n</ol>\n<h4 id=\"reactxp优点\"><a href=\"#reactxp优点\" class=\"headerlink\" title=\"reactxp优点\"></a>reactxp优点</h4><ul>\n<li>写一份代码就可实现多端渲染，对于有多端需求的产品可以减少代码量和人力；</li>\n<li>由微软Skype团队维护并且用于Skype产品中，有大公司投入资源支持；</li>\n<li>基于TypeScript编写，对IDE友好；</li>\n</ul>\n<h4 id=\"reactxp缺点\"><a href=\"#reactxp缺点\" class=\"headerlink\" title=\"reactxp缺点\"></a>reactxp缺点</h4><ul>\n<li>为了抹平多端平台差异导致灵活性降低，暴露的组件和API较react-native要少很多；</li>\n<li>需要兼容UWP平台导致包袱更重，而目前会针对Windows桌面或手机开发应用的产品也再渐渐减少，大多数产品不需要支持Windows平台；</li>\n<li>需要多导入reactxp这个库，导致打包输出的bundle会变大；并且由于多了一层适配，运行时性能肯定是不如直接使用react-native。</li>\n</ul>\n<p>其中最为致命的缺点可能在于目前reactxp支持的组件和API相当匮乏，一些比较细的操作无法控制；如果你在reactxp项目中确实有需求超出reactxp的能力范围，可以通过导入和使用react-native实现，但这会导致整个项目脱离reactxp体系，因此reactxp为我们实现的多端同构将会无法实现；</p>\n<p>reactxp只保证在它的体型内实现多端同构，但在它的体系内却有很多API不可用。</p>\n<p>reactxp更像是微软为了挽救其奄奄一息的<a href=\"https://en.wikipedia.org/wiki/Windows_Phone\" target=\"_blank\" rel=\"noopener\">Windows Phone</a>系统在做努力，但事实上微软已经失去了移动操作系统市场，无人愿意为用户量很少的WP系统开发APP。</p>\n<h4 id=\"react-native-web和reactxp对比表\"><a href=\"#react-native-web和reactxp对比表\" class=\"headerlink\" title=\"react-native-web和reactxp对比表\"></a>react-native-web和reactxp对比表</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>reactxp</th>\n<th>react-native-web</th>\n<th>对比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>维护人</td>\n<td>微软Skype团队和GitHub社区</td>\n<td>来自Twitter的个人<a href=\"https://github.com/necolas\" target=\"_blank\" rel=\"noopener\">necolas</a>和GitHub社区</td>\n<td>reactxp小胜</td>\n</tr>\n<tr>\n<td>服务端渲染支持</td>\n<td><a href=\"https://github.com/Microsoft/reactxp/issues/201\" target=\"_blank\" rel=\"noopener\">官方没有明确要支持</a></td>\n<td>完全支持</td>\n<td>react-native-web胜</td>\n</tr>\n<tr>\n<td>Web端包大小</td>\n<td>435KB</td>\n<td>354.4KB</td>\n<td>react-native-web胜</td>\n</tr>\n<tr>\n<td>写代码效率</td>\n<td>针对reactxp暴露的API去实现多端适配</td>\n<td>需要自己去验证代码在多端的表现是否一致</td>\n<td>reactxp胜</td>\n</tr>\n<tr>\n<td>学习成本</td>\n<td>除了需要学习reactxp外，不可避免的还需要学习react-native</td>\n<td>只需学习react-native即可</td>\n<td>react-native-web胜</td>\n</tr>\n<tr>\n<td>Github数据</td>\n<td>start=2017年4月 star=6521 issues=23/739 commits=814</td>\n<td>start=2017年7月 star=10151 issues=45/1034 commits=1248</td>\n<td>react-native-web用户更多，代码变动频率更大。reactxp问题响应速度更快。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"如何选择\"><a href=\"#如何选择\" class=\"headerlink\" title=\"如何选择\"></a>如何选择</h4><p>如果你开发的产品有适配UWP平台的需求就选择reactxp，否则选择react-native-web，因为reactxp相比于react-native-web除了多支持Windows平台外，并无其它明显优势。</p>\n<h2 id=\"react-native-web接入\"><a href=\"#react-native-web接入\" class=\"headerlink\" title=\"react-native-web接入\"></a>react-native-web接入</h2><p>为了给你现有的ReactNative接入react-native-web，实现ReactNative三端同构的能力，你需要做以下事情：</p>\n<ol>\n<li><p>安装新的依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 运行时依赖</span><br><span class=\"line\">npm i react react-dom react-native-web react-art</span><br><span class=\"line\"># 构建工具</span><br><span class=\"line\">npm i -D webpack webpack-dev-server webpack-cli babel-loader babel-plugin-transform-runtime</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为Web平台写一份Webpack配置文件webpack.config.js，内容如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 支持图片等静态文件的加载</span></span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(gif|jpe?g|png|svg)$/</span>,</span><br><span class=\"line\">        use: &#123;</span><br><span class=\"line\">          loader: <span class=\"string\">'file-loader'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// react-native包中有很多es6语法的js，需要用babel转换后才能在浏览器中运行</span></span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        use: &#123;</span><br><span class=\"line\">          loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">          options: &#123;</span><br><span class=\"line\">            cacheDirectory: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            presets: [<span class=\"string\">'react-native'</span>],</span><br><span class=\"line\">            plugins: [</span><br><span class=\"line\">              <span class=\"comment\">// 支持 async/await 语法</span></span><br><span class=\"line\">              <span class=\"string\">'transform-runtime'</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 优先加载以web.js结尾的针对web平台的文件</span></span><br><span class=\"line\">    extensions: &#123;</span><br><span class=\"line\">        <span class=\"string\">'.web.js'</span>,</span><br><span class=\"line\">        <span class=\"string\">'.js'</span>,</span><br><span class=\"line\">        <span class=\"string\">'.json'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 把react-native包映射成react-native-web</span></span><br><span class=\"line\">      <span class=\"string\">'react-native$'</span>: <span class=\"string\">'react-native-web'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>写一个针对Web平台启动入口文件index.web.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; AppRegistry &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册组件</span></span><br><span class=\"line\">AppRegistry.registerComponent(<span class=\"string\">'App'</span>, () =&gt; App);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动App组件</span></span><br><span class=\"line\">AppRegistry.runApplication(<span class=\"string\">'App'</span>, &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 启动时传给App组件的属性</span></span><br><span class=\"line\">  initialProps: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 渲染App的DOM容器</span></span><br><span class=\"line\">  rootTag: <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'react-app'</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>写一个index.html文件，引入Webpack构建出的JavaScript，以在Web平台运行：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--以下是正常运行所需的必须样式--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        html,body,#react-root&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            height: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        #react-root&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            display:flex;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"react-root\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"main.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>完成以上步骤后重新执行webpack构建，再在浏览器中打开index.html你就可以看到ReactNative转出的Web网页了。</p>\n<p>完整的例子可以参考react-native-web的<a href=\"https://github.com/necolas/react-native-web/tree/master/packages/examples\" target=\"_blank\" rel=\"noopener\">官方例子</a>。</p>\n<h2 id=\"reactxp接入\"><a href=\"#reactxp接入\" class=\"headerlink\" title=\"reactxp接入\"></a>reactxp接入</h2><p>由于reactxp所有暴露的API都是支持在Web平台和ReactNative平台同时正常运行的，因此为reactxp应用转Web的方法非常简单，只需为项目加入Webpack构建和运行Web页面的index.html文件。</p>\n<p>Webpack配置文件如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">\"./src/index.tsx\"</span>,</span><br><span class=\"line\">  mode: <span class=\"string\">\"development\"</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">\"bundle.js\"</span>,</span><br><span class=\"line\">    path: __dirname + <span class=\"string\">\"/dist\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 优先加载web.js后缀的文件</span></span><br><span class=\"line\">    extensions: [<span class=\"string\">\".web.js\"</span>, <span class=\"string\">\".ts\"</span>, <span class=\"string\">\".tsx\"</span>, <span class=\"string\">\".js\"</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">  \t  <span class=\"comment\">// 转换TypeScript文件    </span></span><br><span class=\"line\">      &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.tsx?$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">\"awesome-typescript-loader\"</span> &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>再写一个运行Web页面的index.html文件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!doctype html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">'utf-8'</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    html, body, .app-container &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">      width: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">      height: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">      padding: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">      border: none;</span></span><br><span class=\"line\"><span class=\"undefined\">      margin: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    *:focus &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        outline: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"app-container\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"dist/bundle.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>完整的例子可以参考reactxp的<a href=\"https://github.com/Microsoft/reactxp/tree/master/samples/hello-world\" target=\"_blank\" rel=\"noopener\">官方例子</a>。</p>\n<h2 id=\"适配你项目中自定义的NativeModules\"><a href=\"#适配你项目中自定义的NativeModules\" class=\"headerlink\" title=\"适配你项目中自定义的NativeModules\"></a>适配你项目中自定义的NativeModules</h2><p>ReactNative开发的App中经常会出现ReactNative官方提供的NativeModules不够用的情况，这时你会在项目中开发自己的NativeModules，然后在JavaScript中去调用自己的NativeModules。这在ReactNative环境下运行没有问题，但转成Web后执行时会报错说NativeModules上找不到对应的模块，这时因为在浏览器环境下是不存在这些自定义的NativeModules。为了让页面能正常在浏览器中运行，需要为Web平台也实现一份自定义的NativeModules，实现方法可以web平台的执行入口的最开头注入以下polyfill：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; NativeModules &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> MyModule <span class=\"keyword\">from</span> <span class=\"string\">'./MyModule'</span>; <span class=\"comment\">// 实现自定义NativeModules的地方</span></span><br><span class=\"line\"></span><br><span class=\"line\">NativeModules.MyModule = MyModule; <span class=\"comment\">// 挂载MyModule</span></span><br></pre></td></tr></table></figure>\n<p>这段代码的作用是把针对Web平台编写的自定义原生模块挂载到NativeModules对象上成为其属性，以让JavaScript代码在访问自定义NativeModules时访问到针对Web平台编写模块。</p>\n<h2 id=\"编写特定平台的代码\"><a href=\"#编写特定平台的代码\" class=\"headerlink\" title=\"编写特定平台的代码\"></a>编写特定平台的代码</h2><p>为了让ReactNative三端同构能正常的运行，在有些情况下你不得不编写平台特点的代码，因为有些代码只能在特点平台下才能运行，编写Web平台特定的代码的方法有以下三种：</p>\n<ol>\n<li><p>ReactNative.Platform.OS：所有端的代码都在一个文件中，通过以下代码来写web平台专属代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Platform &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(Platform.OS===<span class=\"string\">'web'</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// web平台专属代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>process.env.platform：通过Webpack注入的环境变量来区分</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (process.env.platform === <span class=\"string\">'web'</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// web平台专属代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码只会在web平台下被打包进去，这和<code>ReactNative.Platform</code>的区别是：</p>\n<p><code>ReactNative.Platform</code>的代码会打包进所有的平台。</p>\n<p>要使用这种方法需要你在webpack.config.js文件中注入环境变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">\t<span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">'process.env'</span>: &#123;</span><br><span class=\"line\">\t\t\tplatform: <span class=\"built_in\">JSON</span>.stringify(platform),</span><br><span class=\"line\">\t\t\t__DEV__: mode === <span class=\"string\">'development'</span></span><br><span class=\"line\">\t&#125;),</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>.web.js: 在web模式下会优先加载.web.js文件，当.web.js文件不存在时才使用.js文件。</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>ReactNative三端同构在理论上虽然可行，并且有现成的方案，但实践是还是会遇到一些问题，例如：</p>\n<ul>\n<li>在Web平台运行出的样式和ReactNative平台不一致，针对这种情况一般是react-native-web库的适配问题，可以在github上提issus或pr；</li>\n<li>有些ReactNative提供的API在Web平台不可能实现适配，例如调摄像头、振动等，对于这种问题只有在Web平台裁剪掉这些功能或使用其它交互方式替代。</li>\n</ul>\n<p>ReactNative三端同构虽然无法实现100%和ReactNative环境运行一致，但能快速简单的转换大多数场景，以低成本的方式为你的项目带来收益。</p>\n<blockquote>\n<p>本文首发于<a href=\"https://www.ibm.com/developerworks/cn/web/wa-universal-react-native/index.html\" target=\"_blank\" rel=\"noopener\">IBM Dev社区</a></p>\n</blockquote>\n"},{"title":"webpack原理与实战","date":"2017-05-31T00:11:45.000Z","url":"https://github.com/gwuhaolin/blog/issues/4","_content":"\n[![](http://ou8vcvyuy.bkt.clouddn.com/dive-into-webpack-for-blog.jpg)](http://webpack.wuhaolin.cn/)\n\n\nwebpack是一个js打包工具，不一个完整的前端构建工具。它的流行得益于模块化和单页应用的流行。webpack提供扩展机制，在庞大的社区支持下各种场景基本它都可找到解决方案。本文的目的是教会你用webpack解决实战中常见的问题。\n\n## webpack原理\n在深入实战前先要知道webpack的运行原理\n### webpack核心概念\n- `entry` 一个可执行模块或库的入口文件。\n- `chunk` 多个文件组成的一个代码块，例如把一个可执行模块和它所有依赖的模块组合和一个 `chunk` 这体现了webpack的打包机制。\n- `loader` 文件转换器，例如把es6转换为es5，scss转换为css。\n- `plugin` 插件，用于扩展webpack的功能，在webpack构建生命周期的节点上加入扩展hook为webpack加入功能。\n\n### webpack构建流程\n从启动webpack构建到输出结果经历了一系列过程，它们是：\n1. 解析webpack配置参数，合并从shell传入和`webpack.config.js`文件里配置的参数，生产最后的配置结果。\n2. 注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。\n3. 从配置的`entry`入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。\n4. 在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。\n5. 递归完后得到每个文件的最终结果，根据`entry`配置生成代码块`chunk`。\n6. 输出所有`chunk`到文件系统。\n\n需要注意的是，在构建生命周期中有一系列插件在合适的时机做了合适的事情，比如`UglifyJsPlugin`会在loader转换递归完后对结果再使用`UglifyJs`压缩覆盖之前的结果。\n\n## 场景和方案\n通过各种场景和对应的解决方案让你深入掌握webpack\n### 单页应用\n**demo [redemo](https://github.com/gwuhaolin/redemo)**\n一个单页应用需要配置一个`entry`指明执行入口，webpack会为`entry`生成一个包含这个入口所有依赖文件的`chunk`，但要让它在浏览器里跑起来还需要一个HTML文件来加载`chunk`生成的js文件，如果提取出了css还需要让HTML文件引入提取出的css。[web-webpack-plugin](https://github.com/gwuhaolin/web-webpack-plugin)里的`WebPlugin`可以自动的完成这些工作。\n\nwebpack配置文件\n```js\nconst { WebPlugin } = require('web-webpack-plugin');\nmodule.exports = {\n  entry: {\n    app: './src/doc/index.js',\n  },\n  plugins: [\n    // 一个WebPlugin对应生成一个html文件\n    new WebPlugin({\n      //输出的html文件名称\n      filename: 'index.html',\n      //这个html依赖的`entry`\n      requires: ['app'],\n    }),\n  ],\n};\n```\n`requires: ['doc']`指明这个HTML依赖哪些`entry`，`entry`生成的js和css会自动注入到HTML里。\n你还可以配置这些资源的注入方式，支持如下属性：\n- `_dist` 只有在生产环境下才引入该资源\n- `_dev` 只有在开发环境下才引入该资源\n- `_inline` 把该资源的内容潜入到html里\n- `_ie` 只有IE浏览器才需要引入的资源\n\n要设置这些属性可以通过在js里配置\n```js\nnew WebPlugin({\n    filename: 'index.html',\n    requires: {\n         app:{\n              _dist:true,\n              _inline:false,\n         }\n    },\n}),\n```\n或者在模版里设置，使用模版的好处是灵活的控制资源注入点。\n```js\nnew WebPlugin({\n      filename: 'index.html',\n      template: './template.html',\n}),\n```\n```html\n<!DOCTYPE html>\n<html lang=\"zh-cn\">\n<head>\n    <link rel=\"stylesheet\" href=\"app?_inline\">\n    <script src=\"ie-polyfill?_ie\"></script>\n</head>\n<body>\n<div id=\"react-body\"></div>\n<script src=\"app\"></script>\n</body>\n</html>\n```\n`WebPlugin`插件借鉴了`fis3`的思想，补足了webpack缺失的以HTML为入口的功能。想了解`WebPlugin`的更多功能，见[文档](https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#输出html文件-demo)。\n\n### 一个项目里管理多个单页应用\n一般项目里会包含多个单页应用，虽然多个单页应用也可以合并成一个但是这样做会导致用户没访问的部分也加载了。如果项目里有很多个单页应用，为每个单页应用配置一个`entry`和`WebPlugin `？如果项目又新增了一个单页应用，又去新增webpack配置？这样做太麻烦了，[web-webpack-plugin](https://github.com/gwuhaolin/web-webpack-plugin)里的`AutoWebPlugin`可以方便的解决这些问题。\n```js\nmodule.exports = {\n    plugins: [\n        // 所有页面的入口目录\n        new AutoWebPlugin('./src/'),\n    ]\n};\n```\n`AutoWebPlugin`会把`./src/`目录下所有每个文件夹作为一个单页页面的入口，自动为所有的页面入口配置一个WebPlugin输出对应的html。要新增一个页面就在`./src/`下新建一个文件夹包含这个单页应用所依赖的代码，`AutoWebPlugin`自动生成一个名叫文件夹名称的html文件。`AutoWebPlugin`的更多功能见[文档](https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#自动探测html入口-demo)。\n\n### 代码分割优化\n一个好的代码分割对浏览器首屏效果提升很大。比如对于最常见的react体系你可以\n1. 先抽出基础库`react` `react-dom` `redux` `react-redux`到一个单独的文件而不是和其它文件放在一起打包为一个文件，这样做的好处是只要你不升级他们的版本这个文件永远不会被刷新。如果你把这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致文件hash值变化从而导致缓存失效浏览器重复下载这些包含基础库的代码。以上的配置为：\n```js\n// vender.js 文件抽离基础库到单独的一个文件里防止跟随业务代码被刷新\n// 所有页面都依赖的第三方库\n// react基础\nimport 'react';\nimport 'react-dom';\nimport 'react-redux';\n// redux基础\nimport 'redux';\nimport 'redux-thunk';\n```\n```js\n// webpack配置\n{\n  entry: {\n    vendor: './path/to/vendor.js',\n  },\n}\n```\n2. 再通过[CommonsChunkPlugin](https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin)可以提取出多个代码块都依赖的代码形成一个单独的`chunk`。在应用有多个页面的场景下提取出所有页面公共的代码减少单个页面的代码，在不同页面之间切换时所有页面公共的代码之前被加载过而不必重新加载。\n\n### 构建npm包\n**demo [remd](https://github.com/gwuhaolin/remd)**\n除了构建可运行的web应用，webpack也可用来构建发布到npm上去的给别人调用的js库。\n```js\nconst nodeExternals = require('webpack-node-externals');\nmodule.exports = {\n  entry: {\n    index: './src/index.js',\n  },\n  externals: [nodeExternals()],\n  target: 'node',\n  output: {\n    path: path.resolve(__dirname, '.npm'),\n    filename: '[name].js',\n    libraryTarget: 'commonjs2',\n  },\n};\n```\n这里有几个区别于web应用不同的地方：\n- `externals: [nodeExternals()]`用于排除`node_modules`目录下的代码被打包进去，因为放在`node_modules`目录下的代码应该通过npm安装。\n- `libraryTarget: 'commonjs2'`指出`entry`是一个可供别人调用的库而不是可执行的，输出的js文件按照commonjs规范。\n\n### 构建服务端渲染\n服务端渲染的代码要运行在nodejs环境，和浏览器不同的是，服务端渲染代码需要采用commonjs规范同时不应该包含除js之外的文件比如css。webpack配置如下：\n```js\nmodule.exports = {\n  target: 'node',\n  entry: {\n    'server_render': './src/server_render',\n  },\n  output: {\n    filename: './dist/server/[name].js',\n    libraryTarget: 'commonjs2',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n      },\n      {\n        test: /\\.(scss|css|pdf)$/,\n        loader: 'ignore-loader',\n      },\n    ]\n  },\n};\n```\n其中几个关键的地方在于：\n- `target: 'node'` 指明构建出的代码是要运行在node环境里\n- `libraryTarget: 'commonjs2'` 指明输出的代码要是commonjs规范\n- `{test: /\\.(scss|css|pdf)$/,loader: 'ignore-loader'}` 是为了防止不能在node里执行服务端渲染也用不上的文件被打包进去。\n\n### 从fis3迁移到webpack\nfis3和webpack有相似的地方也有不同的地方。相似在于他们都采用commonjs规范，不同在于导入css这些非js资源的方式。fis3通过`// @require './index.scss'`而webpack通过`require('./index.scss')`。如果想从fis3平滑迁移到webpack可以使用[comment-require-loader](https://github.com/gwuhaolin/comment-require-loader/issues)。比如你想在webpack构建是使用采用了fis3方式的`imui`模块，配置如下：\n```js\nloaders:[{\n     test: /\\.js$/,\n     loaders: ['comment-require-loader'],\n     include: [path.resolve(__dirname, 'node_modules/imui'),]\n}]\n```\n\n## 自定义webpack扩展\n如果你在社区找不到你的应用场景的解决方案，那就需要自己动手了写loader或者plugin了。\n在你编写自定义webpack扩展前你需要想明白到底是要做一个`loader`还是`plugin`呢？可以这样判断：\n> 如果你的扩展是想对一个个单独的文件进行转换那么就编写`loader`剩下的都是`plugin`。\n\n其中对文件进行转换可以是像：\n- `babel-loader`把es6转换成`es5`\n- `file-loader`把文件替换成对应的URL\n- `raw-loader`注入文本文件内容到代码里去\n\n### 编写 webpack loader\n**demo [comment-require-loader](https://github.com/gwuhaolin/comment-require-loader)**\n编写`loader`非常简单，以comment-require-loader为例：\n```js\nmodule.exports = function (content) {\n    return replace(content);\n};\n```\n`loader`的入口需要导出一个函数，这个函数要干的事情就是转换一个文件的内容。\n函数接收的参数`content`是一个文件在转换前的字符串形式内容，需要返回一个新的字符串形式内容作为转换后的结果，所有通过模块化倒入的文件都会经过`loader`。从这里可以看出`loader`只能处理一个个单独的文件而不能处理代码块。想编写更复杂的loader可参考[官方文档](https://webpack.github.io/docs/loaders.html)\n\n### 编写 webpack plugin\n**demo [end-webpack-plugin](https://github.com/gwuhaolin/end-webpack-plugin)**\n`plugin`应用场景广泛，所以稍微复杂点。以end-webpack-plugin为例：\n```js\nclass EndWebpackPlugin {\n\n    constructor(doneCallback, failCallback) {\n        this.doneCallback = doneCallback;\n        this.failCallback = failCallback;\n    }\n\n    apply(compiler) {\n        // 监听webpack生命周期里的事件，做相应的处理\n        compiler.plugin('done', (stats) => {\n            this.doneCallback(stats);\n        });\n        compiler.plugin('failed', (err) => {\n            this.failCallback(err);\n        });\n    }\n}\n\nmodule.exports = EndWebpackPlugin;\n```\n`loader`的入口需要导出一个class, 在`new EndWebpackPlugin()`的时候通过构造函数传入这个插件需要的参数，在webpack启动的时候会先实例化`plugin`再调用`plugin`的`apply`方法，插件需要在`apply`函数里监听webpack生命周期里的事件，做相应的处理。\nwebpack plugin 里有2个核心概念：\n- `Compiler`: 从webpack启动到推出只存在一个`Compiler`，`Compiler`存放着webpack配置\n- `Compilation`: 由于webpack的监听文件变化自动编译机制，`Compilation`代表一次编译。\n\n`Compiler` 和 `Compilation` 都会广播一系列事件。\nwebpack生命周期里有非常多的事件可以在[event-hooks](https://webpack.js.org/api/plugins/compiler/#event-hooks)和[Compilation](https://webpack.js.org/api/plugins/compilation/)里查到。以上只是一个最简单的demo，更复杂的可以查看 [how to write a plugin](https://github.com/webpack/docs/wiki/how-to-write-a-plugin)或参考[web-webpack-plugin](https://github.com/gwuhaolin/web-webpack-plugin)。\n\n## 总结\nwebpack其实很简单，可以用一句话涵盖它的本质：\n> webpack是一个打包模块化js的工具，可以通过loader转换文件，通过plugin扩展功能。\n\n如果webpack让你感到复杂，一定是各种loader和plugin的原因。\n希望本文能让你明白webpack的原理与本质让你可以在实战中灵活应用webpack。\n\n[阅读原文](http://wuhaolin.cn/2017/05/31/webpack%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/)\n","source":"_posts/webpack原理与实战.md","raw":"---\ntitle: webpack原理与实战\ndate: 2017-05-31T08:11:45Z\nurl: https://github.com/gwuhaolin/blog/issues/4\ntags:\n    - webpack\n---\n\n[![](http://ou8vcvyuy.bkt.clouddn.com/dive-into-webpack-for-blog.jpg)](http://webpack.wuhaolin.cn/)\n\n\nwebpack是一个js打包工具，不一个完整的前端构建工具。它的流行得益于模块化和单页应用的流行。webpack提供扩展机制，在庞大的社区支持下各种场景基本它都可找到解决方案。本文的目的是教会你用webpack解决实战中常见的问题。\n\n## webpack原理\n在深入实战前先要知道webpack的运行原理\n### webpack核心概念\n- `entry` 一个可执行模块或库的入口文件。\n- `chunk` 多个文件组成的一个代码块，例如把一个可执行模块和它所有依赖的模块组合和一个 `chunk` 这体现了webpack的打包机制。\n- `loader` 文件转换器，例如把es6转换为es5，scss转换为css。\n- `plugin` 插件，用于扩展webpack的功能，在webpack构建生命周期的节点上加入扩展hook为webpack加入功能。\n\n### webpack构建流程\n从启动webpack构建到输出结果经历了一系列过程，它们是：\n1. 解析webpack配置参数，合并从shell传入和`webpack.config.js`文件里配置的参数，生产最后的配置结果。\n2. 注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。\n3. 从配置的`entry`入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。\n4. 在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。\n5. 递归完后得到每个文件的最终结果，根据`entry`配置生成代码块`chunk`。\n6. 输出所有`chunk`到文件系统。\n\n需要注意的是，在构建生命周期中有一系列插件在合适的时机做了合适的事情，比如`UglifyJsPlugin`会在loader转换递归完后对结果再使用`UglifyJs`压缩覆盖之前的结果。\n\n## 场景和方案\n通过各种场景和对应的解决方案让你深入掌握webpack\n### 单页应用\n**demo [redemo](https://github.com/gwuhaolin/redemo)**\n一个单页应用需要配置一个`entry`指明执行入口，webpack会为`entry`生成一个包含这个入口所有依赖文件的`chunk`，但要让它在浏览器里跑起来还需要一个HTML文件来加载`chunk`生成的js文件，如果提取出了css还需要让HTML文件引入提取出的css。[web-webpack-plugin](https://github.com/gwuhaolin/web-webpack-plugin)里的`WebPlugin`可以自动的完成这些工作。\n\nwebpack配置文件\n```js\nconst { WebPlugin } = require('web-webpack-plugin');\nmodule.exports = {\n  entry: {\n    app: './src/doc/index.js',\n  },\n  plugins: [\n    // 一个WebPlugin对应生成一个html文件\n    new WebPlugin({\n      //输出的html文件名称\n      filename: 'index.html',\n      //这个html依赖的`entry`\n      requires: ['app'],\n    }),\n  ],\n};\n```\n`requires: ['doc']`指明这个HTML依赖哪些`entry`，`entry`生成的js和css会自动注入到HTML里。\n你还可以配置这些资源的注入方式，支持如下属性：\n- `_dist` 只有在生产环境下才引入该资源\n- `_dev` 只有在开发环境下才引入该资源\n- `_inline` 把该资源的内容潜入到html里\n- `_ie` 只有IE浏览器才需要引入的资源\n\n要设置这些属性可以通过在js里配置\n```js\nnew WebPlugin({\n    filename: 'index.html',\n    requires: {\n         app:{\n              _dist:true,\n              _inline:false,\n         }\n    },\n}),\n```\n或者在模版里设置，使用模版的好处是灵活的控制资源注入点。\n```js\nnew WebPlugin({\n      filename: 'index.html',\n      template: './template.html',\n}),\n```\n```html\n<!DOCTYPE html>\n<html lang=\"zh-cn\">\n<head>\n    <link rel=\"stylesheet\" href=\"app?_inline\">\n    <script src=\"ie-polyfill?_ie\"></script>\n</head>\n<body>\n<div id=\"react-body\"></div>\n<script src=\"app\"></script>\n</body>\n</html>\n```\n`WebPlugin`插件借鉴了`fis3`的思想，补足了webpack缺失的以HTML为入口的功能。想了解`WebPlugin`的更多功能，见[文档](https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#输出html文件-demo)。\n\n### 一个项目里管理多个单页应用\n一般项目里会包含多个单页应用，虽然多个单页应用也可以合并成一个但是这样做会导致用户没访问的部分也加载了。如果项目里有很多个单页应用，为每个单页应用配置一个`entry`和`WebPlugin `？如果项目又新增了一个单页应用，又去新增webpack配置？这样做太麻烦了，[web-webpack-plugin](https://github.com/gwuhaolin/web-webpack-plugin)里的`AutoWebPlugin`可以方便的解决这些问题。\n```js\nmodule.exports = {\n    plugins: [\n        // 所有页面的入口目录\n        new AutoWebPlugin('./src/'),\n    ]\n};\n```\n`AutoWebPlugin`会把`./src/`目录下所有每个文件夹作为一个单页页面的入口，自动为所有的页面入口配置一个WebPlugin输出对应的html。要新增一个页面就在`./src/`下新建一个文件夹包含这个单页应用所依赖的代码，`AutoWebPlugin`自动生成一个名叫文件夹名称的html文件。`AutoWebPlugin`的更多功能见[文档](https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#自动探测html入口-demo)。\n\n### 代码分割优化\n一个好的代码分割对浏览器首屏效果提升很大。比如对于最常见的react体系你可以\n1. 先抽出基础库`react` `react-dom` `redux` `react-redux`到一个单独的文件而不是和其它文件放在一起打包为一个文件，这样做的好处是只要你不升级他们的版本这个文件永远不会被刷新。如果你把这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致文件hash值变化从而导致缓存失效浏览器重复下载这些包含基础库的代码。以上的配置为：\n```js\n// vender.js 文件抽离基础库到单独的一个文件里防止跟随业务代码被刷新\n// 所有页面都依赖的第三方库\n// react基础\nimport 'react';\nimport 'react-dom';\nimport 'react-redux';\n// redux基础\nimport 'redux';\nimport 'redux-thunk';\n```\n```js\n// webpack配置\n{\n  entry: {\n    vendor: './path/to/vendor.js',\n  },\n}\n```\n2. 再通过[CommonsChunkPlugin](https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin)可以提取出多个代码块都依赖的代码形成一个单独的`chunk`。在应用有多个页面的场景下提取出所有页面公共的代码减少单个页面的代码，在不同页面之间切换时所有页面公共的代码之前被加载过而不必重新加载。\n\n### 构建npm包\n**demo [remd](https://github.com/gwuhaolin/remd)**\n除了构建可运行的web应用，webpack也可用来构建发布到npm上去的给别人调用的js库。\n```js\nconst nodeExternals = require('webpack-node-externals');\nmodule.exports = {\n  entry: {\n    index: './src/index.js',\n  },\n  externals: [nodeExternals()],\n  target: 'node',\n  output: {\n    path: path.resolve(__dirname, '.npm'),\n    filename: '[name].js',\n    libraryTarget: 'commonjs2',\n  },\n};\n```\n这里有几个区别于web应用不同的地方：\n- `externals: [nodeExternals()]`用于排除`node_modules`目录下的代码被打包进去，因为放在`node_modules`目录下的代码应该通过npm安装。\n- `libraryTarget: 'commonjs2'`指出`entry`是一个可供别人调用的库而不是可执行的，输出的js文件按照commonjs规范。\n\n### 构建服务端渲染\n服务端渲染的代码要运行在nodejs环境，和浏览器不同的是，服务端渲染代码需要采用commonjs规范同时不应该包含除js之外的文件比如css。webpack配置如下：\n```js\nmodule.exports = {\n  target: 'node',\n  entry: {\n    'server_render': './src/server_render',\n  },\n  output: {\n    filename: './dist/server/[name].js',\n    libraryTarget: 'commonjs2',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n      },\n      {\n        test: /\\.(scss|css|pdf)$/,\n        loader: 'ignore-loader',\n      },\n    ]\n  },\n};\n```\n其中几个关键的地方在于：\n- `target: 'node'` 指明构建出的代码是要运行在node环境里\n- `libraryTarget: 'commonjs2'` 指明输出的代码要是commonjs规范\n- `{test: /\\.(scss|css|pdf)$/,loader: 'ignore-loader'}` 是为了防止不能在node里执行服务端渲染也用不上的文件被打包进去。\n\n### 从fis3迁移到webpack\nfis3和webpack有相似的地方也有不同的地方。相似在于他们都采用commonjs规范，不同在于导入css这些非js资源的方式。fis3通过`// @require './index.scss'`而webpack通过`require('./index.scss')`。如果想从fis3平滑迁移到webpack可以使用[comment-require-loader](https://github.com/gwuhaolin/comment-require-loader/issues)。比如你想在webpack构建是使用采用了fis3方式的`imui`模块，配置如下：\n```js\nloaders:[{\n     test: /\\.js$/,\n     loaders: ['comment-require-loader'],\n     include: [path.resolve(__dirname, 'node_modules/imui'),]\n}]\n```\n\n## 自定义webpack扩展\n如果你在社区找不到你的应用场景的解决方案，那就需要自己动手了写loader或者plugin了。\n在你编写自定义webpack扩展前你需要想明白到底是要做一个`loader`还是`plugin`呢？可以这样判断：\n> 如果你的扩展是想对一个个单独的文件进行转换那么就编写`loader`剩下的都是`plugin`。\n\n其中对文件进行转换可以是像：\n- `babel-loader`把es6转换成`es5`\n- `file-loader`把文件替换成对应的URL\n- `raw-loader`注入文本文件内容到代码里去\n\n### 编写 webpack loader\n**demo [comment-require-loader](https://github.com/gwuhaolin/comment-require-loader)**\n编写`loader`非常简单，以comment-require-loader为例：\n```js\nmodule.exports = function (content) {\n    return replace(content);\n};\n```\n`loader`的入口需要导出一个函数，这个函数要干的事情就是转换一个文件的内容。\n函数接收的参数`content`是一个文件在转换前的字符串形式内容，需要返回一个新的字符串形式内容作为转换后的结果，所有通过模块化倒入的文件都会经过`loader`。从这里可以看出`loader`只能处理一个个单独的文件而不能处理代码块。想编写更复杂的loader可参考[官方文档](https://webpack.github.io/docs/loaders.html)\n\n### 编写 webpack plugin\n**demo [end-webpack-plugin](https://github.com/gwuhaolin/end-webpack-plugin)**\n`plugin`应用场景广泛，所以稍微复杂点。以end-webpack-plugin为例：\n```js\nclass EndWebpackPlugin {\n\n    constructor(doneCallback, failCallback) {\n        this.doneCallback = doneCallback;\n        this.failCallback = failCallback;\n    }\n\n    apply(compiler) {\n        // 监听webpack生命周期里的事件，做相应的处理\n        compiler.plugin('done', (stats) => {\n            this.doneCallback(stats);\n        });\n        compiler.plugin('failed', (err) => {\n            this.failCallback(err);\n        });\n    }\n}\n\nmodule.exports = EndWebpackPlugin;\n```\n`loader`的入口需要导出一个class, 在`new EndWebpackPlugin()`的时候通过构造函数传入这个插件需要的参数，在webpack启动的时候会先实例化`plugin`再调用`plugin`的`apply`方法，插件需要在`apply`函数里监听webpack生命周期里的事件，做相应的处理。\nwebpack plugin 里有2个核心概念：\n- `Compiler`: 从webpack启动到推出只存在一个`Compiler`，`Compiler`存放着webpack配置\n- `Compilation`: 由于webpack的监听文件变化自动编译机制，`Compilation`代表一次编译。\n\n`Compiler` 和 `Compilation` 都会广播一系列事件。\nwebpack生命周期里有非常多的事件可以在[event-hooks](https://webpack.js.org/api/plugins/compiler/#event-hooks)和[Compilation](https://webpack.js.org/api/plugins/compilation/)里查到。以上只是一个最简单的demo，更复杂的可以查看 [how to write a plugin](https://github.com/webpack/docs/wiki/how-to-write-a-plugin)或参考[web-webpack-plugin](https://github.com/gwuhaolin/web-webpack-plugin)。\n\n## 总结\nwebpack其实很简单，可以用一句话涵盖它的本质：\n> webpack是一个打包模块化js的工具，可以通过loader转换文件，通过plugin扩展功能。\n\n如果webpack让你感到复杂，一定是各种loader和plugin的原因。\n希望本文能让你明白webpack的原理与本质让你可以在实战中灵活应用webpack。\n\n[阅读原文](http://wuhaolin.cn/2017/05/31/webpack%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/)\n","slug":"webpack原理与实战","published":1,"updated":"2018-11-14T04:39:28.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjogs0ke20004g5tcae7st4bx","content":"<p><a href=\"http://webpack.wuhaolin.cn/\" target=\"_blank\" rel=\"noopener\"><img src=\"http://ou8vcvyuy.bkt.clouddn.com/dive-into-webpack-for-blog.jpg\" alt=\"\"></a></p>\n<p>webpack是一个js打包工具，不一个完整的前端构建工具。它的流行得益于模块化和单页应用的流行。webpack提供扩展机制，在庞大的社区支持下各种场景基本它都可找到解决方案。本文的目的是教会你用webpack解决实战中常见的问题。</p>\n<h2 id=\"webpack原理\"><a href=\"#webpack原理\" class=\"headerlink\" title=\"webpack原理\"></a>webpack原理</h2><p>在深入实战前先要知道webpack的运行原理</p>\n<h3 id=\"webpack核心概念\"><a href=\"#webpack核心概念\" class=\"headerlink\" title=\"webpack核心概念\"></a>webpack核心概念</h3><ul>\n<li><code>entry</code> 一个可执行模块或库的入口文件。</li>\n<li><code>chunk</code> 多个文件组成的一个代码块，例如把一个可执行模块和它所有依赖的模块组合和一个 <code>chunk</code> 这体现了webpack的打包机制。</li>\n<li><code>loader</code> 文件转换器，例如把es6转换为es5，scss转换为css。</li>\n<li><code>plugin</code> 插件，用于扩展webpack的功能，在webpack构建生命周期的节点上加入扩展hook为webpack加入功能。</li>\n</ul>\n<h3 id=\"webpack构建流程\"><a href=\"#webpack构建流程\" class=\"headerlink\" title=\"webpack构建流程\"></a>webpack构建流程</h3><p>从启动webpack构建到输出结果经历了一系列过程，它们是：</p>\n<ol>\n<li>解析webpack配置参数，合并从shell传入和<code>webpack.config.js</code>文件里配置的参数，生产最后的配置结果。</li>\n<li>注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。</li>\n<li>从配置的<code>entry</code>入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。</li>\n<li>在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。</li>\n<li>递归完后得到每个文件的最终结果，根据<code>entry</code>配置生成代码块<code>chunk</code>。</li>\n<li>输出所有<code>chunk</code>到文件系统。</li>\n</ol>\n<p>需要注意的是，在构建生命周期中有一系列插件在合适的时机做了合适的事情，比如<code>UglifyJsPlugin</code>会在loader转换递归完后对结果再使用<code>UglifyJs</code>压缩覆盖之前的结果。</p>\n<h2 id=\"场景和方案\"><a href=\"#场景和方案\" class=\"headerlink\" title=\"场景和方案\"></a>场景和方案</h2><p>通过各种场景和对应的解决方案让你深入掌握webpack</p>\n<h3 id=\"单页应用\"><a href=\"#单页应用\" class=\"headerlink\" title=\"单页应用\"></a>单页应用</h3><p><strong>demo <a href=\"https://github.com/gwuhaolin/redemo\" target=\"_blank\" rel=\"noopener\">redemo</a></strong><br>一个单页应用需要配置一个<code>entry</code>指明执行入口，webpack会为<code>entry</code>生成一个包含这个入口所有依赖文件的<code>chunk</code>，但要让它在浏览器里跑起来还需要一个HTML文件来加载<code>chunk</code>生成的js文件，如果提取出了css还需要让HTML文件引入提取出的css。<a href=\"https://github.com/gwuhaolin/web-webpack-plugin\" target=\"_blank\" rel=\"noopener\">web-webpack-plugin</a>里的<code>WebPlugin</code>可以自动的完成这些工作。</p>\n<p>webpack配置文件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; WebPlugin &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'web-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: <span class=\"string\">'./src/doc/index.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// 一个WebPlugin对应生成一个html文件</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> WebPlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">//输出的html文件名称</span></span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>,</span><br><span class=\"line\">      <span class=\"comment\">//这个html依赖的`entry`</span></span><br><span class=\"line\">      requires: [<span class=\"string\">'app'</span>],</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>requires: [&#39;doc&#39;]</code>指明这个HTML依赖哪些<code>entry</code>，<code>entry</code>生成的js和css会自动注入到HTML里。<br>你还可以配置这些资源的注入方式，支持如下属性：</p>\n<ul>\n<li><code>_dist</code> 只有在生产环境下才引入该资源</li>\n<li><code>_dev</code> 只有在开发环境下才引入该资源</li>\n<li><code>_inline</code> 把该资源的内容潜入到html里</li>\n<li><code>_ie</code> 只有IE浏览器才需要引入的资源</li>\n</ul>\n<p>要设置这些属性可以通过在js里配置<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> WebPlugin(&#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'index.html'</span>,</span><br><span class=\"line\">    requires: &#123;</span><br><span class=\"line\">         app:&#123;</span><br><span class=\"line\">              _dist:<span class=\"literal\">true</span>,</span><br><span class=\"line\">              _inline:<span class=\"literal\">false</span>,</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure></p>\n<p>或者在模版里设置，使用模版的好处是灵活的控制资源注入点。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> WebPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>,</span><br><span class=\"line\">      template: <span class=\"string\">'./template.html'</span>,</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"zh-cn\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"app?_inline\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"ie-polyfill?_ie\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"react-body\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>WebPlugin</code>插件借鉴了<code>fis3</code>的思想，补足了webpack缺失的以HTML为入口的功能。想了解<code>WebPlugin</code>的更多功能，见<a href=\"https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#输出html文件-demo\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h3 id=\"一个项目里管理多个单页应用\"><a href=\"#一个项目里管理多个单页应用\" class=\"headerlink\" title=\"一个项目里管理多个单页应用\"></a>一个项目里管理多个单页应用</h3><p>一般项目里会包含多个单页应用，虽然多个单页应用也可以合并成一个但是这样做会导致用户没访问的部分也加载了。如果项目里有很多个单页应用，为每个单页应用配置一个<code>entry</code>和<code>WebPlugin</code>？如果项目又新增了一个单页应用，又去新增webpack配置？这样做太麻烦了，<a href=\"https://github.com/gwuhaolin/web-webpack-plugin\" target=\"_blank\" rel=\"noopener\">web-webpack-plugin</a>里的<code>AutoWebPlugin</code>可以方便的解决这些问题。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        <span class=\"comment\">// 所有页面的入口目录</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> AutoWebPlugin(<span class=\"string\">'./src/'</span>),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>AutoWebPlugin</code>会把<code>./src/</code>目录下所有每个文件夹作为一个单页页面的入口，自动为所有的页面入口配置一个WebPlugin输出对应的html。要新增一个页面就在<code>./src/</code>下新建一个文件夹包含这个单页应用所依赖的代码，<code>AutoWebPlugin</code>自动生成一个名叫文件夹名称的html文件。<code>AutoWebPlugin</code>的更多功能见<a href=\"https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#自动探测html入口-demo\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h3 id=\"代码分割优化\"><a href=\"#代码分割优化\" class=\"headerlink\" title=\"代码分割优化\"></a>代码分割优化</h3><p>一个好的代码分割对浏览器首屏效果提升很大。比如对于最常见的react体系你可以</p>\n<ol>\n<li>先抽出基础库<code>react</code> <code>react-dom</code> <code>redux</code> <code>react-redux</code>到一个单独的文件而不是和其它文件放在一起打包为一个文件，这样做的好处是只要你不升级他们的版本这个文件永远不会被刷新。如果你把这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致文件hash值变化从而导致缓存失效浏览器重复下载这些包含基础库的代码。以上的配置为：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vender.js 文件抽离基础库到单独的一个文件里防止跟随业务代码被刷新</span></span><br><span class=\"line\"><span class=\"comment\">// 所有页面都依赖的第三方库</span></span><br><span class=\"line\"><span class=\"comment\">// react基础</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"comment\">// redux基础</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'redux-thunk'</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack配置</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    vendor: <span class=\"string\">'./path/to/vendor.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>再通过<a href=\"https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin\" target=\"_blank\" rel=\"noopener\">CommonsChunkPlugin</a>可以提取出多个代码块都依赖的代码形成一个单独的<code>chunk</code>。在应用有多个页面的场景下提取出所有页面公共的代码减少单个页面的代码，在不同页面之间切换时所有页面公共的代码之前被加载过而不必重新加载。</li>\n</ol>\n<h3 id=\"构建npm包\"><a href=\"#构建npm包\" class=\"headerlink\" title=\"构建npm包\"></a>构建npm包</h3><p><strong>demo <a href=\"https://github.com/gwuhaolin/remd\" target=\"_blank\" rel=\"noopener\">remd</a></strong><br>除了构建可运行的web应用，webpack也可用来构建发布到npm上去的给别人调用的js库。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> nodeExternals = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-node-externals'</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    index: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  externals: [nodeExternals()],</span><br><span class=\"line\">  target: <span class=\"string\">'node'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'.npm'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span>,</span><br><span class=\"line\">    libraryTarget: <span class=\"string\">'commonjs2'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这里有几个区别于web应用不同的地方：</p>\n<ul>\n<li><code>externals: [nodeExternals()]</code>用于排除<code>node_modules</code>目录下的代码被打包进去，因为放在<code>node_modules</code>目录下的代码应该通过npm安装。</li>\n<li><code>libraryTarget: &#39;commonjs2&#39;</code>指出<code>entry</code>是一个可供别人调用的库而不是可执行的，输出的js文件按照commonjs规范。</li>\n</ul>\n<h3 id=\"构建服务端渲染\"><a href=\"#构建服务端渲染\" class=\"headerlink\" title=\"构建服务端渲染\"></a>构建服务端渲染</h3><p>服务端渲染的代码要运行在nodejs环境，和浏览器不同的是，服务端渲染代码需要采用commonjs规范同时不应该包含除js之外的文件比如css。webpack配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  target: <span class=\"string\">'node'</span>,</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    <span class=\"string\">'server_render'</span>: <span class=\"string\">'./src/server_render'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'./dist/server/[name].js'</span>,</span><br><span class=\"line\">    libraryTarget: <span class=\"string\">'commonjs2'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(scss|css|pdf)$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'ignore-loader'</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>其中几个关键的地方在于：</p>\n<ul>\n<li><code>target: &#39;node&#39;</code> 指明构建出的代码是要运行在node环境里</li>\n<li><code>libraryTarget: &#39;commonjs2&#39;</code> 指明输出的代码要是commonjs规范</li>\n<li><code>{test: /\\.(scss|css|pdf)$/,loader: &#39;ignore-loader&#39;}</code> 是为了防止不能在node里执行服务端渲染也用不上的文件被打包进去。</li>\n</ul>\n<h3 id=\"从fis3迁移到webpack\"><a href=\"#从fis3迁移到webpack\" class=\"headerlink\" title=\"从fis3迁移到webpack\"></a>从fis3迁移到webpack</h3><p>fis3和webpack有相似的地方也有不同的地方。相似在于他们都采用commonjs规范，不同在于导入css这些非js资源的方式。fis3通过<code>// @require &#39;./index.scss&#39;</code>而webpack通过<code>require(&#39;./index.scss&#39;)</code>。如果想从fis3平滑迁移到webpack可以使用<a href=\"https://github.com/gwuhaolin/comment-require-loader/issues\" target=\"_blank\" rel=\"noopener\">comment-require-loader</a>。比如你想在webpack构建是使用采用了fis3方式的<code>imui</code>模块，配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loaders:[&#123;</span><br><span class=\"line\">     test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">     loaders: [<span class=\"string\">'comment-require-loader'</span>],</span><br><span class=\"line\">     include: [path.resolve(__dirname, <span class=\"string\">'node_modules/imui'</span>),]</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"自定义webpack扩展\"><a href=\"#自定义webpack扩展\" class=\"headerlink\" title=\"自定义webpack扩展\"></a>自定义webpack扩展</h2><p>如果你在社区找不到你的应用场景的解决方案，那就需要自己动手了写loader或者plugin了。<br>在你编写自定义webpack扩展前你需要想明白到底是要做一个<code>loader</code>还是<code>plugin</code>呢？可以这样判断：</p>\n<blockquote>\n<p>如果你的扩展是想对一个个单独的文件进行转换那么就编写<code>loader</code>剩下的都是<code>plugin</code>。</p>\n</blockquote>\n<p>其中对文件进行转换可以是像：</p>\n<ul>\n<li><code>babel-loader</code>把es6转换成<code>es5</code></li>\n<li><code>file-loader</code>把文件替换成对应的URL</li>\n<li><code>raw-loader</code>注入文本文件内容到代码里去</li>\n</ul>\n<h3 id=\"编写-webpack-loader\"><a href=\"#编写-webpack-loader\" class=\"headerlink\" title=\"编写 webpack loader\"></a>编写 webpack loader</h3><p><strong>demo <a href=\"https://github.com/gwuhaolin/comment-require-loader\" target=\"_blank\" rel=\"noopener\">comment-require-loader</a></strong><br>编写<code>loader</code>非常简单，以comment-require-loader为例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> replace(content);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>loader</code>的入口需要导出一个函数，这个函数要干的事情就是转换一个文件的内容。<br>函数接收的参数<code>content</code>是一个文件在转换前的字符串形式内容，需要返回一个新的字符串形式内容作为转换后的结果，所有通过模块化倒入的文件都会经过<code>loader</code>。从这里可以看出<code>loader</code>只能处理一个个单独的文件而不能处理代码块。想编写更复杂的loader可参考<a href=\"https://webpack.github.io/docs/loaders.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h3 id=\"编写-webpack-plugin\"><a href=\"#编写-webpack-plugin\" class=\"headerlink\" title=\"编写 webpack plugin\"></a>编写 webpack plugin</h3><p><strong>demo <a href=\"https://github.com/gwuhaolin/end-webpack-plugin\" target=\"_blank\" rel=\"noopener\">end-webpack-plugin</a></strong><br><code>plugin</code>应用场景广泛，所以稍微复杂点。以end-webpack-plugin为例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EndWebpackPlugin</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(doneCallback, failCallback) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.doneCallback = doneCallback;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.failCallback = failCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    apply(compiler) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 监听webpack生命周期里的事件，做相应的处理</span></span><br><span class=\"line\">        compiler.plugin(<span class=\"string\">'done'</span>, (stats) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.doneCallback(stats);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        compiler.plugin(<span class=\"string\">'failed'</span>, (err) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.failCallback(err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = EndWebpackPlugin;</span><br></pre></td></tr></table></figure></p>\n<p><code>loader</code>的入口需要导出一个class, 在<code>new EndWebpackPlugin()</code>的时候通过构造函数传入这个插件需要的参数，在webpack启动的时候会先实例化<code>plugin</code>再调用<code>plugin</code>的<code>apply</code>方法，插件需要在<code>apply</code>函数里监听webpack生命周期里的事件，做相应的处理。<br>webpack plugin 里有2个核心概念：</p>\n<ul>\n<li><code>Compiler</code>: 从webpack启动到推出只存在一个<code>Compiler</code>，<code>Compiler</code>存放着webpack配置</li>\n<li><code>Compilation</code>: 由于webpack的监听文件变化自动编译机制，<code>Compilation</code>代表一次编译。</li>\n</ul>\n<p><code>Compiler</code> 和 <code>Compilation</code> 都会广播一系列事件。<br>webpack生命周期里有非常多的事件可以在<a href=\"https://webpack.js.org/api/plugins/compiler/#event-hooks\" target=\"_blank\" rel=\"noopener\">event-hooks</a>和<a href=\"https://webpack.js.org/api/plugins/compilation/\" target=\"_blank\" rel=\"noopener\">Compilation</a>里查到。以上只是一个最简单的demo，更复杂的可以查看 <a href=\"https://github.com/webpack/docs/wiki/how-to-write-a-plugin\" target=\"_blank\" rel=\"noopener\">how to write a plugin</a>或参考<a href=\"https://github.com/gwuhaolin/web-webpack-plugin\" target=\"_blank\" rel=\"noopener\">web-webpack-plugin</a>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>webpack其实很简单，可以用一句话涵盖它的本质：</p>\n<blockquote>\n<p>webpack是一个打包模块化js的工具，可以通过loader转换文件，通过plugin扩展功能。</p>\n</blockquote>\n<p>如果webpack让你感到复杂，一定是各种loader和plugin的原因。<br>希望本文能让你明白webpack的原理与本质让你可以在实战中灵活应用webpack。</p>\n<p><a href=\"http://wuhaolin.cn/2017/05/31/webpack%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/\">阅读原文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://webpack.wuhaolin.cn/\" target=\"_blank\" rel=\"noopener\"><img src=\"http://ou8vcvyuy.bkt.clouddn.com/dive-into-webpack-for-blog.jpg\" alt=\"\"></a></p>\n<p>webpack是一个js打包工具，不一个完整的前端构建工具。它的流行得益于模块化和单页应用的流行。webpack提供扩展机制，在庞大的社区支持下各种场景基本它都可找到解决方案。本文的目的是教会你用webpack解决实战中常见的问题。</p>\n<h2 id=\"webpack原理\"><a href=\"#webpack原理\" class=\"headerlink\" title=\"webpack原理\"></a>webpack原理</h2><p>在深入实战前先要知道webpack的运行原理</p>\n<h3 id=\"webpack核心概念\"><a href=\"#webpack核心概念\" class=\"headerlink\" title=\"webpack核心概念\"></a>webpack核心概念</h3><ul>\n<li><code>entry</code> 一个可执行模块或库的入口文件。</li>\n<li><code>chunk</code> 多个文件组成的一个代码块，例如把一个可执行模块和它所有依赖的模块组合和一个 <code>chunk</code> 这体现了webpack的打包机制。</li>\n<li><code>loader</code> 文件转换器，例如把es6转换为es5，scss转换为css。</li>\n<li><code>plugin</code> 插件，用于扩展webpack的功能，在webpack构建生命周期的节点上加入扩展hook为webpack加入功能。</li>\n</ul>\n<h3 id=\"webpack构建流程\"><a href=\"#webpack构建流程\" class=\"headerlink\" title=\"webpack构建流程\"></a>webpack构建流程</h3><p>从启动webpack构建到输出结果经历了一系列过程，它们是：</p>\n<ol>\n<li>解析webpack配置参数，合并从shell传入和<code>webpack.config.js</code>文件里配置的参数，生产最后的配置结果。</li>\n<li>注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。</li>\n<li>从配置的<code>entry</code>入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。</li>\n<li>在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。</li>\n<li>递归完后得到每个文件的最终结果，根据<code>entry</code>配置生成代码块<code>chunk</code>。</li>\n<li>输出所有<code>chunk</code>到文件系统。</li>\n</ol>\n<p>需要注意的是，在构建生命周期中有一系列插件在合适的时机做了合适的事情，比如<code>UglifyJsPlugin</code>会在loader转换递归完后对结果再使用<code>UglifyJs</code>压缩覆盖之前的结果。</p>\n<h2 id=\"场景和方案\"><a href=\"#场景和方案\" class=\"headerlink\" title=\"场景和方案\"></a>场景和方案</h2><p>通过各种场景和对应的解决方案让你深入掌握webpack</p>\n<h3 id=\"单页应用\"><a href=\"#单页应用\" class=\"headerlink\" title=\"单页应用\"></a>单页应用</h3><p><strong>demo <a href=\"https://github.com/gwuhaolin/redemo\" target=\"_blank\" rel=\"noopener\">redemo</a></strong><br>一个单页应用需要配置一个<code>entry</code>指明执行入口，webpack会为<code>entry</code>生成一个包含这个入口所有依赖文件的<code>chunk</code>，但要让它在浏览器里跑起来还需要一个HTML文件来加载<code>chunk</code>生成的js文件，如果提取出了css还需要让HTML文件引入提取出的css。<a href=\"https://github.com/gwuhaolin/web-webpack-plugin\" target=\"_blank\" rel=\"noopener\">web-webpack-plugin</a>里的<code>WebPlugin</code>可以自动的完成这些工作。</p>\n<p>webpack配置文件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; WebPlugin &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'web-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: <span class=\"string\">'./src/doc/index.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// 一个WebPlugin对应生成一个html文件</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> WebPlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">//输出的html文件名称</span></span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>,</span><br><span class=\"line\">      <span class=\"comment\">//这个html依赖的`entry`</span></span><br><span class=\"line\">      requires: [<span class=\"string\">'app'</span>],</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>requires: [&#39;doc&#39;]</code>指明这个HTML依赖哪些<code>entry</code>，<code>entry</code>生成的js和css会自动注入到HTML里。<br>你还可以配置这些资源的注入方式，支持如下属性：</p>\n<ul>\n<li><code>_dist</code> 只有在生产环境下才引入该资源</li>\n<li><code>_dev</code> 只有在开发环境下才引入该资源</li>\n<li><code>_inline</code> 把该资源的内容潜入到html里</li>\n<li><code>_ie</code> 只有IE浏览器才需要引入的资源</li>\n</ul>\n<p>要设置这些属性可以通过在js里配置<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> WebPlugin(&#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'index.html'</span>,</span><br><span class=\"line\">    requires: &#123;</span><br><span class=\"line\">         app:&#123;</span><br><span class=\"line\">              _dist:<span class=\"literal\">true</span>,</span><br><span class=\"line\">              _inline:<span class=\"literal\">false</span>,</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure></p>\n<p>或者在模版里设置，使用模版的好处是灵活的控制资源注入点。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> WebPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>,</span><br><span class=\"line\">      template: <span class=\"string\">'./template.html'</span>,</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"zh-cn\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"app?_inline\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"ie-polyfill?_ie\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"react-body\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>WebPlugin</code>插件借鉴了<code>fis3</code>的思想，补足了webpack缺失的以HTML为入口的功能。想了解<code>WebPlugin</code>的更多功能，见<a href=\"https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#输出html文件-demo\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h3 id=\"一个项目里管理多个单页应用\"><a href=\"#一个项目里管理多个单页应用\" class=\"headerlink\" title=\"一个项目里管理多个单页应用\"></a>一个项目里管理多个单页应用</h3><p>一般项目里会包含多个单页应用，虽然多个单页应用也可以合并成一个但是这样做会导致用户没访问的部分也加载了。如果项目里有很多个单页应用，为每个单页应用配置一个<code>entry</code>和<code>WebPlugin</code>？如果项目又新增了一个单页应用，又去新增webpack配置？这样做太麻烦了，<a href=\"https://github.com/gwuhaolin/web-webpack-plugin\" target=\"_blank\" rel=\"noopener\">web-webpack-plugin</a>里的<code>AutoWebPlugin</code>可以方便的解决这些问题。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        <span class=\"comment\">// 所有页面的入口目录</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> AutoWebPlugin(<span class=\"string\">'./src/'</span>),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>AutoWebPlugin</code>会把<code>./src/</code>目录下所有每个文件夹作为一个单页页面的入口，自动为所有的页面入口配置一个WebPlugin输出对应的html。要新增一个页面就在<code>./src/</code>下新建一个文件夹包含这个单页应用所依赖的代码，<code>AutoWebPlugin</code>自动生成一个名叫文件夹名称的html文件。<code>AutoWebPlugin</code>的更多功能见<a href=\"https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#自动探测html入口-demo\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h3 id=\"代码分割优化\"><a href=\"#代码分割优化\" class=\"headerlink\" title=\"代码分割优化\"></a>代码分割优化</h3><p>一个好的代码分割对浏览器首屏效果提升很大。比如对于最常见的react体系你可以</p>\n<ol>\n<li>先抽出基础库<code>react</code> <code>react-dom</code> <code>redux</code> <code>react-redux</code>到一个单独的文件而不是和其它文件放在一起打包为一个文件，这样做的好处是只要你不升级他们的版本这个文件永远不会被刷新。如果你把这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致文件hash值变化从而导致缓存失效浏览器重复下载这些包含基础库的代码。以上的配置为：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vender.js 文件抽离基础库到单独的一个文件里防止跟随业务代码被刷新</span></span><br><span class=\"line\"><span class=\"comment\">// 所有页面都依赖的第三方库</span></span><br><span class=\"line\"><span class=\"comment\">// react基础</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"comment\">// redux基础</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'redux-thunk'</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack配置</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    vendor: <span class=\"string\">'./path/to/vendor.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>再通过<a href=\"https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin\" target=\"_blank\" rel=\"noopener\">CommonsChunkPlugin</a>可以提取出多个代码块都依赖的代码形成一个单独的<code>chunk</code>。在应用有多个页面的场景下提取出所有页面公共的代码减少单个页面的代码，在不同页面之间切换时所有页面公共的代码之前被加载过而不必重新加载。</li>\n</ol>\n<h3 id=\"构建npm包\"><a href=\"#构建npm包\" class=\"headerlink\" title=\"构建npm包\"></a>构建npm包</h3><p><strong>demo <a href=\"https://github.com/gwuhaolin/remd\" target=\"_blank\" rel=\"noopener\">remd</a></strong><br>除了构建可运行的web应用，webpack也可用来构建发布到npm上去的给别人调用的js库。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> nodeExternals = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-node-externals'</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    index: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  externals: [nodeExternals()],</span><br><span class=\"line\">  target: <span class=\"string\">'node'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'.npm'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span>,</span><br><span class=\"line\">    libraryTarget: <span class=\"string\">'commonjs2'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这里有几个区别于web应用不同的地方：</p>\n<ul>\n<li><code>externals: [nodeExternals()]</code>用于排除<code>node_modules</code>目录下的代码被打包进去，因为放在<code>node_modules</code>目录下的代码应该通过npm安装。</li>\n<li><code>libraryTarget: &#39;commonjs2&#39;</code>指出<code>entry</code>是一个可供别人调用的库而不是可执行的，输出的js文件按照commonjs规范。</li>\n</ul>\n<h3 id=\"构建服务端渲染\"><a href=\"#构建服务端渲染\" class=\"headerlink\" title=\"构建服务端渲染\"></a>构建服务端渲染</h3><p>服务端渲染的代码要运行在nodejs环境，和浏览器不同的是，服务端渲染代码需要采用commonjs规范同时不应该包含除js之外的文件比如css。webpack配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  target: <span class=\"string\">'node'</span>,</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    <span class=\"string\">'server_render'</span>: <span class=\"string\">'./src/server_render'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'./dist/server/[name].js'</span>,</span><br><span class=\"line\">    libraryTarget: <span class=\"string\">'commonjs2'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(scss|css|pdf)$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'ignore-loader'</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>其中几个关键的地方在于：</p>\n<ul>\n<li><code>target: &#39;node&#39;</code> 指明构建出的代码是要运行在node环境里</li>\n<li><code>libraryTarget: &#39;commonjs2&#39;</code> 指明输出的代码要是commonjs规范</li>\n<li><code>{test: /\\.(scss|css|pdf)$/,loader: &#39;ignore-loader&#39;}</code> 是为了防止不能在node里执行服务端渲染也用不上的文件被打包进去。</li>\n</ul>\n<h3 id=\"从fis3迁移到webpack\"><a href=\"#从fis3迁移到webpack\" class=\"headerlink\" title=\"从fis3迁移到webpack\"></a>从fis3迁移到webpack</h3><p>fis3和webpack有相似的地方也有不同的地方。相似在于他们都采用commonjs规范，不同在于导入css这些非js资源的方式。fis3通过<code>// @require &#39;./index.scss&#39;</code>而webpack通过<code>require(&#39;./index.scss&#39;)</code>。如果想从fis3平滑迁移到webpack可以使用<a href=\"https://github.com/gwuhaolin/comment-require-loader/issues\" target=\"_blank\" rel=\"noopener\">comment-require-loader</a>。比如你想在webpack构建是使用采用了fis3方式的<code>imui</code>模块，配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loaders:[&#123;</span><br><span class=\"line\">     test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">     loaders: [<span class=\"string\">'comment-require-loader'</span>],</span><br><span class=\"line\">     include: [path.resolve(__dirname, <span class=\"string\">'node_modules/imui'</span>),]</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"自定义webpack扩展\"><a href=\"#自定义webpack扩展\" class=\"headerlink\" title=\"自定义webpack扩展\"></a>自定义webpack扩展</h2><p>如果你在社区找不到你的应用场景的解决方案，那就需要自己动手了写loader或者plugin了。<br>在你编写自定义webpack扩展前你需要想明白到底是要做一个<code>loader</code>还是<code>plugin</code>呢？可以这样判断：</p>\n<blockquote>\n<p>如果你的扩展是想对一个个单独的文件进行转换那么就编写<code>loader</code>剩下的都是<code>plugin</code>。</p>\n</blockquote>\n<p>其中对文件进行转换可以是像：</p>\n<ul>\n<li><code>babel-loader</code>把es6转换成<code>es5</code></li>\n<li><code>file-loader</code>把文件替换成对应的URL</li>\n<li><code>raw-loader</code>注入文本文件内容到代码里去</li>\n</ul>\n<h3 id=\"编写-webpack-loader\"><a href=\"#编写-webpack-loader\" class=\"headerlink\" title=\"编写 webpack loader\"></a>编写 webpack loader</h3><p><strong>demo <a href=\"https://github.com/gwuhaolin/comment-require-loader\" target=\"_blank\" rel=\"noopener\">comment-require-loader</a></strong><br>编写<code>loader</code>非常简单，以comment-require-loader为例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> replace(content);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>loader</code>的入口需要导出一个函数，这个函数要干的事情就是转换一个文件的内容。<br>函数接收的参数<code>content</code>是一个文件在转换前的字符串形式内容，需要返回一个新的字符串形式内容作为转换后的结果，所有通过模块化倒入的文件都会经过<code>loader</code>。从这里可以看出<code>loader</code>只能处理一个个单独的文件而不能处理代码块。想编写更复杂的loader可参考<a href=\"https://webpack.github.io/docs/loaders.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h3 id=\"编写-webpack-plugin\"><a href=\"#编写-webpack-plugin\" class=\"headerlink\" title=\"编写 webpack plugin\"></a>编写 webpack plugin</h3><p><strong>demo <a href=\"https://github.com/gwuhaolin/end-webpack-plugin\" target=\"_blank\" rel=\"noopener\">end-webpack-plugin</a></strong><br><code>plugin</code>应用场景广泛，所以稍微复杂点。以end-webpack-plugin为例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EndWebpackPlugin</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(doneCallback, failCallback) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.doneCallback = doneCallback;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.failCallback = failCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    apply(compiler) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 监听webpack生命周期里的事件，做相应的处理</span></span><br><span class=\"line\">        compiler.plugin(<span class=\"string\">'done'</span>, (stats) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.doneCallback(stats);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        compiler.plugin(<span class=\"string\">'failed'</span>, (err) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.failCallback(err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = EndWebpackPlugin;</span><br></pre></td></tr></table></figure></p>\n<p><code>loader</code>的入口需要导出一个class, 在<code>new EndWebpackPlugin()</code>的时候通过构造函数传入这个插件需要的参数，在webpack启动的时候会先实例化<code>plugin</code>再调用<code>plugin</code>的<code>apply</code>方法，插件需要在<code>apply</code>函数里监听webpack生命周期里的事件，做相应的处理。<br>webpack plugin 里有2个核心概念：</p>\n<ul>\n<li><code>Compiler</code>: 从webpack启动到推出只存在一个<code>Compiler</code>，<code>Compiler</code>存放着webpack配置</li>\n<li><code>Compilation</code>: 由于webpack的监听文件变化自动编译机制，<code>Compilation</code>代表一次编译。</li>\n</ul>\n<p><code>Compiler</code> 和 <code>Compilation</code> 都会广播一系列事件。<br>webpack生命周期里有非常多的事件可以在<a href=\"https://webpack.js.org/api/plugins/compiler/#event-hooks\" target=\"_blank\" rel=\"noopener\">event-hooks</a>和<a href=\"https://webpack.js.org/api/plugins/compilation/\" target=\"_blank\" rel=\"noopener\">Compilation</a>里查到。以上只是一个最简单的demo，更复杂的可以查看 <a href=\"https://github.com/webpack/docs/wiki/how-to-write-a-plugin\" target=\"_blank\" rel=\"noopener\">how to write a plugin</a>或参考<a href=\"https://github.com/gwuhaolin/web-webpack-plugin\" target=\"_blank\" rel=\"noopener\">web-webpack-plugin</a>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>webpack其实很简单，可以用一句话涵盖它的本质：</p>\n<blockquote>\n<p>webpack是一个打包模块化js的工具，可以通过loader转换文件，通过plugin扩展功能。</p>\n</blockquote>\n<p>如果webpack让你感到复杂，一定是各种loader和plugin的原因。<br>希望本文能让你明白webpack的原理与本质让你可以在实战中灵活应用webpack。</p>\n<p><a href=\"http://wuhaolin.cn/2017/05/31/webpack%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/\">阅读原文</a></p>\n"},{"title":"WebAssembly 现状与实战","date":"2018-08-10T17:35:23.000Z","url":"https://github.com/gwuhaolin/blog/issues/17","_content":"\n## 为什么需要 WebAssembly\n\n自从 JavaScript 诞生起到现在已经变成最流行的编程语言，这背后正是 Web 的发展所推动的。Web 应用变得更多更复杂，但这也渐渐暴露出了 JavaScript 的问题：\n\n- 语法太灵活导致开发大型 Web 项目困难；\n- 性能不能满足一些场景的需要。\n\n针对以上两点缺陷，近年来出现了一些 JS 的代替语言，例如：\n\n- 微软的[ TypeScript ](http://www.typescriptlang.org/)通过为 JS 加入静态类型检查来改进 JS 松散的语法，提升代码健壮性；\n- 谷歌的[ Dart ](https://www.dartlang.org/)则是为浏览器引入新的虚拟机去直接运行 Dart 程序以提升性能；\n- 火狐的[ asm.js ](http://asmjs.org/)则是取 JS 的子集，JS 引擎针对 asm.js 做性能优化。\n\n以上尝试各有优缺点，其中：\n\n- TypeScript 只是解决了 JS 语法松散的问题，最后还是需要编译成 JS 去运行，对性能没有提升；\n- Dart 只能在 Chrome 预览版中运行，无主流浏览器支持，用 Dart 开发的人不多；\n- asm.js 语法太简单、有很大限制，开发效率低。\n\n三大浏览器巨头分别提出了自己的解决方案，互不兼容，这违背了 Web 的宗旨； 是技术的规范统一让 Web 走到了今天，因此形成一套新的规范去解决 JS 所面临的问题迫在眉睫。\n\n于是 WebAssembly 诞生了，WebAssembly 是一种新的字节码格式，主流浏览器都已经支持 WebAssembly。 和 JS 需要解释执行不同的是，WebAssembly 字节码和底层机器码很相似可快速装载运行，因此性能相对于 JS 解释执行大大提升。 也就是说 WebAssembly 并不是一门编程语言，而是一份字节码标准，需要用高级编程语言编译出字节码放到 WebAssembly 虚拟机中才能运行， 浏览器厂商需要做的就是根据 WebAssembly 规范实现虚拟机。\n\n## WebAssembly 原理\n\n要搞懂 WebAssembly 的原理，需要先搞懂计算机的运行原理。 电子计算机都是由电子元件组成，为了方便处理电子元件只存在开闭两种状态，对应着 0 和 1，也就是说计算机只认识 0 和 1，数据和逻辑都需要由 0 和 1 表示，也就是可以直接装载到计算机中运行的机器码。 机器码可读性极差，因此人们通过高级语言 C、C++、Rust、Go 等编写再编译成机器码。\n\n由于不同的计算机 CPU 架构不同，机器码标准也有所差别，常见的 CPU 架构包括 x86、AMD64、ARM， 因此在由高级编程语言编译成可自行代码时需要指定目标架构。\n\nWebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行， 但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。\n\n相对于 JS，WebAssembly 有如下优点：\n\n- 体积小：由于浏览器运行时只加载编译成的字节码，一样的逻辑比用字符串描述的 JS 文件体积要小很多；\n- 加载快：由于文件体积小，再加上无需解释执行，WebAssembly 能更快的加载并实例化，减少运行前的等待时间；\n- 兼容性问题少：WebAssembly 是非常底层的字节码规范，制订好后很少变动，就算以后发生变化,也只需在从高级语言编译成字节码过程中做兼容。可能出现兼容性问题的地方在于 JS 和 WebAssembly 桥接的 JS 接口。\n\n每个高级语言都去实现源码到不同平台的机器码的转换工作是重复的，高级语言只需要生成底层虚拟机(LLVM)认识的中间语言(LLVM IR)，[LLVM ](https://llvm.org/)能实现：\n\n- LLVM IR 到不同 CPU 架构机器码的生成；\n- 机器码编译时性能和大小优化。\n\n除此之外 LLVM 还实现了 LLVM IR 到 WebAssembly 字节码的编译功能，也就是说只要高级语言能转换成 LLVM IR，就能被编译成 WebAssembly 字节码，目前能编译成 WebAssembly 字节码的高级语言有：\n\n- [AssemblyScript](https://github.com/AssemblyScript/assemblyscript):语法和 TypeScript 一致，对前端来说学习成本低，为前端编写 WebAssembly 最佳选择；\n- c\\c++:官方推荐的方式，详细使用见[文档](http://webassembly.org.cn/getting-started/developers-guide/);\n- [Rust](https://www.rust-lang.org/):语法复杂、学习成本高，对前端来说可能会不适应。详细使用见[文档](https://github.com/rust-lang-nursery/rust-wasm);\n- [Kotlin](http://kotlinlang.org/):语法和 Java、JS 相似，语言学习成本低，详细使用见[文档](https://kotlinlang.org/docs/reference/native-overview.html);\n- [Golang](https://golang.org/):语法简单学习成本低。但对 WebAssembly 的支持还处于未正式发布阶段，详细使用见[文档](https://blog.gopheracademy.com/advent-2017/go-wasm/)。\n\n通常负责把高级语言翻译到 LLVM IR 的部分叫做编译器前端，把 LLVM IR 编译成各架构 CPU 对应机器码的部分叫做编译器后端； 现在越来越多的高级编程语言选择 LLVM 作为后端，高级语言只需专注于如何提供开发效率更高的语法同时保持翻译到 LLVM IR 的程序执行性能。\n\n## 编写 WebAssembly\n\n### AssemblyScript 初体验\n\n接下来详细介绍如何使用 AssemblyScript 来编写 WebAssembly，实现斐波那契序列的计算。 用 TypeScript 实现斐波那契序列计算的模块 f.ts 如下：\n\n```js\nexport function f(x: i32): i32 {\n    if (x === 1 || x === 2) {\n        return 1;\n    }\n    return f(x - 1) + f(x - 2)\n}\n```\n\n在按照 [AssemblyScript 提供的安装教程](https://github.com/AssemblyScript/assemblyscript#installation)成功安装后， 再通过\n\n```bash\nasc f.ts -o f.wasm\n```\n\n就能把以上代码编译成可运行的 WebAssembly 模块。\n\n为了加载并执行编译出的 f.wasm 模块，需要通过 JS 去加载并调用模块上的 f 函数，为此需要以下 JS 代码：\n\n```js\nfetch('f.wasm') // 网络加载 f.wasm 文件\n    .then(res => res.arrayBuffer()) // 转成 ArrayBuffer\n    .then(WebAssembly.instantiate) // 编译为当前 CPU 架构的机器码 + 实例化\n    .then(mod => { // 调用模块实例上的 f 函数计算\n    console.log(mod.instance.f(50));\n    });\n```\n\n以上代码中出现了一个新的内置类型 i32，这是 AssemblyScript 在 TypeScript 的基础上内置的类型。 AssemblyScript 和 TypeScript 有细微区别，AssemblyScript 是 TypeScript 的子集，为了方便编译成 WebAssembly 在 TypeScript 的基础上加了更严格的[类型限制](https://github.com/AssemblyScript/assemblyscript/wiki/Limitations)， 区别如下：\n\n- 比 TypeScript 多了很多更细致的内置类型，以优化性能和内存占用，详情[文档](https://github.com/AssemblyScript/assemblyscript/wiki/Types);\n- 不能使用 any 和 undefined 类型，以及枚举类型；\n- 可空类型的变量必须是引用类型，而不能是基本数据类型如 string、number、boolean；\n- 函数中的可选参数必须提供默认值，函数必须有返回类型，无返回值的函数返回类型需要是 void；\n- 不能使用 JS 环境中的内置函数，只能使用 [AssemblyScript 提供的内置函数](https://github.com/AssemblyScript/assemblyscript/wiki/Built-in-functions)。\n\n总体来说 AssemblyScript 比 TypeScript 又多了很多限制，编写起来会觉得局限性很大； 用 AssemblyScript 来写 WebAssembly 经常会出现 tsc 编译通过但运行 WebAssembly 时出错的情况，这很可能就是你没有遵守以上限制导致的；但 AssemblyScript 通过修改 TypeScript 编译器默认配置能在编译阶段找出大多错误。\n\nAssemblyScript 的实现原理其实也借助了 LLVM，它通过 TypeScript 编译器把 TS 源码解析成 AST，再把 AST 翻译成 IR，再通过 LLVM 编译成 WebAssembly 字节码实现； 上面提到的各种限制都是为了方便把 AST 转换成 LLVM IR。\n\n### 为什么选 AssemblyScript 作为 WebAssembly 开发语言\n\nAssemblyScript 相对于 C、Rust 等其它语言去写 WebAssembly 而言，好处除了对前端来说无额外新语言学习成本外，还有对于不支持 WebAssembly 的浏览器，可以通过 TypeScript 编译器编译成可正常执行的 JS 代码，从而实现从 JS 到 WebAssembly 的平滑迁移。\n\n### 接入 Webpack 构建\n\n任何新的 Web 开发技术都少不了构建流程，为了提供一套流畅的 WebAssembly 开发流程，接下来介绍接入 Webpack 具体步骤。\n\n1. 安装以下依赖，以便让 TS 源码被 AssemblyScript 编译成 WebAssembly。\n\n   ```js\n   {\n     \"devDependencies\": {\n       \"assemblyscript\": \"github:AssemblyScript/assemblyscript\",\n       \"assemblyscript-typescript-loader\": \"^1.3.2\",\n       \"typescript\": \"^2.8.1\",\n       \"webpack\": \"^3.10.0\",\n       \"webpack-dev-server\": \"^2.10.1\"\n     }\n   }\n   ```\n\n   \n\n2. 修改 webpack.config.js，加入 loader：\n\n   ```\n   module.exports = {\n       module: {\n           rules: [\n               {\n                   test: /\\.ts$/,\n                   loader: 'assemblyscript-typescript-loader',\n                   options: {\n                       sourceMap: true,\n                   }\n               }\n           ]\n       },\n   };\n   ```\n\n   \n\n3. 修改 TypeScript 编译器配置 tsconfig.json，以便让 TypeScript 编译器能支持 AssemblyScript 中引入的内置类型和函数。\n\n   ```\n   {\n     \"extends\": \"../../node_modules/assemblyscript/std/portable.json\",\n     \"include\": [\n       \"./**/*.ts\"\n     ]\n   }\n   ```\n\n4. 配置直接继承自 assemblyscript 内置的配置文件。\n\n## WebAssembly 相关文件格式\n\n前面提到了 WebAssembly 的二进制文件格式 wasm，这种格式的文件人眼无法阅读，为了阅读 WebAssembly 文件的逻辑，还有一种文本格式叫 wast； 以前面讲到的计算斐波那契序列的模块为例，对应的 wast 文件如下：\n\n```\nfunc $src/asm/module/f (param f64) (result f64)\n(local i32)\n  get_local 0\n  f64.const 1\n  f64.eq\n  tee_local 1\n  if i32\n    get_local 1\n  else\n    get_local 0\n    f64.const 2\n    f64.eq\n  end\n  i32.const 1\n  i32.and\n  if\n    f64.const 1\n    return\n  end\n  get_local 0\n  f64.const 1\n  f64.sub\n  call 0\n  get_local 0\n  f64.const 2\n  f64.sub\n  call 0\n  f64.add\nend\n```\n\n这和汇编语言非常像，里面的 f64 是数据类型，f64.eq f64.sub f64.add 则是 CPU 指令。\n\n为了把二进制文件格式 wasm 转换成人眼可见的 wast 文本，需要安装 WebAssembly 二进制工具箱[WABT](https://github.com/WebAssembly/wabt)， 在 Mac 系统下可通过 brew install WABT 安装，安装成功后可以通过命令 wasm2wast f.wasm 获得 wast；除此之外还可以通过 wast2wasm f.wast -o f.wasm 逆向转换回去。\n\n## WebAssembly 相关工具\n\n除了前面提到的 WebAssembly 二进制工具箱，WebAssembly 社区还有以下常用工具：\n\n- [Emscripten](http://kripken.github.io/emscripten-site/): 能把 C、C++代码转换成 wasm、asm.js；\n- [Binaryen](https://github.com/WebAssembly/binaryen): 提供更简洁的 IR，把 IR 转换成 wasm，并且提供 wasm 的编译时优化、wasm 虚拟机，wasm 压缩等功能，前面提到的 AssemblyScript 就是基于它。\n\n## WebAssembly JS API\n\n目前 WebAssembly 只能通过 JS 去加载和执行，但未来在浏览器中可以通过像加载 JS 那样 <script src='f.wasm'></script> 去加载和执行 WebAssembly，下面来详细介绍如何用 JS 调 WebAssembly。\n\nJS 调 WebAssembly 分为 3 大步：**加载字节码 > 编译字节码 > 实例化**，获取到 WebAssembly 实例后就可以通过 JS 去调用了，以上 3 步具体的操作是：\n\n1. 对于浏览器可以通过网络请求去加载字节码，对于 Nodejs 可以通过 fs 模块读取字节码文件；\n2. 在获取到字节码后都需要转换成 ArrayBuffer 后才能被编译，通过 WebAssembly 通过的 JS API [WebAssembly.compile](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compile) 编译后会通过 Promise resolve 一个 [WebAssembly.Module](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module)，这个 module 是不能直接被调用的需要；\n3. 在获取到 module 后需要通过[ WebAssembly.Instance](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Instance) API 去实例化 module，获取到 Instance 后就可以像使用 JS 模块一个调用了。\n\n其中的第 2、3 步可以合并一步完成，前面提到的 [WebAssembly.instantiate](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate) 就做了这两个事情。\n\n```js\nWebAssembly.instantiate(bytes).then(mod=>{\n  mod.instance.f(50);\n})\n```\n\n### WebAssembly 调 JS\n\n之前的例子都是用 JS 去调用 WebAssembly 模块，但是在有些场景下可能需要在 WebAssembly 模块中调用浏览器 API，接下来介绍如何在 WebAssembly 中调用 JS。\n\nWebAssembly.instantiate 函数支持第二个参数 WebAssembly.instantiate(bytes,importObject)，这个 importObject 参数的作用就是 JS 向 WebAssembly 传入 WebAssembly 中需要调用 JS 的 JS 模块。举个具体的例子，改造前面的计算斐波那契序列在 WebAssembly 中调用 Web 中的 window.alert 函数把计算结果弹出来，为此需要改造加载 WebAssembly 模块的 JS 代码：\n\n```js\nWebAssembly.instantiate(bytes,{\n  window:{\n    alert:window.alert\n  }\n}).then(mod=>{\n  mod.instance.f(50);\n})\n```\n\n对应的还需要修改 AssemblyScript 编写的源码：\n\n```js\n// 声明从外部导入的模块类型\ndeclare namespace window {\n    export function alert(v: number): void;\n}\n \nfunction _f(x: number): number {\n    if (x == 1 || x == 2) {\n        return 1;\n    }\n    return _f(x - 1) + _f(x - 2)\n}\n \nexport function f(x: number): void {\n    // 直接调用 JS 模块\n    window.alert(_f(x));\n}\n```\n\n修改以上 AssemblyScript 源码后重新用 asc 通过命令 asc f.ts 编译后输出的 wast 文件比之前多了几行：\n\n```\n(import \"window\" \"alert\" (func $src/asm/module/window.alert (type 0)))\n \n(func $src/asm/module/f (type 0) (param f64)\n    get_local 0\n    call $src/asm/module/_f\n    call $src/asm/module/window.alert)\n```\n\n多出的这部分 wast 代码就是在 AssemblyScript 中调用 JS 中传入的模块的逻辑。\n\n除了以上常用的 API 外，WebAssembly 还提供一些 API，你可以通过这个[ d.ts 文件](https://github.com/01alchemist/webassembly-types/blob/master/webassembly.d.ts)去查看所有 WebAssembly JS API 的细节。\n\n## 不止于浏览器\n\nWebAssembly 作为一种底层字节码，除了能在浏览器中运行外，还能在其它环境运行。\n\n### 直接执行 wasm 二进制文件\n\n前面提到的 Binaryen 提供了在命令行中直接执行 wasm 二进制文件的工具，在 Mac 系统下通过 brew install binaryen 安装成功后，通过 wasm-shell f.wasm 文件即可直接运行。\n\n### 在 Node.js 中运行\n\n目前 V8 JS 引擎已经添加了对 WebAssembly 的支持，Chrome 和 Node.js 都采用了 V8 作为引擎，因此 WebAssembly 也可以运行在 Node.js 环境中；\n\nV8 JS 引擎在运行 WebAssembly 时，WebAssembly 和 JS 是在同一个虚拟机中执行，而不是 WebAssembly 在一个单独的虚拟机中运行，这样方便实现 JS 和 WebAssembly 之间的相互调用。\n\n要让上面的例子在 Node.js 中运行，可以使用以下代码：\n\n```js\nconst fs = require('fs');\n \nfunction toUint8Array(buf) {\n    var u = new Uint8Array(buf.length);\n    for (var i = 0; i < buf.length; ++i) {\n        u[i] = buf[i];\n    }\n    return u;\n}\n \nfunction loadWebAssembly(filename, imports) {\n    // 读取 wasm 文件，并转换成 byte 数组\n    const buffer = toUint8Array(fs.readFileSync(filename));\n    // 编译 wasm 字节码到机器码\n    return WebAssembly.compile(buffer)\n        .then(module => {\n            // 实例化模块\n            return new WebAssembly.Instance(module, imports)\n        })\n}\n \nloadWebAssembly('../temp/assembly/module.wasm')\n    .then(instance => {\n        // 调用 f 函数计算\n        console.log(instance.exports.f(10))\n    });\n```\n\n在 Nodejs 环境中运行 WebAssembly 的意义其实不大，原因在于 Nodejs 支持运行原生模块，而原生模块的性能比 WebAssembly 要好。 如果你是通过 C、Rust 去编写 WebAssembly，你可以直接编译成 Nodejs 可以调用的原生模块。\n\n## WebAssembly 展望\n\n从上面的内容可见 WebAssembly 主要是为了解决 JS 的性能瓶颈，也就是说 WebAssembly 适合用于需要大量计算的场景，例如：\n\n- 在浏览器中处理音视频，[flv.js](https://github.com/Bilibili/flv.js/) 用 WebAssembly 重写后性能会有很大提升；\n- React 的 dom diff 中涉及到大量计算，用 WebAssembly 重写 React 核心模块能提升性能。Safari 浏览器使用的 JS 引擎 JavaScriptCore 也已经支持 WebAssembly，RN 应用性能也能提升；\n- 突破大型 3D 网页游戏性能瓶颈，[白鹭引擎已经开始探索用 WebAssembly](https://feday.fequan.com/2017/WebAssembly%E5%9C%A8%E7%99%BD%E9%B9%AD%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%9E%E8%B7%B5.pdf)。\n\n## 总结\n\nWebAssembly 标准虽然已经定稿并且得到主流浏览器的实现，但目前还存在以下问题：\n\n- 浏览器兼容性不好，只有最新版本的浏览器支持，并且不同的浏览器对 JS WebAssembly 互调的 API 支持不一致；\n- 生态工具不完善不成熟，目前还不能找到一门体验流畅的编写 WebAssembly 的语言，都还处于起步阶段；\n- 学习资料太少，还需要更多的人去探索去踩坑。；\n\n总之现在的 WebAssembly 还不算成熟，如果你的团队没有不可容忍的性能问题，那现在使用 WebAssembly 到产品中还不是时候， 因为这可能会影响到团队的开发效率，或者遇到无法轻易解决的坑而阻塞开发。\n\n## 参考资源\n\n- [asm.js 和 Emscripten 入门教程](http://www.ruanyifeng.com/blog/2017/09/asmjs_emscripten.html)\n- [结构化编译器前端 Clang 介绍](https://www.ibm.com/developerworks/cn/opensource/os-cn-clang/index.html)\n- [理解 WebAssembly 文本格式](https://developer.mozilla.org/zh-CN/docs/WebAssembly/Understanding_the_text_format)\n- [使用 WebAssembly JavaScript API](https://developer.mozilla.org/zh-CN/docs/WebAssembly/Using_the_JavaScript_API)\n\n\n> 本文首发于[IBM Dev社区](https://www.ibm.com/developerworks/cn/web/wa-lo-webassembly-status-and-reality/index.html)\n","source":"_posts/WebAssembly 现状与实战.md","raw":"---\ntitle: WebAssembly 现状与实战\ndate: 2018-08-11T01:35:23Z\nurl: https://github.com/gwuhaolin/blog/issues/17\ntags:\n    - 编程语言\n---\n\n## 为什么需要 WebAssembly\n\n自从 JavaScript 诞生起到现在已经变成最流行的编程语言，这背后正是 Web 的发展所推动的。Web 应用变得更多更复杂，但这也渐渐暴露出了 JavaScript 的问题：\n\n- 语法太灵活导致开发大型 Web 项目困难；\n- 性能不能满足一些场景的需要。\n\n针对以上两点缺陷，近年来出现了一些 JS 的代替语言，例如：\n\n- 微软的[ TypeScript ](http://www.typescriptlang.org/)通过为 JS 加入静态类型检查来改进 JS 松散的语法，提升代码健壮性；\n- 谷歌的[ Dart ](https://www.dartlang.org/)则是为浏览器引入新的虚拟机去直接运行 Dart 程序以提升性能；\n- 火狐的[ asm.js ](http://asmjs.org/)则是取 JS 的子集，JS 引擎针对 asm.js 做性能优化。\n\n以上尝试各有优缺点，其中：\n\n- TypeScript 只是解决了 JS 语法松散的问题，最后还是需要编译成 JS 去运行，对性能没有提升；\n- Dart 只能在 Chrome 预览版中运行，无主流浏览器支持，用 Dart 开发的人不多；\n- asm.js 语法太简单、有很大限制，开发效率低。\n\n三大浏览器巨头分别提出了自己的解决方案，互不兼容，这违背了 Web 的宗旨； 是技术的规范统一让 Web 走到了今天，因此形成一套新的规范去解决 JS 所面临的问题迫在眉睫。\n\n于是 WebAssembly 诞生了，WebAssembly 是一种新的字节码格式，主流浏览器都已经支持 WebAssembly。 和 JS 需要解释执行不同的是，WebAssembly 字节码和底层机器码很相似可快速装载运行，因此性能相对于 JS 解释执行大大提升。 也就是说 WebAssembly 并不是一门编程语言，而是一份字节码标准，需要用高级编程语言编译出字节码放到 WebAssembly 虚拟机中才能运行， 浏览器厂商需要做的就是根据 WebAssembly 规范实现虚拟机。\n\n## WebAssembly 原理\n\n要搞懂 WebAssembly 的原理，需要先搞懂计算机的运行原理。 电子计算机都是由电子元件组成，为了方便处理电子元件只存在开闭两种状态，对应着 0 和 1，也就是说计算机只认识 0 和 1，数据和逻辑都需要由 0 和 1 表示，也就是可以直接装载到计算机中运行的机器码。 机器码可读性极差，因此人们通过高级语言 C、C++、Rust、Go 等编写再编译成机器码。\n\n由于不同的计算机 CPU 架构不同，机器码标准也有所差别，常见的 CPU 架构包括 x86、AMD64、ARM， 因此在由高级编程语言编译成可自行代码时需要指定目标架构。\n\nWebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行， 但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。\n\n相对于 JS，WebAssembly 有如下优点：\n\n- 体积小：由于浏览器运行时只加载编译成的字节码，一样的逻辑比用字符串描述的 JS 文件体积要小很多；\n- 加载快：由于文件体积小，再加上无需解释执行，WebAssembly 能更快的加载并实例化，减少运行前的等待时间；\n- 兼容性问题少：WebAssembly 是非常底层的字节码规范，制订好后很少变动，就算以后发生变化,也只需在从高级语言编译成字节码过程中做兼容。可能出现兼容性问题的地方在于 JS 和 WebAssembly 桥接的 JS 接口。\n\n每个高级语言都去实现源码到不同平台的机器码的转换工作是重复的，高级语言只需要生成底层虚拟机(LLVM)认识的中间语言(LLVM IR)，[LLVM ](https://llvm.org/)能实现：\n\n- LLVM IR 到不同 CPU 架构机器码的生成；\n- 机器码编译时性能和大小优化。\n\n除此之外 LLVM 还实现了 LLVM IR 到 WebAssembly 字节码的编译功能，也就是说只要高级语言能转换成 LLVM IR，就能被编译成 WebAssembly 字节码，目前能编译成 WebAssembly 字节码的高级语言有：\n\n- [AssemblyScript](https://github.com/AssemblyScript/assemblyscript):语法和 TypeScript 一致，对前端来说学习成本低，为前端编写 WebAssembly 最佳选择；\n- c\\c++:官方推荐的方式，详细使用见[文档](http://webassembly.org.cn/getting-started/developers-guide/);\n- [Rust](https://www.rust-lang.org/):语法复杂、学习成本高，对前端来说可能会不适应。详细使用见[文档](https://github.com/rust-lang-nursery/rust-wasm);\n- [Kotlin](http://kotlinlang.org/):语法和 Java、JS 相似，语言学习成本低，详细使用见[文档](https://kotlinlang.org/docs/reference/native-overview.html);\n- [Golang](https://golang.org/):语法简单学习成本低。但对 WebAssembly 的支持还处于未正式发布阶段，详细使用见[文档](https://blog.gopheracademy.com/advent-2017/go-wasm/)。\n\n通常负责把高级语言翻译到 LLVM IR 的部分叫做编译器前端，把 LLVM IR 编译成各架构 CPU 对应机器码的部分叫做编译器后端； 现在越来越多的高级编程语言选择 LLVM 作为后端，高级语言只需专注于如何提供开发效率更高的语法同时保持翻译到 LLVM IR 的程序执行性能。\n\n## 编写 WebAssembly\n\n### AssemblyScript 初体验\n\n接下来详细介绍如何使用 AssemblyScript 来编写 WebAssembly，实现斐波那契序列的计算。 用 TypeScript 实现斐波那契序列计算的模块 f.ts 如下：\n\n```js\nexport function f(x: i32): i32 {\n    if (x === 1 || x === 2) {\n        return 1;\n    }\n    return f(x - 1) + f(x - 2)\n}\n```\n\n在按照 [AssemblyScript 提供的安装教程](https://github.com/AssemblyScript/assemblyscript#installation)成功安装后， 再通过\n\n```bash\nasc f.ts -o f.wasm\n```\n\n就能把以上代码编译成可运行的 WebAssembly 模块。\n\n为了加载并执行编译出的 f.wasm 模块，需要通过 JS 去加载并调用模块上的 f 函数，为此需要以下 JS 代码：\n\n```js\nfetch('f.wasm') // 网络加载 f.wasm 文件\n    .then(res => res.arrayBuffer()) // 转成 ArrayBuffer\n    .then(WebAssembly.instantiate) // 编译为当前 CPU 架构的机器码 + 实例化\n    .then(mod => { // 调用模块实例上的 f 函数计算\n    console.log(mod.instance.f(50));\n    });\n```\n\n以上代码中出现了一个新的内置类型 i32，这是 AssemblyScript 在 TypeScript 的基础上内置的类型。 AssemblyScript 和 TypeScript 有细微区别，AssemblyScript 是 TypeScript 的子集，为了方便编译成 WebAssembly 在 TypeScript 的基础上加了更严格的[类型限制](https://github.com/AssemblyScript/assemblyscript/wiki/Limitations)， 区别如下：\n\n- 比 TypeScript 多了很多更细致的内置类型，以优化性能和内存占用，详情[文档](https://github.com/AssemblyScript/assemblyscript/wiki/Types);\n- 不能使用 any 和 undefined 类型，以及枚举类型；\n- 可空类型的变量必须是引用类型，而不能是基本数据类型如 string、number、boolean；\n- 函数中的可选参数必须提供默认值，函数必须有返回类型，无返回值的函数返回类型需要是 void；\n- 不能使用 JS 环境中的内置函数，只能使用 [AssemblyScript 提供的内置函数](https://github.com/AssemblyScript/assemblyscript/wiki/Built-in-functions)。\n\n总体来说 AssemblyScript 比 TypeScript 又多了很多限制，编写起来会觉得局限性很大； 用 AssemblyScript 来写 WebAssembly 经常会出现 tsc 编译通过但运行 WebAssembly 时出错的情况，这很可能就是你没有遵守以上限制导致的；但 AssemblyScript 通过修改 TypeScript 编译器默认配置能在编译阶段找出大多错误。\n\nAssemblyScript 的实现原理其实也借助了 LLVM，它通过 TypeScript 编译器把 TS 源码解析成 AST，再把 AST 翻译成 IR，再通过 LLVM 编译成 WebAssembly 字节码实现； 上面提到的各种限制都是为了方便把 AST 转换成 LLVM IR。\n\n### 为什么选 AssemblyScript 作为 WebAssembly 开发语言\n\nAssemblyScript 相对于 C、Rust 等其它语言去写 WebAssembly 而言，好处除了对前端来说无额外新语言学习成本外，还有对于不支持 WebAssembly 的浏览器，可以通过 TypeScript 编译器编译成可正常执行的 JS 代码，从而实现从 JS 到 WebAssembly 的平滑迁移。\n\n### 接入 Webpack 构建\n\n任何新的 Web 开发技术都少不了构建流程，为了提供一套流畅的 WebAssembly 开发流程，接下来介绍接入 Webpack 具体步骤。\n\n1. 安装以下依赖，以便让 TS 源码被 AssemblyScript 编译成 WebAssembly。\n\n   ```js\n   {\n     \"devDependencies\": {\n       \"assemblyscript\": \"github:AssemblyScript/assemblyscript\",\n       \"assemblyscript-typescript-loader\": \"^1.3.2\",\n       \"typescript\": \"^2.8.1\",\n       \"webpack\": \"^3.10.0\",\n       \"webpack-dev-server\": \"^2.10.1\"\n     }\n   }\n   ```\n\n   \n\n2. 修改 webpack.config.js，加入 loader：\n\n   ```\n   module.exports = {\n       module: {\n           rules: [\n               {\n                   test: /\\.ts$/,\n                   loader: 'assemblyscript-typescript-loader',\n                   options: {\n                       sourceMap: true,\n                   }\n               }\n           ]\n       },\n   };\n   ```\n\n   \n\n3. 修改 TypeScript 编译器配置 tsconfig.json，以便让 TypeScript 编译器能支持 AssemblyScript 中引入的内置类型和函数。\n\n   ```\n   {\n     \"extends\": \"../../node_modules/assemblyscript/std/portable.json\",\n     \"include\": [\n       \"./**/*.ts\"\n     ]\n   }\n   ```\n\n4. 配置直接继承自 assemblyscript 内置的配置文件。\n\n## WebAssembly 相关文件格式\n\n前面提到了 WebAssembly 的二进制文件格式 wasm，这种格式的文件人眼无法阅读，为了阅读 WebAssembly 文件的逻辑，还有一种文本格式叫 wast； 以前面讲到的计算斐波那契序列的模块为例，对应的 wast 文件如下：\n\n```\nfunc $src/asm/module/f (param f64) (result f64)\n(local i32)\n  get_local 0\n  f64.const 1\n  f64.eq\n  tee_local 1\n  if i32\n    get_local 1\n  else\n    get_local 0\n    f64.const 2\n    f64.eq\n  end\n  i32.const 1\n  i32.and\n  if\n    f64.const 1\n    return\n  end\n  get_local 0\n  f64.const 1\n  f64.sub\n  call 0\n  get_local 0\n  f64.const 2\n  f64.sub\n  call 0\n  f64.add\nend\n```\n\n这和汇编语言非常像，里面的 f64 是数据类型，f64.eq f64.sub f64.add 则是 CPU 指令。\n\n为了把二进制文件格式 wasm 转换成人眼可见的 wast 文本，需要安装 WebAssembly 二进制工具箱[WABT](https://github.com/WebAssembly/wabt)， 在 Mac 系统下可通过 brew install WABT 安装，安装成功后可以通过命令 wasm2wast f.wasm 获得 wast；除此之外还可以通过 wast2wasm f.wast -o f.wasm 逆向转换回去。\n\n## WebAssembly 相关工具\n\n除了前面提到的 WebAssembly 二进制工具箱，WebAssembly 社区还有以下常用工具：\n\n- [Emscripten](http://kripken.github.io/emscripten-site/): 能把 C、C++代码转换成 wasm、asm.js；\n- [Binaryen](https://github.com/WebAssembly/binaryen): 提供更简洁的 IR，把 IR 转换成 wasm，并且提供 wasm 的编译时优化、wasm 虚拟机，wasm 压缩等功能，前面提到的 AssemblyScript 就是基于它。\n\n## WebAssembly JS API\n\n目前 WebAssembly 只能通过 JS 去加载和执行，但未来在浏览器中可以通过像加载 JS 那样 <script src='f.wasm'></script> 去加载和执行 WebAssembly，下面来详细介绍如何用 JS 调 WebAssembly。\n\nJS 调 WebAssembly 分为 3 大步：**加载字节码 > 编译字节码 > 实例化**，获取到 WebAssembly 实例后就可以通过 JS 去调用了，以上 3 步具体的操作是：\n\n1. 对于浏览器可以通过网络请求去加载字节码，对于 Nodejs 可以通过 fs 模块读取字节码文件；\n2. 在获取到字节码后都需要转换成 ArrayBuffer 后才能被编译，通过 WebAssembly 通过的 JS API [WebAssembly.compile](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compile) 编译后会通过 Promise resolve 一个 [WebAssembly.Module](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module)，这个 module 是不能直接被调用的需要；\n3. 在获取到 module 后需要通过[ WebAssembly.Instance](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Instance) API 去实例化 module，获取到 Instance 后就可以像使用 JS 模块一个调用了。\n\n其中的第 2、3 步可以合并一步完成，前面提到的 [WebAssembly.instantiate](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate) 就做了这两个事情。\n\n```js\nWebAssembly.instantiate(bytes).then(mod=>{\n  mod.instance.f(50);\n})\n```\n\n### WebAssembly 调 JS\n\n之前的例子都是用 JS 去调用 WebAssembly 模块，但是在有些场景下可能需要在 WebAssembly 模块中调用浏览器 API，接下来介绍如何在 WebAssembly 中调用 JS。\n\nWebAssembly.instantiate 函数支持第二个参数 WebAssembly.instantiate(bytes,importObject)，这个 importObject 参数的作用就是 JS 向 WebAssembly 传入 WebAssembly 中需要调用 JS 的 JS 模块。举个具体的例子，改造前面的计算斐波那契序列在 WebAssembly 中调用 Web 中的 window.alert 函数把计算结果弹出来，为此需要改造加载 WebAssembly 模块的 JS 代码：\n\n```js\nWebAssembly.instantiate(bytes,{\n  window:{\n    alert:window.alert\n  }\n}).then(mod=>{\n  mod.instance.f(50);\n})\n```\n\n对应的还需要修改 AssemblyScript 编写的源码：\n\n```js\n// 声明从外部导入的模块类型\ndeclare namespace window {\n    export function alert(v: number): void;\n}\n \nfunction _f(x: number): number {\n    if (x == 1 || x == 2) {\n        return 1;\n    }\n    return _f(x - 1) + _f(x - 2)\n}\n \nexport function f(x: number): void {\n    // 直接调用 JS 模块\n    window.alert(_f(x));\n}\n```\n\n修改以上 AssemblyScript 源码后重新用 asc 通过命令 asc f.ts 编译后输出的 wast 文件比之前多了几行：\n\n```\n(import \"window\" \"alert\" (func $src/asm/module/window.alert (type 0)))\n \n(func $src/asm/module/f (type 0) (param f64)\n    get_local 0\n    call $src/asm/module/_f\n    call $src/asm/module/window.alert)\n```\n\n多出的这部分 wast 代码就是在 AssemblyScript 中调用 JS 中传入的模块的逻辑。\n\n除了以上常用的 API 外，WebAssembly 还提供一些 API，你可以通过这个[ d.ts 文件](https://github.com/01alchemist/webassembly-types/blob/master/webassembly.d.ts)去查看所有 WebAssembly JS API 的细节。\n\n## 不止于浏览器\n\nWebAssembly 作为一种底层字节码，除了能在浏览器中运行外，还能在其它环境运行。\n\n### 直接执行 wasm 二进制文件\n\n前面提到的 Binaryen 提供了在命令行中直接执行 wasm 二进制文件的工具，在 Mac 系统下通过 brew install binaryen 安装成功后，通过 wasm-shell f.wasm 文件即可直接运行。\n\n### 在 Node.js 中运行\n\n目前 V8 JS 引擎已经添加了对 WebAssembly 的支持，Chrome 和 Node.js 都采用了 V8 作为引擎，因此 WebAssembly 也可以运行在 Node.js 环境中；\n\nV8 JS 引擎在运行 WebAssembly 时，WebAssembly 和 JS 是在同一个虚拟机中执行，而不是 WebAssembly 在一个单独的虚拟机中运行，这样方便实现 JS 和 WebAssembly 之间的相互调用。\n\n要让上面的例子在 Node.js 中运行，可以使用以下代码：\n\n```js\nconst fs = require('fs');\n \nfunction toUint8Array(buf) {\n    var u = new Uint8Array(buf.length);\n    for (var i = 0; i < buf.length; ++i) {\n        u[i] = buf[i];\n    }\n    return u;\n}\n \nfunction loadWebAssembly(filename, imports) {\n    // 读取 wasm 文件，并转换成 byte 数组\n    const buffer = toUint8Array(fs.readFileSync(filename));\n    // 编译 wasm 字节码到机器码\n    return WebAssembly.compile(buffer)\n        .then(module => {\n            // 实例化模块\n            return new WebAssembly.Instance(module, imports)\n        })\n}\n \nloadWebAssembly('../temp/assembly/module.wasm')\n    .then(instance => {\n        // 调用 f 函数计算\n        console.log(instance.exports.f(10))\n    });\n```\n\n在 Nodejs 环境中运行 WebAssembly 的意义其实不大，原因在于 Nodejs 支持运行原生模块，而原生模块的性能比 WebAssembly 要好。 如果你是通过 C、Rust 去编写 WebAssembly，你可以直接编译成 Nodejs 可以调用的原生模块。\n\n## WebAssembly 展望\n\n从上面的内容可见 WebAssembly 主要是为了解决 JS 的性能瓶颈，也就是说 WebAssembly 适合用于需要大量计算的场景，例如：\n\n- 在浏览器中处理音视频，[flv.js](https://github.com/Bilibili/flv.js/) 用 WebAssembly 重写后性能会有很大提升；\n- React 的 dom diff 中涉及到大量计算，用 WebAssembly 重写 React 核心模块能提升性能。Safari 浏览器使用的 JS 引擎 JavaScriptCore 也已经支持 WebAssembly，RN 应用性能也能提升；\n- 突破大型 3D 网页游戏性能瓶颈，[白鹭引擎已经开始探索用 WebAssembly](https://feday.fequan.com/2017/WebAssembly%E5%9C%A8%E7%99%BD%E9%B9%AD%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%9E%E8%B7%B5.pdf)。\n\n## 总结\n\nWebAssembly 标准虽然已经定稿并且得到主流浏览器的实现，但目前还存在以下问题：\n\n- 浏览器兼容性不好，只有最新版本的浏览器支持，并且不同的浏览器对 JS WebAssembly 互调的 API 支持不一致；\n- 生态工具不完善不成熟，目前还不能找到一门体验流畅的编写 WebAssembly 的语言，都还处于起步阶段；\n- 学习资料太少，还需要更多的人去探索去踩坑。；\n\n总之现在的 WebAssembly 还不算成熟，如果你的团队没有不可容忍的性能问题，那现在使用 WebAssembly 到产品中还不是时候， 因为这可能会影响到团队的开发效率，或者遇到无法轻易解决的坑而阻塞开发。\n\n## 参考资源\n\n- [asm.js 和 Emscripten 入门教程](http://www.ruanyifeng.com/blog/2017/09/asmjs_emscripten.html)\n- [结构化编译器前端 Clang 介绍](https://www.ibm.com/developerworks/cn/opensource/os-cn-clang/index.html)\n- [理解 WebAssembly 文本格式](https://developer.mozilla.org/zh-CN/docs/WebAssembly/Understanding_the_text_format)\n- [使用 WebAssembly JavaScript API](https://developer.mozilla.org/zh-CN/docs/WebAssembly/Using_the_JavaScript_API)\n\n\n> 本文首发于[IBM Dev社区](https://www.ibm.com/developerworks/cn/web/wa-lo-webassembly-status-and-reality/index.html)\n","slug":"WebAssembly 现状与实战","published":1,"updated":"2018-11-14T04:39:28.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjogs0ke40005g5tcdbypald1","content":"<h2 id=\"为什么需要-WebAssembly\"><a href=\"#为什么需要-WebAssembly\" class=\"headerlink\" title=\"为什么需要 WebAssembly\"></a>为什么需要 WebAssembly</h2><p>自从 JavaScript 诞生起到现在已经变成最流行的编程语言，这背后正是 Web 的发展所推动的。Web 应用变得更多更复杂，但这也渐渐暴露出了 JavaScript 的问题：</p>\n<ul>\n<li>语法太灵活导致开发大型 Web 项目困难；</li>\n<li>性能不能满足一些场景的需要。</li>\n</ul>\n<p>针对以上两点缺陷，近年来出现了一些 JS 的代替语言，例如：</p>\n<ul>\n<li>微软的<a href=\"http://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener\"> TypeScript </a>通过为 JS 加入静态类型检查来改进 JS 松散的语法，提升代码健壮性；</li>\n<li>谷歌的<a href=\"https://www.dartlang.org/\" target=\"_blank\" rel=\"noopener\"> Dart </a>则是为浏览器引入新的虚拟机去直接运行 Dart 程序以提升性能；</li>\n<li>火狐的<a href=\"http://asmjs.org/\" target=\"_blank\" rel=\"noopener\"> asm.js </a>则是取 JS 的子集，JS 引擎针对 asm.js 做性能优化。</li>\n</ul>\n<p>以上尝试各有优缺点，其中：</p>\n<ul>\n<li>TypeScript 只是解决了 JS 语法松散的问题，最后还是需要编译成 JS 去运行，对性能没有提升；</li>\n<li>Dart 只能在 Chrome 预览版中运行，无主流浏览器支持，用 Dart 开发的人不多；</li>\n<li>asm.js 语法太简单、有很大限制，开发效率低。</li>\n</ul>\n<p>三大浏览器巨头分别提出了自己的解决方案，互不兼容，这违背了 Web 的宗旨； 是技术的规范统一让 Web 走到了今天，因此形成一套新的规范去解决 JS 所面临的问题迫在眉睫。</p>\n<p>于是 WebAssembly 诞生了，WebAssembly 是一种新的字节码格式，主流浏览器都已经支持 WebAssembly。 和 JS 需要解释执行不同的是，WebAssembly 字节码和底层机器码很相似可快速装载运行，因此性能相对于 JS 解释执行大大提升。 也就是说 WebAssembly 并不是一门编程语言，而是一份字节码标准，需要用高级编程语言编译出字节码放到 WebAssembly 虚拟机中才能运行， 浏览器厂商需要做的就是根据 WebAssembly 规范实现虚拟机。</p>\n<h2 id=\"WebAssembly-原理\"><a href=\"#WebAssembly-原理\" class=\"headerlink\" title=\"WebAssembly 原理\"></a>WebAssembly 原理</h2><p>要搞懂 WebAssembly 的原理，需要先搞懂计算机的运行原理。 电子计算机都是由电子元件组成，为了方便处理电子元件只存在开闭两种状态，对应着 0 和 1，也就是说计算机只认识 0 和 1，数据和逻辑都需要由 0 和 1 表示，也就是可以直接装载到计算机中运行的机器码。 机器码可读性极差，因此人们通过高级语言 C、C++、Rust、Go 等编写再编译成机器码。</p>\n<p>由于不同的计算机 CPU 架构不同，机器码标准也有所差别，常见的 CPU 架构包括 x86、AMD64、ARM， 因此在由高级编程语言编译成可自行代码时需要指定目标架构。</p>\n<p>WebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行， 但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。</p>\n<p>相对于 JS，WebAssembly 有如下优点：</p>\n<ul>\n<li>体积小：由于浏览器运行时只加载编译成的字节码，一样的逻辑比用字符串描述的 JS 文件体积要小很多；</li>\n<li>加载快：由于文件体积小，再加上无需解释执行，WebAssembly 能更快的加载并实例化，减少运行前的等待时间；</li>\n<li>兼容性问题少：WebAssembly 是非常底层的字节码规范，制订好后很少变动，就算以后发生变化,也只需在从高级语言编译成字节码过程中做兼容。可能出现兼容性问题的地方在于 JS 和 WebAssembly 桥接的 JS 接口。</li>\n</ul>\n<p>每个高级语言都去实现源码到不同平台的机器码的转换工作是重复的，高级语言只需要生成底层虚拟机(LLVM)认识的中间语言(LLVM IR)，<a href=\"https://llvm.org/\" target=\"_blank\" rel=\"noopener\">LLVM </a>能实现：</p>\n<ul>\n<li>LLVM IR 到不同 CPU 架构机器码的生成；</li>\n<li>机器码编译时性能和大小优化。</li>\n</ul>\n<p>除此之外 LLVM 还实现了 LLVM IR 到 WebAssembly 字节码的编译功能，也就是说只要高级语言能转换成 LLVM IR，就能被编译成 WebAssembly 字节码，目前能编译成 WebAssembly 字节码的高级语言有：</p>\n<ul>\n<li><a href=\"https://github.com/AssemblyScript/assemblyscript\" target=\"_blank\" rel=\"noopener\">AssemblyScript</a>:语法和 TypeScript 一致，对前端来说学习成本低，为前端编写 WebAssembly 最佳选择；</li>\n<li>c\\c++:官方推荐的方式，详细使用见<a href=\"http://webassembly.org.cn/getting-started/developers-guide/\" target=\"_blank\" rel=\"noopener\">文档</a>;</li>\n<li><a href=\"https://www.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust</a>:语法复杂、学习成本高，对前端来说可能会不适应。详细使用见<a href=\"https://github.com/rust-lang-nursery/rust-wasm\" target=\"_blank\" rel=\"noopener\">文档</a>;</li>\n<li><a href=\"http://kotlinlang.org/\" target=\"_blank\" rel=\"noopener\">Kotlin</a>:语法和 Java、JS 相似，语言学习成本低，详细使用见<a href=\"https://kotlinlang.org/docs/reference/native-overview.html\" target=\"_blank\" rel=\"noopener\">文档</a>;</li>\n<li><a href=\"https://golang.org/\" target=\"_blank\" rel=\"noopener\">Golang</a>:语法简单学习成本低。但对 WebAssembly 的支持还处于未正式发布阶段，详细使用见<a href=\"https://blog.gopheracademy.com/advent-2017/go-wasm/\" target=\"_blank\" rel=\"noopener\">文档</a>。</li>\n</ul>\n<p>通常负责把高级语言翻译到 LLVM IR 的部分叫做编译器前端，把 LLVM IR 编译成各架构 CPU 对应机器码的部分叫做编译器后端； 现在越来越多的高级编程语言选择 LLVM 作为后端，高级语言只需专注于如何提供开发效率更高的语法同时保持翻译到 LLVM IR 的程序执行性能。</p>\n<h2 id=\"编写-WebAssembly\"><a href=\"#编写-WebAssembly\" class=\"headerlink\" title=\"编写 WebAssembly\"></a>编写 WebAssembly</h2><h3 id=\"AssemblyScript-初体验\"><a href=\"#AssemblyScript-初体验\" class=\"headerlink\" title=\"AssemblyScript 初体验\"></a>AssemblyScript 初体验</h3><p>接下来详细介绍如何使用 AssemblyScript 来编写 WebAssembly，实现斐波那契序列的计算。 用 TypeScript 实现斐波那契序列计算的模块 f.ts 如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x: i32</span>): <span class=\"title\">i32</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x === <span class=\"number\">1</span> || x === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(x - <span class=\"number\">1</span>) + f(x - <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在按照 <a href=\"https://github.com/AssemblyScript/assemblyscript#installation\" target=\"_blank\" rel=\"noopener\">AssemblyScript 提供的安装教程</a>成功安装后， 再通过</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asc f.ts -o f.wasm</span><br></pre></td></tr></table></figure>\n<p>就能把以上代码编译成可运行的 WebAssembly 模块。</p>\n<p>为了加载并执行编译出的 f.wasm 模块，需要通过 JS 去加载并调用模块上的 f 函数，为此需要以下 JS 代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'f.wasm'</span>) <span class=\"comment\">// 网络加载 f.wasm 文件</span></span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.arrayBuffer()) <span class=\"comment\">// 转成 ArrayBuffer</span></span><br><span class=\"line\">    .then(WebAssembly.instantiate) <span class=\"comment\">// 编译为当前 CPU 架构的机器码 + 实例化</span></span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">mod</span> =&gt;</span> &#123; <span class=\"comment\">// 调用模块实例上的 f 函数计算</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(mod.instance.f(<span class=\"number\">50</span>));</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>以上代码中出现了一个新的内置类型 i32，这是 AssemblyScript 在 TypeScript 的基础上内置的类型。 AssemblyScript 和 TypeScript 有细微区别，AssemblyScript 是 TypeScript 的子集，为了方便编译成 WebAssembly 在 TypeScript 的基础上加了更严格的<a href=\"https://github.com/AssemblyScript/assemblyscript/wiki/Limitations\" target=\"_blank\" rel=\"noopener\">类型限制</a>， 区别如下：</p>\n<ul>\n<li>比 TypeScript 多了很多更细致的内置类型，以优化性能和内存占用，详情<a href=\"https://github.com/AssemblyScript/assemblyscript/wiki/Types\" target=\"_blank\" rel=\"noopener\">文档</a>;</li>\n<li>不能使用 any 和 undefined 类型，以及枚举类型；</li>\n<li>可空类型的变量必须是引用类型，而不能是基本数据类型如 string、number、boolean；</li>\n<li>函数中的可选参数必须提供默认值，函数必须有返回类型，无返回值的函数返回类型需要是 void；</li>\n<li>不能使用 JS 环境中的内置函数，只能使用 <a href=\"https://github.com/AssemblyScript/assemblyscript/wiki/Built-in-functions\" target=\"_blank\" rel=\"noopener\">AssemblyScript 提供的内置函数</a>。</li>\n</ul>\n<p>总体来说 AssemblyScript 比 TypeScript 又多了很多限制，编写起来会觉得局限性很大； 用 AssemblyScript 来写 WebAssembly 经常会出现 tsc 编译通过但运行 WebAssembly 时出错的情况，这很可能就是你没有遵守以上限制导致的；但 AssemblyScript 通过修改 TypeScript 编译器默认配置能在编译阶段找出大多错误。</p>\n<p>AssemblyScript 的实现原理其实也借助了 LLVM，它通过 TypeScript 编译器把 TS 源码解析成 AST，再把 AST 翻译成 IR，再通过 LLVM 编译成 WebAssembly 字节码实现； 上面提到的各种限制都是为了方便把 AST 转换成 LLVM IR。</p>\n<h3 id=\"为什么选-AssemblyScript-作为-WebAssembly-开发语言\"><a href=\"#为什么选-AssemblyScript-作为-WebAssembly-开发语言\" class=\"headerlink\" title=\"为什么选 AssemblyScript 作为 WebAssembly 开发语言\"></a>为什么选 AssemblyScript 作为 WebAssembly 开发语言</h3><p>AssemblyScript 相对于 C、Rust 等其它语言去写 WebAssembly 而言，好处除了对前端来说无额外新语言学习成本外，还有对于不支持 WebAssembly 的浏览器，可以通过 TypeScript 编译器编译成可正常执行的 JS 代码，从而实现从 JS 到 WebAssembly 的平滑迁移。</p>\n<h3 id=\"接入-Webpack-构建\"><a href=\"#接入-Webpack-构建\" class=\"headerlink\" title=\"接入 Webpack 构建\"></a>接入 Webpack 构建</h3><p>任何新的 Web 开发技术都少不了构建流程，为了提供一套流畅的 WebAssembly 开发流程，接下来介绍接入 Webpack 具体步骤。</p>\n<ol>\n<li><p>安装以下依赖，以便让 TS 源码被 AssemblyScript 编译成 WebAssembly。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"assemblyscript\"</span>: <span class=\"string\">\"github:AssemblyScript/assemblyscript\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"assemblyscript-typescript-loader\"</span>: <span class=\"string\">\"^1.3.2\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"typescript\"</span>: <span class=\"string\">\"^2.8.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack\"</span>: <span class=\"string\">\"^3.10.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack-dev-server\"</span>: <span class=\"string\">\"^2.10.1\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>修改 webpack.config.js，加入 loader：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.ts$/,</span><br><span class=\"line\">                loader: &apos;assemblyscript-typescript-loader&apos;,</span><br><span class=\"line\">                options: &#123;</span><br><span class=\"line\">                    sourceMap: true,</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>修改 TypeScript 编译器配置 tsconfig.json，以便让 TypeScript 编译器能支持 AssemblyScript 中引入的内置类型和函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;extends&quot;: &quot;../../node_modules/assemblyscript/std/portable.json&quot;,</span><br><span class=\"line\">  &quot;include&quot;: [</span><br><span class=\"line\">    &quot;./**/*.ts&quot;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置直接继承自 assemblyscript 内置的配置文件。</p>\n</li>\n</ol>\n<h2 id=\"WebAssembly-相关文件格式\"><a href=\"#WebAssembly-相关文件格式\" class=\"headerlink\" title=\"WebAssembly 相关文件格式\"></a>WebAssembly 相关文件格式</h2><p>前面提到了 WebAssembly 的二进制文件格式 wasm，这种格式的文件人眼无法阅读，为了阅读 WebAssembly 文件的逻辑，还有一种文本格式叫 wast； 以前面讲到的计算斐波那契序列的模块为例，对应的 wast 文件如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func $src/asm/module/f (param f64) (result f64)</span><br><span class=\"line\">(local i32)</span><br><span class=\"line\">  get_local 0</span><br><span class=\"line\">  f64.const 1</span><br><span class=\"line\">  f64.eq</span><br><span class=\"line\">  tee_local 1</span><br><span class=\"line\">  if i32</span><br><span class=\"line\">    get_local 1</span><br><span class=\"line\">  else</span><br><span class=\"line\">    get_local 0</span><br><span class=\"line\">    f64.const 2</span><br><span class=\"line\">    f64.eq</span><br><span class=\"line\">  end</span><br><span class=\"line\">  i32.const 1</span><br><span class=\"line\">  i32.and</span><br><span class=\"line\">  if</span><br><span class=\"line\">    f64.const 1</span><br><span class=\"line\">    return</span><br><span class=\"line\">  end</span><br><span class=\"line\">  get_local 0</span><br><span class=\"line\">  f64.const 1</span><br><span class=\"line\">  f64.sub</span><br><span class=\"line\">  call 0</span><br><span class=\"line\">  get_local 0</span><br><span class=\"line\">  f64.const 2</span><br><span class=\"line\">  f64.sub</span><br><span class=\"line\">  call 0</span><br><span class=\"line\">  f64.add</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>这和汇编语言非常像，里面的 f64 是数据类型，f64.eq f64.sub f64.add 则是 CPU 指令。</p>\n<p>为了把二进制文件格式 wasm 转换成人眼可见的 wast 文本，需要安装 WebAssembly 二进制工具箱<a href=\"https://github.com/WebAssembly/wabt\" target=\"_blank\" rel=\"noopener\">WABT</a>， 在 Mac 系统下可通过 brew install WABT 安装，安装成功后可以通过命令 wasm2wast f.wasm 获得 wast；除此之外还可以通过 wast2wasm f.wast -o f.wasm 逆向转换回去。</p>\n<h2 id=\"WebAssembly-相关工具\"><a href=\"#WebAssembly-相关工具\" class=\"headerlink\" title=\"WebAssembly 相关工具\"></a>WebAssembly 相关工具</h2><p>除了前面提到的 WebAssembly 二进制工具箱，WebAssembly 社区还有以下常用工具：</p>\n<ul>\n<li><a href=\"http://kripken.github.io/emscripten-site/\" target=\"_blank\" rel=\"noopener\">Emscripten</a>: 能把 C、C++代码转换成 wasm、asm.js；</li>\n<li><a href=\"https://github.com/WebAssembly/binaryen\" target=\"_blank\" rel=\"noopener\">Binaryen</a>: 提供更简洁的 IR，把 IR 转换成 wasm，并且提供 wasm 的编译时优化、wasm 虚拟机，wasm 压缩等功能，前面提到的 AssemblyScript 就是基于它。</li>\n</ul>\n<h2 id=\"WebAssembly-JS-API\"><a href=\"#WebAssembly-JS-API\" class=\"headerlink\" title=\"WebAssembly JS API\"></a>WebAssembly JS API</h2><p>目前 WebAssembly 只能通过 JS 去加载和执行，但未来在浏览器中可以通过像加载 JS 那样 <script src=\"f.wasm\"></script> 去加载和执行 WebAssembly，下面来详细介绍如何用 JS 调 WebAssembly。</p>\n<p>JS 调 WebAssembly 分为 3 大步：<strong>加载字节码 &gt; 编译字节码 &gt; 实例化</strong>，获取到 WebAssembly 实例后就可以通过 JS 去调用了，以上 3 步具体的操作是：</p>\n<ol>\n<li>对于浏览器可以通过网络请求去加载字节码，对于 Nodejs 可以通过 fs 模块读取字节码文件；</li>\n<li>在获取到字节码后都需要转换成 ArrayBuffer 后才能被编译，通过 WebAssembly 通过的 JS API <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compile\" target=\"_blank\" rel=\"noopener\">WebAssembly.compile</a> 编译后会通过 Promise resolve 一个 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module\" target=\"_blank\" rel=\"noopener\">WebAssembly.Module</a>，这个 module 是不能直接被调用的需要；</li>\n<li>在获取到 module 后需要通过<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Instance\" target=\"_blank\" rel=\"noopener\"> WebAssembly.Instance</a> API 去实例化 module，获取到 Instance 后就可以像使用 JS 模块一个调用了。</li>\n</ol>\n<p>其中的第 2、3 步可以合并一步完成，前面提到的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate\" target=\"_blank\" rel=\"noopener\">WebAssembly.instantiate</a> 就做了这两个事情。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebAssembly.instantiate(bytes).then(<span class=\"function\"><span class=\"params\">mod</span>=&gt;</span>&#123;</span><br><span class=\"line\">  mod.instance.f(<span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"WebAssembly-调-JS\"><a href=\"#WebAssembly-调-JS\" class=\"headerlink\" title=\"WebAssembly 调 JS\"></a>WebAssembly 调 JS</h3><p>之前的例子都是用 JS 去调用 WebAssembly 模块，但是在有些场景下可能需要在 WebAssembly 模块中调用浏览器 API，接下来介绍如何在 WebAssembly 中调用 JS。</p>\n<p>WebAssembly.instantiate 函数支持第二个参数 WebAssembly.instantiate(bytes,importObject)，这个 importObject 参数的作用就是 JS 向 WebAssembly 传入 WebAssembly 中需要调用 JS 的 JS 模块。举个具体的例子，改造前面的计算斐波那契序列在 WebAssembly 中调用 Web 中的 window.alert 函数把计算结果弹出来，为此需要改造加载 WebAssembly 模块的 JS 代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebAssembly.instantiate(bytes,&#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>:&#123;</span><br><span class=\"line\">    alert:<span class=\"built_in\">window</span>.alert</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">mod</span>=&gt;</span>&#123;</span><br><span class=\"line\">  mod.instance.f(<span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>对应的还需要修改 AssemblyScript 编写的源码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明从外部导入的模块类型</span></span><br><span class=\"line\">declare namespace <span class=\"built_in\">window</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">alert</span>(<span class=\"params\">v: number</span>): <span class=\"title\">void</span>;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\"><span class=\"function\"> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">_f</span>(<span class=\"params\">x: number</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == <span class=\"number\">1</span> || x == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _f(x - <span class=\"number\">1</span>) + _f(x - <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x: number</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 直接调用 JS 模块</span></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.alert(_f(x));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改以上 AssemblyScript 源码后重新用 asc 通过命令 asc f.ts 编译后输出的 wast 文件比之前多了几行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(import &quot;window&quot; &quot;alert&quot; (func $src/asm/module/window.alert (type 0)))</span><br><span class=\"line\"> </span><br><span class=\"line\">(func $src/asm/module/f (type 0) (param f64)</span><br><span class=\"line\">    get_local 0</span><br><span class=\"line\">    call $src/asm/module/_f</span><br><span class=\"line\">    call $src/asm/module/window.alert)</span><br></pre></td></tr></table></figure>\n<p>多出的这部分 wast 代码就是在 AssemblyScript 中调用 JS 中传入的模块的逻辑。</p>\n<p>除了以上常用的 API 外，WebAssembly 还提供一些 API，你可以通过这个<a href=\"https://github.com/01alchemist/webassembly-types/blob/master/webassembly.d.ts\" target=\"_blank\" rel=\"noopener\"> d.ts 文件</a>去查看所有 WebAssembly JS API 的细节。</p>\n<h2 id=\"不止于浏览器\"><a href=\"#不止于浏览器\" class=\"headerlink\" title=\"不止于浏览器\"></a>不止于浏览器</h2><p>WebAssembly 作为一种底层字节码，除了能在浏览器中运行外，还能在其它环境运行。</p>\n<h3 id=\"直接执行-wasm-二进制文件\"><a href=\"#直接执行-wasm-二进制文件\" class=\"headerlink\" title=\"直接执行 wasm 二进制文件\"></a>直接执行 wasm 二进制文件</h3><p>前面提到的 Binaryen 提供了在命令行中直接执行 wasm 二进制文件的工具，在 Mac 系统下通过 brew install binaryen 安装成功后，通过 wasm-shell f.wasm 文件即可直接运行。</p>\n<h3 id=\"在-Node-js-中运行\"><a href=\"#在-Node-js-中运行\" class=\"headerlink\" title=\"在 Node.js 中运行\"></a>在 Node.js 中运行</h3><p>目前 V8 JS 引擎已经添加了对 WebAssembly 的支持，Chrome 和 Node.js 都采用了 V8 作为引擎，因此 WebAssembly 也可以运行在 Node.js 环境中；</p>\n<p>V8 JS 引擎在运行 WebAssembly 时，WebAssembly 和 JS 是在同一个虚拟机中执行，而不是 WebAssembly 在一个单独的虚拟机中运行，这样方便实现 JS 和 WebAssembly 之间的相互调用。</p>\n<p>要让上面的例子在 Node.js 中运行，可以使用以下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toUint8Array</span>(<span class=\"params\">buf</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> u = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(buf.length);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; buf.length; ++i) &#123;</span><br><span class=\"line\">        u[i] = buf[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> u;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadWebAssembly</span>(<span class=\"params\">filename, imports</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 读取 wasm 文件，并转换成 byte 数组</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> buffer = toUint8Array(fs.readFileSync(filename));</span><br><span class=\"line\">    <span class=\"comment\">// 编译 wasm 字节码到机器码</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> WebAssembly.compile(buffer)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 实例化模块</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WebAssembly.Instance(<span class=\"built_in\">module</span>, imports)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">loadWebAssembly(<span class=\"string\">'../temp/assembly/module.wasm'</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">instance</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 f 函数计算</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(instance.exports.f(<span class=\"number\">10</span>))</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>在 Nodejs 环境中运行 WebAssembly 的意义其实不大，原因在于 Nodejs 支持运行原生模块，而原生模块的性能比 WebAssembly 要好。 如果你是通过 C、Rust 去编写 WebAssembly，你可以直接编译成 Nodejs 可以调用的原生模块。</p>\n<h2 id=\"WebAssembly-展望\"><a href=\"#WebAssembly-展望\" class=\"headerlink\" title=\"WebAssembly 展望\"></a>WebAssembly 展望</h2><p>从上面的内容可见 WebAssembly 主要是为了解决 JS 的性能瓶颈，也就是说 WebAssembly 适合用于需要大量计算的场景，例如：</p>\n<ul>\n<li>在浏览器中处理音视频，<a href=\"https://github.com/Bilibili/flv.js/\" target=\"_blank\" rel=\"noopener\">flv.js</a> 用 WebAssembly 重写后性能会有很大提升；</li>\n<li>React 的 dom diff 中涉及到大量计算，用 WebAssembly 重写 React 核心模块能提升性能。Safari 浏览器使用的 JS 引擎 JavaScriptCore 也已经支持 WebAssembly，RN 应用性能也能提升；</li>\n<li>突破大型 3D 网页游戏性能瓶颈，<a href=\"https://feday.fequan.com/2017/WebAssembly%E5%9C%A8%E7%99%BD%E9%B9%AD%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%9E%E8%B7%B5.pdf\" target=\"_blank\" rel=\"noopener\">白鹭引擎已经开始探索用 WebAssembly</a>。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>WebAssembly 标准虽然已经定稿并且得到主流浏览器的实现，但目前还存在以下问题：</p>\n<ul>\n<li>浏览器兼容性不好，只有最新版本的浏览器支持，并且不同的浏览器对 JS WebAssembly 互调的 API 支持不一致；</li>\n<li>生态工具不完善不成熟，目前还不能找到一门体验流畅的编写 WebAssembly 的语言，都还处于起步阶段；</li>\n<li>学习资料太少，还需要更多的人去探索去踩坑。；</li>\n</ul>\n<p>总之现在的 WebAssembly 还不算成熟，如果你的团队没有不可容忍的性能问题，那现在使用 WebAssembly 到产品中还不是时候， 因为这可能会影响到团队的开发效率，或者遇到无法轻易解决的坑而阻塞开发。</p>\n<h2 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/09/asmjs_emscripten.html\" target=\"_blank\" rel=\"noopener\">asm.js 和 Emscripten 入门教程</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-clang/index.html\" target=\"_blank\" rel=\"noopener\">结构化编译器前端 Clang 介绍</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/WebAssembly/Understanding_the_text_format\" target=\"_blank\" rel=\"noopener\">理解 WebAssembly 文本格式</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/WebAssembly/Using_the_JavaScript_API\" target=\"_blank\" rel=\"noopener\">使用 WebAssembly JavaScript API</a></li>\n</ul>\n<blockquote>\n<p>本文首发于<a href=\"https://www.ibm.com/developerworks/cn/web/wa-lo-webassembly-status-and-reality/index.html\" target=\"_blank\" rel=\"noopener\">IBM Dev社区</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为什么需要-WebAssembly\"><a href=\"#为什么需要-WebAssembly\" class=\"headerlink\" title=\"为什么需要 WebAssembly\"></a>为什么需要 WebAssembly</h2><p>自从 JavaScript 诞生起到现在已经变成最流行的编程语言，这背后正是 Web 的发展所推动的。Web 应用变得更多更复杂，但这也渐渐暴露出了 JavaScript 的问题：</p>\n<ul>\n<li>语法太灵活导致开发大型 Web 项目困难；</li>\n<li>性能不能满足一些场景的需要。</li>\n</ul>\n<p>针对以上两点缺陷，近年来出现了一些 JS 的代替语言，例如：</p>\n<ul>\n<li>微软的<a href=\"http://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener\"> TypeScript </a>通过为 JS 加入静态类型检查来改进 JS 松散的语法，提升代码健壮性；</li>\n<li>谷歌的<a href=\"https://www.dartlang.org/\" target=\"_blank\" rel=\"noopener\"> Dart </a>则是为浏览器引入新的虚拟机去直接运行 Dart 程序以提升性能；</li>\n<li>火狐的<a href=\"http://asmjs.org/\" target=\"_blank\" rel=\"noopener\"> asm.js </a>则是取 JS 的子集，JS 引擎针对 asm.js 做性能优化。</li>\n</ul>\n<p>以上尝试各有优缺点，其中：</p>\n<ul>\n<li>TypeScript 只是解决了 JS 语法松散的问题，最后还是需要编译成 JS 去运行，对性能没有提升；</li>\n<li>Dart 只能在 Chrome 预览版中运行，无主流浏览器支持，用 Dart 开发的人不多；</li>\n<li>asm.js 语法太简单、有很大限制，开发效率低。</li>\n</ul>\n<p>三大浏览器巨头分别提出了自己的解决方案，互不兼容，这违背了 Web 的宗旨； 是技术的规范统一让 Web 走到了今天，因此形成一套新的规范去解决 JS 所面临的问题迫在眉睫。</p>\n<p>于是 WebAssembly 诞生了，WebAssembly 是一种新的字节码格式，主流浏览器都已经支持 WebAssembly。 和 JS 需要解释执行不同的是，WebAssembly 字节码和底层机器码很相似可快速装载运行，因此性能相对于 JS 解释执行大大提升。 也就是说 WebAssembly 并不是一门编程语言，而是一份字节码标准，需要用高级编程语言编译出字节码放到 WebAssembly 虚拟机中才能运行， 浏览器厂商需要做的就是根据 WebAssembly 规范实现虚拟机。</p>\n<h2 id=\"WebAssembly-原理\"><a href=\"#WebAssembly-原理\" class=\"headerlink\" title=\"WebAssembly 原理\"></a>WebAssembly 原理</h2><p>要搞懂 WebAssembly 的原理，需要先搞懂计算机的运行原理。 电子计算机都是由电子元件组成，为了方便处理电子元件只存在开闭两种状态，对应着 0 和 1，也就是说计算机只认识 0 和 1，数据和逻辑都需要由 0 和 1 表示，也就是可以直接装载到计算机中运行的机器码。 机器码可读性极差，因此人们通过高级语言 C、C++、Rust、Go 等编写再编译成机器码。</p>\n<p>由于不同的计算机 CPU 架构不同，机器码标准也有所差别，常见的 CPU 架构包括 x86、AMD64、ARM， 因此在由高级编程语言编译成可自行代码时需要指定目标架构。</p>\n<p>WebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行， 但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。</p>\n<p>相对于 JS，WebAssembly 有如下优点：</p>\n<ul>\n<li>体积小：由于浏览器运行时只加载编译成的字节码，一样的逻辑比用字符串描述的 JS 文件体积要小很多；</li>\n<li>加载快：由于文件体积小，再加上无需解释执行，WebAssembly 能更快的加载并实例化，减少运行前的等待时间；</li>\n<li>兼容性问题少：WebAssembly 是非常底层的字节码规范，制订好后很少变动，就算以后发生变化,也只需在从高级语言编译成字节码过程中做兼容。可能出现兼容性问题的地方在于 JS 和 WebAssembly 桥接的 JS 接口。</li>\n</ul>\n<p>每个高级语言都去实现源码到不同平台的机器码的转换工作是重复的，高级语言只需要生成底层虚拟机(LLVM)认识的中间语言(LLVM IR)，<a href=\"https://llvm.org/\" target=\"_blank\" rel=\"noopener\">LLVM </a>能实现：</p>\n<ul>\n<li>LLVM IR 到不同 CPU 架构机器码的生成；</li>\n<li>机器码编译时性能和大小优化。</li>\n</ul>\n<p>除此之外 LLVM 还实现了 LLVM IR 到 WebAssembly 字节码的编译功能，也就是说只要高级语言能转换成 LLVM IR，就能被编译成 WebAssembly 字节码，目前能编译成 WebAssembly 字节码的高级语言有：</p>\n<ul>\n<li><a href=\"https://github.com/AssemblyScript/assemblyscript\" target=\"_blank\" rel=\"noopener\">AssemblyScript</a>:语法和 TypeScript 一致，对前端来说学习成本低，为前端编写 WebAssembly 最佳选择；</li>\n<li>c\\c++:官方推荐的方式，详细使用见<a href=\"http://webassembly.org.cn/getting-started/developers-guide/\" target=\"_blank\" rel=\"noopener\">文档</a>;</li>\n<li><a href=\"https://www.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust</a>:语法复杂、学习成本高，对前端来说可能会不适应。详细使用见<a href=\"https://github.com/rust-lang-nursery/rust-wasm\" target=\"_blank\" rel=\"noopener\">文档</a>;</li>\n<li><a href=\"http://kotlinlang.org/\" target=\"_blank\" rel=\"noopener\">Kotlin</a>:语法和 Java、JS 相似，语言学习成本低，详细使用见<a href=\"https://kotlinlang.org/docs/reference/native-overview.html\" target=\"_blank\" rel=\"noopener\">文档</a>;</li>\n<li><a href=\"https://golang.org/\" target=\"_blank\" rel=\"noopener\">Golang</a>:语法简单学习成本低。但对 WebAssembly 的支持还处于未正式发布阶段，详细使用见<a href=\"https://blog.gopheracademy.com/advent-2017/go-wasm/\" target=\"_blank\" rel=\"noopener\">文档</a>。</li>\n</ul>\n<p>通常负责把高级语言翻译到 LLVM IR 的部分叫做编译器前端，把 LLVM IR 编译成各架构 CPU 对应机器码的部分叫做编译器后端； 现在越来越多的高级编程语言选择 LLVM 作为后端，高级语言只需专注于如何提供开发效率更高的语法同时保持翻译到 LLVM IR 的程序执行性能。</p>\n<h2 id=\"编写-WebAssembly\"><a href=\"#编写-WebAssembly\" class=\"headerlink\" title=\"编写 WebAssembly\"></a>编写 WebAssembly</h2><h3 id=\"AssemblyScript-初体验\"><a href=\"#AssemblyScript-初体验\" class=\"headerlink\" title=\"AssemblyScript 初体验\"></a>AssemblyScript 初体验</h3><p>接下来详细介绍如何使用 AssemblyScript 来编写 WebAssembly，实现斐波那契序列的计算。 用 TypeScript 实现斐波那契序列计算的模块 f.ts 如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x: i32</span>): <span class=\"title\">i32</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x === <span class=\"number\">1</span> || x === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(x - <span class=\"number\">1</span>) + f(x - <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在按照 <a href=\"https://github.com/AssemblyScript/assemblyscript#installation\" target=\"_blank\" rel=\"noopener\">AssemblyScript 提供的安装教程</a>成功安装后， 再通过</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asc f.ts -o f.wasm</span><br></pre></td></tr></table></figure>\n<p>就能把以上代码编译成可运行的 WebAssembly 模块。</p>\n<p>为了加载并执行编译出的 f.wasm 模块，需要通过 JS 去加载并调用模块上的 f 函数，为此需要以下 JS 代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'f.wasm'</span>) <span class=\"comment\">// 网络加载 f.wasm 文件</span></span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.arrayBuffer()) <span class=\"comment\">// 转成 ArrayBuffer</span></span><br><span class=\"line\">    .then(WebAssembly.instantiate) <span class=\"comment\">// 编译为当前 CPU 架构的机器码 + 实例化</span></span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">mod</span> =&gt;</span> &#123; <span class=\"comment\">// 调用模块实例上的 f 函数计算</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(mod.instance.f(<span class=\"number\">50</span>));</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>以上代码中出现了一个新的内置类型 i32，这是 AssemblyScript 在 TypeScript 的基础上内置的类型。 AssemblyScript 和 TypeScript 有细微区别，AssemblyScript 是 TypeScript 的子集，为了方便编译成 WebAssembly 在 TypeScript 的基础上加了更严格的<a href=\"https://github.com/AssemblyScript/assemblyscript/wiki/Limitations\" target=\"_blank\" rel=\"noopener\">类型限制</a>， 区别如下：</p>\n<ul>\n<li>比 TypeScript 多了很多更细致的内置类型，以优化性能和内存占用，详情<a href=\"https://github.com/AssemblyScript/assemblyscript/wiki/Types\" target=\"_blank\" rel=\"noopener\">文档</a>;</li>\n<li>不能使用 any 和 undefined 类型，以及枚举类型；</li>\n<li>可空类型的变量必须是引用类型，而不能是基本数据类型如 string、number、boolean；</li>\n<li>函数中的可选参数必须提供默认值，函数必须有返回类型，无返回值的函数返回类型需要是 void；</li>\n<li>不能使用 JS 环境中的内置函数，只能使用 <a href=\"https://github.com/AssemblyScript/assemblyscript/wiki/Built-in-functions\" target=\"_blank\" rel=\"noopener\">AssemblyScript 提供的内置函数</a>。</li>\n</ul>\n<p>总体来说 AssemblyScript 比 TypeScript 又多了很多限制，编写起来会觉得局限性很大； 用 AssemblyScript 来写 WebAssembly 经常会出现 tsc 编译通过但运行 WebAssembly 时出错的情况，这很可能就是你没有遵守以上限制导致的；但 AssemblyScript 通过修改 TypeScript 编译器默认配置能在编译阶段找出大多错误。</p>\n<p>AssemblyScript 的实现原理其实也借助了 LLVM，它通过 TypeScript 编译器把 TS 源码解析成 AST，再把 AST 翻译成 IR，再通过 LLVM 编译成 WebAssembly 字节码实现； 上面提到的各种限制都是为了方便把 AST 转换成 LLVM IR。</p>\n<h3 id=\"为什么选-AssemblyScript-作为-WebAssembly-开发语言\"><a href=\"#为什么选-AssemblyScript-作为-WebAssembly-开发语言\" class=\"headerlink\" title=\"为什么选 AssemblyScript 作为 WebAssembly 开发语言\"></a>为什么选 AssemblyScript 作为 WebAssembly 开发语言</h3><p>AssemblyScript 相对于 C、Rust 等其它语言去写 WebAssembly 而言，好处除了对前端来说无额外新语言学习成本外，还有对于不支持 WebAssembly 的浏览器，可以通过 TypeScript 编译器编译成可正常执行的 JS 代码，从而实现从 JS 到 WebAssembly 的平滑迁移。</p>\n<h3 id=\"接入-Webpack-构建\"><a href=\"#接入-Webpack-构建\" class=\"headerlink\" title=\"接入 Webpack 构建\"></a>接入 Webpack 构建</h3><p>任何新的 Web 开发技术都少不了构建流程，为了提供一套流畅的 WebAssembly 开发流程，接下来介绍接入 Webpack 具体步骤。</p>\n<ol>\n<li><p>安装以下依赖，以便让 TS 源码被 AssemblyScript 编译成 WebAssembly。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"assemblyscript\"</span>: <span class=\"string\">\"github:AssemblyScript/assemblyscript\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"assemblyscript-typescript-loader\"</span>: <span class=\"string\">\"^1.3.2\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"typescript\"</span>: <span class=\"string\">\"^2.8.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack\"</span>: <span class=\"string\">\"^3.10.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack-dev-server\"</span>: <span class=\"string\">\"^2.10.1\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>修改 webpack.config.js，加入 loader：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.ts$/,</span><br><span class=\"line\">                loader: &apos;assemblyscript-typescript-loader&apos;,</span><br><span class=\"line\">                options: &#123;</span><br><span class=\"line\">                    sourceMap: true,</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>修改 TypeScript 编译器配置 tsconfig.json，以便让 TypeScript 编译器能支持 AssemblyScript 中引入的内置类型和函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;extends&quot;: &quot;../../node_modules/assemblyscript/std/portable.json&quot;,</span><br><span class=\"line\">  &quot;include&quot;: [</span><br><span class=\"line\">    &quot;./**/*.ts&quot;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置直接继承自 assemblyscript 内置的配置文件。</p>\n</li>\n</ol>\n<h2 id=\"WebAssembly-相关文件格式\"><a href=\"#WebAssembly-相关文件格式\" class=\"headerlink\" title=\"WebAssembly 相关文件格式\"></a>WebAssembly 相关文件格式</h2><p>前面提到了 WebAssembly 的二进制文件格式 wasm，这种格式的文件人眼无法阅读，为了阅读 WebAssembly 文件的逻辑，还有一种文本格式叫 wast； 以前面讲到的计算斐波那契序列的模块为例，对应的 wast 文件如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func $src/asm/module/f (param f64) (result f64)</span><br><span class=\"line\">(local i32)</span><br><span class=\"line\">  get_local 0</span><br><span class=\"line\">  f64.const 1</span><br><span class=\"line\">  f64.eq</span><br><span class=\"line\">  tee_local 1</span><br><span class=\"line\">  if i32</span><br><span class=\"line\">    get_local 1</span><br><span class=\"line\">  else</span><br><span class=\"line\">    get_local 0</span><br><span class=\"line\">    f64.const 2</span><br><span class=\"line\">    f64.eq</span><br><span class=\"line\">  end</span><br><span class=\"line\">  i32.const 1</span><br><span class=\"line\">  i32.and</span><br><span class=\"line\">  if</span><br><span class=\"line\">    f64.const 1</span><br><span class=\"line\">    return</span><br><span class=\"line\">  end</span><br><span class=\"line\">  get_local 0</span><br><span class=\"line\">  f64.const 1</span><br><span class=\"line\">  f64.sub</span><br><span class=\"line\">  call 0</span><br><span class=\"line\">  get_local 0</span><br><span class=\"line\">  f64.const 2</span><br><span class=\"line\">  f64.sub</span><br><span class=\"line\">  call 0</span><br><span class=\"line\">  f64.add</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>这和汇编语言非常像，里面的 f64 是数据类型，f64.eq f64.sub f64.add 则是 CPU 指令。</p>\n<p>为了把二进制文件格式 wasm 转换成人眼可见的 wast 文本，需要安装 WebAssembly 二进制工具箱<a href=\"https://github.com/WebAssembly/wabt\" target=\"_blank\" rel=\"noopener\">WABT</a>， 在 Mac 系统下可通过 brew install WABT 安装，安装成功后可以通过命令 wasm2wast f.wasm 获得 wast；除此之外还可以通过 wast2wasm f.wast -o f.wasm 逆向转换回去。</p>\n<h2 id=\"WebAssembly-相关工具\"><a href=\"#WebAssembly-相关工具\" class=\"headerlink\" title=\"WebAssembly 相关工具\"></a>WebAssembly 相关工具</h2><p>除了前面提到的 WebAssembly 二进制工具箱，WebAssembly 社区还有以下常用工具：</p>\n<ul>\n<li><a href=\"http://kripken.github.io/emscripten-site/\" target=\"_blank\" rel=\"noopener\">Emscripten</a>: 能把 C、C++代码转换成 wasm、asm.js；</li>\n<li><a href=\"https://github.com/WebAssembly/binaryen\" target=\"_blank\" rel=\"noopener\">Binaryen</a>: 提供更简洁的 IR，把 IR 转换成 wasm，并且提供 wasm 的编译时优化、wasm 虚拟机，wasm 压缩等功能，前面提到的 AssemblyScript 就是基于它。</li>\n</ul>\n<h2 id=\"WebAssembly-JS-API\"><a href=\"#WebAssembly-JS-API\" class=\"headerlink\" title=\"WebAssembly JS API\"></a>WebAssembly JS API</h2><p>目前 WebAssembly 只能通过 JS 去加载和执行，但未来在浏览器中可以通过像加载 JS 那样 <script src=\"f.wasm\"></script> 去加载和执行 WebAssembly，下面来详细介绍如何用 JS 调 WebAssembly。</p>\n<p>JS 调 WebAssembly 分为 3 大步：<strong>加载字节码 &gt; 编译字节码 &gt; 实例化</strong>，获取到 WebAssembly 实例后就可以通过 JS 去调用了，以上 3 步具体的操作是：</p>\n<ol>\n<li>对于浏览器可以通过网络请求去加载字节码，对于 Nodejs 可以通过 fs 模块读取字节码文件；</li>\n<li>在获取到字节码后都需要转换成 ArrayBuffer 后才能被编译，通过 WebAssembly 通过的 JS API <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compile\" target=\"_blank\" rel=\"noopener\">WebAssembly.compile</a> 编译后会通过 Promise resolve 一个 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module\" target=\"_blank\" rel=\"noopener\">WebAssembly.Module</a>，这个 module 是不能直接被调用的需要；</li>\n<li>在获取到 module 后需要通过<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Instance\" target=\"_blank\" rel=\"noopener\"> WebAssembly.Instance</a> API 去实例化 module，获取到 Instance 后就可以像使用 JS 模块一个调用了。</li>\n</ol>\n<p>其中的第 2、3 步可以合并一步完成，前面提到的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate\" target=\"_blank\" rel=\"noopener\">WebAssembly.instantiate</a> 就做了这两个事情。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebAssembly.instantiate(bytes).then(<span class=\"function\"><span class=\"params\">mod</span>=&gt;</span>&#123;</span><br><span class=\"line\">  mod.instance.f(<span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"WebAssembly-调-JS\"><a href=\"#WebAssembly-调-JS\" class=\"headerlink\" title=\"WebAssembly 调 JS\"></a>WebAssembly 调 JS</h3><p>之前的例子都是用 JS 去调用 WebAssembly 模块，但是在有些场景下可能需要在 WebAssembly 模块中调用浏览器 API，接下来介绍如何在 WebAssembly 中调用 JS。</p>\n<p>WebAssembly.instantiate 函数支持第二个参数 WebAssembly.instantiate(bytes,importObject)，这个 importObject 参数的作用就是 JS 向 WebAssembly 传入 WebAssembly 中需要调用 JS 的 JS 模块。举个具体的例子，改造前面的计算斐波那契序列在 WebAssembly 中调用 Web 中的 window.alert 函数把计算结果弹出来，为此需要改造加载 WebAssembly 模块的 JS 代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebAssembly.instantiate(bytes,&#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>:&#123;</span><br><span class=\"line\">    alert:<span class=\"built_in\">window</span>.alert</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">mod</span>=&gt;</span>&#123;</span><br><span class=\"line\">  mod.instance.f(<span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>对应的还需要修改 AssemblyScript 编写的源码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明从外部导入的模块类型</span></span><br><span class=\"line\">declare namespace <span class=\"built_in\">window</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">alert</span>(<span class=\"params\">v: number</span>): <span class=\"title\">void</span>;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\"><span class=\"function\"> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">_f</span>(<span class=\"params\">x: number</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == <span class=\"number\">1</span> || x == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _f(x - <span class=\"number\">1</span>) + _f(x - <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x: number</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 直接调用 JS 模块</span></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.alert(_f(x));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改以上 AssemblyScript 源码后重新用 asc 通过命令 asc f.ts 编译后输出的 wast 文件比之前多了几行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(import &quot;window&quot; &quot;alert&quot; (func $src/asm/module/window.alert (type 0)))</span><br><span class=\"line\"> </span><br><span class=\"line\">(func $src/asm/module/f (type 0) (param f64)</span><br><span class=\"line\">    get_local 0</span><br><span class=\"line\">    call $src/asm/module/_f</span><br><span class=\"line\">    call $src/asm/module/window.alert)</span><br></pre></td></tr></table></figure>\n<p>多出的这部分 wast 代码就是在 AssemblyScript 中调用 JS 中传入的模块的逻辑。</p>\n<p>除了以上常用的 API 外，WebAssembly 还提供一些 API，你可以通过这个<a href=\"https://github.com/01alchemist/webassembly-types/blob/master/webassembly.d.ts\" target=\"_blank\" rel=\"noopener\"> d.ts 文件</a>去查看所有 WebAssembly JS API 的细节。</p>\n<h2 id=\"不止于浏览器\"><a href=\"#不止于浏览器\" class=\"headerlink\" title=\"不止于浏览器\"></a>不止于浏览器</h2><p>WebAssembly 作为一种底层字节码，除了能在浏览器中运行外，还能在其它环境运行。</p>\n<h3 id=\"直接执行-wasm-二进制文件\"><a href=\"#直接执行-wasm-二进制文件\" class=\"headerlink\" title=\"直接执行 wasm 二进制文件\"></a>直接执行 wasm 二进制文件</h3><p>前面提到的 Binaryen 提供了在命令行中直接执行 wasm 二进制文件的工具，在 Mac 系统下通过 brew install binaryen 安装成功后，通过 wasm-shell f.wasm 文件即可直接运行。</p>\n<h3 id=\"在-Node-js-中运行\"><a href=\"#在-Node-js-中运行\" class=\"headerlink\" title=\"在 Node.js 中运行\"></a>在 Node.js 中运行</h3><p>目前 V8 JS 引擎已经添加了对 WebAssembly 的支持，Chrome 和 Node.js 都采用了 V8 作为引擎，因此 WebAssembly 也可以运行在 Node.js 环境中；</p>\n<p>V8 JS 引擎在运行 WebAssembly 时，WebAssembly 和 JS 是在同一个虚拟机中执行，而不是 WebAssembly 在一个单独的虚拟机中运行，这样方便实现 JS 和 WebAssembly 之间的相互调用。</p>\n<p>要让上面的例子在 Node.js 中运行，可以使用以下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toUint8Array</span>(<span class=\"params\">buf</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> u = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(buf.length);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; buf.length; ++i) &#123;</span><br><span class=\"line\">        u[i] = buf[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> u;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadWebAssembly</span>(<span class=\"params\">filename, imports</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 读取 wasm 文件，并转换成 byte 数组</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> buffer = toUint8Array(fs.readFileSync(filename));</span><br><span class=\"line\">    <span class=\"comment\">// 编译 wasm 字节码到机器码</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> WebAssembly.compile(buffer)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 实例化模块</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WebAssembly.Instance(<span class=\"built_in\">module</span>, imports)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">loadWebAssembly(<span class=\"string\">'../temp/assembly/module.wasm'</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">instance</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 f 函数计算</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(instance.exports.f(<span class=\"number\">10</span>))</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>在 Nodejs 环境中运行 WebAssembly 的意义其实不大，原因在于 Nodejs 支持运行原生模块，而原生模块的性能比 WebAssembly 要好。 如果你是通过 C、Rust 去编写 WebAssembly，你可以直接编译成 Nodejs 可以调用的原生模块。</p>\n<h2 id=\"WebAssembly-展望\"><a href=\"#WebAssembly-展望\" class=\"headerlink\" title=\"WebAssembly 展望\"></a>WebAssembly 展望</h2><p>从上面的内容可见 WebAssembly 主要是为了解决 JS 的性能瓶颈，也就是说 WebAssembly 适合用于需要大量计算的场景，例如：</p>\n<ul>\n<li>在浏览器中处理音视频，<a href=\"https://github.com/Bilibili/flv.js/\" target=\"_blank\" rel=\"noopener\">flv.js</a> 用 WebAssembly 重写后性能会有很大提升；</li>\n<li>React 的 dom diff 中涉及到大量计算，用 WebAssembly 重写 React 核心模块能提升性能。Safari 浏览器使用的 JS 引擎 JavaScriptCore 也已经支持 WebAssembly，RN 应用性能也能提升；</li>\n<li>突破大型 3D 网页游戏性能瓶颈，<a href=\"https://feday.fequan.com/2017/WebAssembly%E5%9C%A8%E7%99%BD%E9%B9%AD%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%9E%E8%B7%B5.pdf\" target=\"_blank\" rel=\"noopener\">白鹭引擎已经开始探索用 WebAssembly</a>。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>WebAssembly 标准虽然已经定稿并且得到主流浏览器的实现，但目前还存在以下问题：</p>\n<ul>\n<li>浏览器兼容性不好，只有最新版本的浏览器支持，并且不同的浏览器对 JS WebAssembly 互调的 API 支持不一致；</li>\n<li>生态工具不完善不成熟，目前还不能找到一门体验流畅的编写 WebAssembly 的语言，都还处于起步阶段；</li>\n<li>学习资料太少，还需要更多的人去探索去踩坑。；</li>\n</ul>\n<p>总之现在的 WebAssembly 还不算成熟，如果你的团队没有不可容忍的性能问题，那现在使用 WebAssembly 到产品中还不是时候， 因为这可能会影响到团队的开发效率，或者遇到无法轻易解决的坑而阻塞开发。</p>\n<h2 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/09/asmjs_emscripten.html\" target=\"_blank\" rel=\"noopener\">asm.js 和 Emscripten 入门教程</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-clang/index.html\" target=\"_blank\" rel=\"noopener\">结构化编译器前端 Clang 介绍</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/WebAssembly/Understanding_the_text_format\" target=\"_blank\" rel=\"noopener\">理解 WebAssembly 文本格式</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/WebAssembly/Using_the_JavaScript_API\" target=\"_blank\" rel=\"noopener\">使用 WebAssembly JavaScript API</a></li>\n</ul>\n<blockquote>\n<p>本文首发于<a href=\"https://www.ibm.com/developerworks/cn/web/wa-lo-webassembly-status-and-reality/index.html\" target=\"_blank\" rel=\"noopener\">IBM Dev社区</a></p>\n</blockquote>\n"},{"title":"webpack2 终极优化","date":"2017-04-30T01:51:14.000Z","url":"https://github.com/gwuhaolin/blog/issues/2","_content":"\n[![](http://ou8vcvyuy.bkt.clouddn.com/dive-into-webpack-for-blog.jpg)](http://webpack.wuhaolin.cn/)\n\nwebpack是当下最流行的js打包工具，这得益于网页应用日益复杂和js模块化的流行。[webpack2](https://webpack.js.org)增加了一些新特性也正式发布了一段时间，是时候告诉大家如何用webpack2优化你的构建让它构建出更小的文件尺寸和更好的开发体验。\n\n# 优化输出\n打包结果更小可以让网页打开速度更快以及简约宽带。可以通过这以下几点做到\n\n#### 压缩css\n`css-loader` 在webpack2里默认是没有开启压缩的，最后生成的css文件里有很多空格和tab，通过配置\n`css-loader?minimize`参数可以开启压缩输出最小的css。css的压缩实际是是通过[cssnano](http://cssnano.co)实现的。\n\n#### tree-shaking\ntree-shaking 是指借助es6 `import export` 语法静态性的特点来删掉export但是没有import过的东西。要让tree-shaking工作需要注意以下几点：\n- 配置babel让它在编译转化es6代码时不把`import export`转换为cmd的`module.export`，配置如下：\n```json\n\"presets\": [\n    [\n      \"es2015\",\n      {\n        \"modules\": false\n      }\n    ]\n]\n```\n- 大多数分布到npm的库里的代码都是es5的，但是也有部分库（redux,react-router等等）开始支持tree-shaking。这些库发布到npm里的代码即包含es5的又包含全采用了es6 `import export` 语法的代码。\n拿redux库来说，npm下载到的目录结构如下：\n```\n├── es\n│   └── utils\n├── lib\n│   └── utils\n```\n其中lib目录里是编译出的es5代码，es目录里是编译出的采用`import export` 语法的es5代码，在redux的`package.json`文件里有这两个配置：\n```\n\"main\": \"lib/index.js\",\n\"jsnext:main\": \"es/index.js\",\n```\n这是指这个库的入口文件的位置，所以要让webpack去读取es目录下的代码需要使用jsnext:main字段配置的入口，要做到这点webpack需要这样配置：\n```js\nmodule.exports = {\n\tresolve: {\n            mainFields: ['jsnext:main','main'],\n        }\n};\n```\n这会让webpack先使用jsnext:main字段，在没有时使用main字段。这样就可以优化支持tree-shaking的库。\n\n#### 优化 UglifyJsPlugin\nwebpack `--optimize-minimize` 选项会开启 UglifyJsPlugin来压缩输出的js，但是默认的UglifyJsPlugin配置并没有把代码压缩到最小输出的js里还是有注释和空格，需要覆盖默认的配置：\n```js\nnew UglifyJsPlugin({\n    // 最紧凑的输出\n    beautify: false,\n    // 删除所有的注释\n    comments: false,\n    compress: {\n      // 在UglifyJs删除没有用到的代码时不输出警告  \n      warnings: false,\n      // 删除所有的 `console` 语句\n      // 还可以兼容ie浏览器\n      drop_console: true,\n      // 内嵌定义了但是只用到一次的变量\n      collapse_vars: true,\n      // 提取出出现多次但是没有定义成变量去引用的静态值\n      reduce_vars: true,\n    }\n})\n```\n\n#### 定义环境变量 NODE_ENV=production\n很多库里（比如react）有部分代码是这样的：\n```js\nif(process.env.NODE_ENV !== 'production'){\n// 不是生产环境才需要用到的代码，比如控制台里看到的警告    \n}\n```\n在环境变量 `NODE_ENV` 等于 `production` 的时候UglifyJs会认为if语句里的是死代码在压缩代码时删掉。\n\n#### 使用 CommonsChunkPlugin 抽取公共代码\n[CommonsChunkPlugin](https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin)可以提取出多个代码块都依赖的模块形成一个单独的模块。要发挥CommonsChunkPlugin的作用还需要浏览器缓存机制的配合。在应用有多个页面的场景下提取出所有页面公共的代码减少单个页面的代码，在不同页面之间切换时所有页面公共的代码之前被加载过而不必重新加载。这个方法可以非常有效的提升应用性能。\n\n#### 在生产环境按照文件内容md5打hash\nwebpack编译在生产环境出来的js、css、图片、字体这些文件应该放到CDN上，再根据文件内容的md5命名文件，利用缓存机制用户只需要加载一次，第二次加载时就直接访问缓存。如果你之后有修改就会为对应的文件生产新的md5值。做到以上你需要这样配置：\n```js\n{\n  output: {\n    publicPath: CND_URL,\n    filename: '[name]_[chunkhash].js',\n  },\n}\n```\n知道以上原理后我们还可以进一步优化：利用CommonsChunkPlugin提取出使用页面都依赖的基础运行环境。比如对于最常见的react体系你可以抽出基础库`react` `react-dom` `redux` `react-redux`到一个单独的文件而不是和其它文件放在一起打包为一个文件，这样做的好处是只要你不升级他们的版本这个文件永远不会被刷新。如果你把这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致浏览器重复下载这些包含基础库的代码。以上的配置为：\n```js\n// vender.js 文件抽离基础库到单独的一个文件里防止跟随业务代码被刷新\n// 所有页面都依赖的第三方库\n// react基础\nimport 'react';\nimport 'react-dom';\nimport 'react-redux';\n// redux基础\nimport 'redux';\nimport 'redux-thunk';\n```\n```js\n// webpack配置\n{\n  entry: {\n    vendor: './path/to/vendor.js',\n  },\n}\n```\n\n#### DedupePlugin 和 OccurrenceOrderPlugin\n在webpack1里经常会使用 `DedupePlugin` 插件来消除重复的模块以及使用 `OccurrenceOrderPlugin` 插件让被依赖次数更高的模块靠前分到更小的id 来达到输出更少的代码，在webpack2里这些已经这两个插件已经被移除了因为这些功能已经被内置了。\n\n除了压缩文本代码外还可以：\n- **用[imagemin-webpack-plugin](https://github.com/Klathmon/imagemin-webpack-plugin) 压缩图片**\n- **用[webpack-spritesmith](https://github.com/mixtur/webpack-spritesmith) 合并雪碧图**\n- **对于支持es6的js运行环境使用[babili](https://github.com/babel/babili)**\n\n以上优化点只需要在构建用于生产环境代码的时候才使用，在开发环境时最好关闭因为它们很耗时。\n\n\n\n# 优化开发体验\n优化开发体验主要从更快的构建和更方便的功能入手。\n\n##  更快的构建\n\n#### 缩小文件搜索范围\nwebpack的`resolve.modules`配置模块库（通常是指node_modules）所在的位置，在js里出现`import 'redux'`这样不是相对也不是绝对路径的写法时会去node_modules目录下找。但是默认的配置会采用向上递归搜索的方式去寻找node_modules，但通常项目目录里只有一个node_modules在项目根目录，为了减少搜索我们直接写明node_modules的全路径：\n```js\nmodule.exports = {\n    resolve: {\n        modules: [path.resolve(__dirname, 'node_modules')]\n    }\n};\n```\n\n除此之外webpack配置loader时也可以缩小文件搜索范围。\n- loader的test正则表达式也应该尽可能的简单，比如在你的项目里只有`.js`文件时就不要把test写成`/\\.jsx?$/`\n- loader使用include命中只需要处理的文件，比如babel-loader的这两个配置:\n\n只对项目目录下src目录里的代码进行babel编译\n```js\n{\n    test: /\\.js$/,\n    loader: 'babel-loader',\n    include: path.resolve(__dirname, 'src')\n}\t\n```\n项目目录下的所有js都会进行babel编译，包括庞大的node_modules下的js\n```js\n{\n    test: /\\.js$/,\n    loader: 'babel-loader'\n}\t\n```\n\n#### 开启 babel-loader 缓存\nbabel编译过程很耗时，好在babel-loader提供缓存编译结果选项，在重启webpack时不需要创新编译而是复用缓存结果减少编译流程。babel-loader缓存机制默认是关闭的，打开的配置如下：\n```js\nmodule.exports = {\n    module: {\n         loaders: [{\n                test: /\\.js$/,\n                loader: 'babel-loader?cacheDirectory',\n         }]\n  }\n};\n```\n\n#### 使用 alias\n`resolve.alias` 配置路径映射。\n发布到npm的库大多数都包含两个目录，一个是放着cmd模块化的lib目录，一个是把所有文件合成一个文件的dist目录，多数的入口文件是指向lib里面下的。\n默认情况下webpack会去读lib目录下的入口文件再去递归加载其它依赖的文件这个过程很耗时，alias配置可以让webpack直接使用dist目录的整体文件减少文件递归解析。配置如下：\n```js\nmodule.exports = {\n  resolve: {\n    alias: {\n      'moment': 'moment/min/moment.min.js',\n      'react': 'react/dist/react.js',\n      'react-dom': 'react-dom/dist/react-dom.js'\n    }\n  }\n};\n```\n\n#### 使用 noParse\n`module.noParse` 配置哪些文件可以脱离webpack的解析。\n有些库是自成一体不依赖其他库的没有使用模块化的，比如jquey、momentjs、chart.js，要使用它们必须整体全部引入。\nwebpack是模块化打包工具完全没有必要去解析这些文件的依赖，因为它们都不依赖其它文件体积也很庞大，要忽略它们配置如下：\n```js\nmodule.exports = {\n  module: {\n    noParse: /node_modules\\/(jquey|moment|chart\\.js)/\n  }\n};\n```\n\n除此以外还有很多可以加速的方法：\n- **使用[happypack](https://github.com/amireh/happypack)多进程并行构建**\n- **使用[DllPlugin](https://github.com/webpack/docs/wiki/list-of-plugins#dllplugin)复用模块**\n\n## 更方便的功能 \n\n#### 模块热替换\n模块热替换是指在开发的过程中修改代码后不用刷新页面直接把变化的模块替换到老模块让页面呈现出最新的效果。\nwebpack-dev-server内置模块热替换，配置起来也很方便，下面以react应用为例，步骤如下：\n- 在启动webpack-dev-server的时候带上`--hot`参数开启模块热替换，在开启`--hot`后针对css的变化是会自动热替换的，但是js涉及到复杂的逻辑还需要进一步配置。\n- 配置页面入口文件\n\n```js\nimport App from './app';\n\nfunction run(){\n\trender(<App/>,document.getElementById('app'));\n}\nrun();\n\n// 只在开发模式下配置模块热替换\nif (process.env.NODE_ENV !== 'production') {\n  module.hot.accept('./app', run);\n}\n```\n\n当./app发生变化或者当./app依赖的文件发生变化时会把./app编译成一个模块去替换老的，替换完毕后重新执行run函数渲染出最新的效果。\n\n#### 自动生成html\nwebpack只做了资源打包的工作还缺少把这些加载到html里运行的功能，在庞大的app里手写html去加载这些资源是很繁琐易错的，我们需要自动正确的加载打包出的资源。\nwebpack原生不支持这个功能于是我做了一个插件 [web-webpack-plugin](https://github.com/gwuhaolin/web-webpack-plugin)\n具体使用点开链接看[详细文档](https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md)，使用大概如下：\n\n[demo](https://github.com/gwuhaolin/web-webpack-plugin/tree/master/demo/out-html)\n\nwebpack配置\n```js\nmodule.exports = {\n    entry: {\n        A: './a',\n        B: './b',\n    },\n    plugins: [\n        new WebPlugin({\n            // 输出的html文件名称，必填，注意不要重名，重名会覆盖相互文件。\n            filename: 'index.html',\n            // 该html文件依赖的entry，必须是一个数组。依赖的资源的注入顺序按照数组的顺序。\n            requires: ['A', 'B'],\n        }),\n    ]\n};\n```\n\n将会输出一个`index.html`文件，这个文件将会自动引入 entry `A` 和 `B` 生成的js文件，\n\n输出的html:\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n<body>\n<script src=\"A.js\"></script>\n<script src=\"B.js\"></script>\n</body>\n</html>\n```\n\n输出的目录结构\n```\n├── A.js\n├── B.js\n└── index.html\n```\n\n#### 管理多页面\n虽然webpack适用于单页应用，但复杂的系统经常是由多个单页应用组成，每个页面一个功能模块。webpack给出了js打包方案但缺少管理多个页面的功能。 [web-webpack-plugin](https://github.com/gwuhaolin/web-webpack-plugin)的`AutoWebPlugin`会自动的为你的系统里每个单页应用生成一个html入口页，这个入口会自动的注入当前单页应用依赖的资源，使用它你只需如下几行代码：\n```js\nplugins: [\n    // ./src/pages/ 代表存放所有页面的根目录，这个目录下的每一个目录被看着是一个单页应用\n    // 会为里面的每一个目录生成一个html入口\n    new AutoWebPlugin('./src/pages/', {\n      //使用单页应用的html模版文件，这里你可以自定义配置\n      template: './src/assets/template.html',\n    }),\n],\n```\n查看web-webpack-plugin的[文档了解更多](https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#自动探测html入口-demo)\n\n### 分析输出结果\n如果你对当前的配置输出或者构建速度不满意，webpack有一个工具叫做[webpack analyze](https://webpack.github.io/analyse/) 以可视化的方式直观的分析构建，来进一步优化构建结果和速度。要使用它你需要在执行webpack的时候带上`--json --profile`2个参数，这代表让webpack把构建结果以json输出并带上构建性能信息，使用如下：\n```bash\nwebpack --json --profile > stats.json \n```\n会生产一个`stats.json `文件，再打开[webpack analyze](https://webpack.github.io/analyse/) 上传这个文件开始分析。\n\n**最后附上这篇文章所讲到的[webpack整体的配置](https://gist.github.com/gwuhaolin/cebd252a23793e742e6acae90ab63e83)，分为开发环境的`webpack.config.js`和生产环境的`webpack-dist.config.js`**\n\n[阅读原文](http://wuhaolin.cn/2017/04/30/webpack2%20%E7%BB%88%E6%9E%81%E4%BC%98%E5%8C%96/)\n","source":"_posts/webpack2 终极优化.md","raw":"---\ntitle: webpack2 终极优化\ndate: 2017-04-30T09:51:14Z\nurl: https://github.com/gwuhaolin/blog/issues/2\ntags:\n    - webpack\n---\n\n[![](http://ou8vcvyuy.bkt.clouddn.com/dive-into-webpack-for-blog.jpg)](http://webpack.wuhaolin.cn/)\n\nwebpack是当下最流行的js打包工具，这得益于网页应用日益复杂和js模块化的流行。[webpack2](https://webpack.js.org)增加了一些新特性也正式发布了一段时间，是时候告诉大家如何用webpack2优化你的构建让它构建出更小的文件尺寸和更好的开发体验。\n\n# 优化输出\n打包结果更小可以让网页打开速度更快以及简约宽带。可以通过这以下几点做到\n\n#### 压缩css\n`css-loader` 在webpack2里默认是没有开启压缩的，最后生成的css文件里有很多空格和tab，通过配置\n`css-loader?minimize`参数可以开启压缩输出最小的css。css的压缩实际是是通过[cssnano](http://cssnano.co)实现的。\n\n#### tree-shaking\ntree-shaking 是指借助es6 `import export` 语法静态性的特点来删掉export但是没有import过的东西。要让tree-shaking工作需要注意以下几点：\n- 配置babel让它在编译转化es6代码时不把`import export`转换为cmd的`module.export`，配置如下：\n```json\n\"presets\": [\n    [\n      \"es2015\",\n      {\n        \"modules\": false\n      }\n    ]\n]\n```\n- 大多数分布到npm的库里的代码都是es5的，但是也有部分库（redux,react-router等等）开始支持tree-shaking。这些库发布到npm里的代码即包含es5的又包含全采用了es6 `import export` 语法的代码。\n拿redux库来说，npm下载到的目录结构如下：\n```\n├── es\n│   └── utils\n├── lib\n│   └── utils\n```\n其中lib目录里是编译出的es5代码，es目录里是编译出的采用`import export` 语法的es5代码，在redux的`package.json`文件里有这两个配置：\n```\n\"main\": \"lib/index.js\",\n\"jsnext:main\": \"es/index.js\",\n```\n这是指这个库的入口文件的位置，所以要让webpack去读取es目录下的代码需要使用jsnext:main字段配置的入口，要做到这点webpack需要这样配置：\n```js\nmodule.exports = {\n\tresolve: {\n            mainFields: ['jsnext:main','main'],\n        }\n};\n```\n这会让webpack先使用jsnext:main字段，在没有时使用main字段。这样就可以优化支持tree-shaking的库。\n\n#### 优化 UglifyJsPlugin\nwebpack `--optimize-minimize` 选项会开启 UglifyJsPlugin来压缩输出的js，但是默认的UglifyJsPlugin配置并没有把代码压缩到最小输出的js里还是有注释和空格，需要覆盖默认的配置：\n```js\nnew UglifyJsPlugin({\n    // 最紧凑的输出\n    beautify: false,\n    // 删除所有的注释\n    comments: false,\n    compress: {\n      // 在UglifyJs删除没有用到的代码时不输出警告  \n      warnings: false,\n      // 删除所有的 `console` 语句\n      // 还可以兼容ie浏览器\n      drop_console: true,\n      // 内嵌定义了但是只用到一次的变量\n      collapse_vars: true,\n      // 提取出出现多次但是没有定义成变量去引用的静态值\n      reduce_vars: true,\n    }\n})\n```\n\n#### 定义环境变量 NODE_ENV=production\n很多库里（比如react）有部分代码是这样的：\n```js\nif(process.env.NODE_ENV !== 'production'){\n// 不是生产环境才需要用到的代码，比如控制台里看到的警告    \n}\n```\n在环境变量 `NODE_ENV` 等于 `production` 的时候UglifyJs会认为if语句里的是死代码在压缩代码时删掉。\n\n#### 使用 CommonsChunkPlugin 抽取公共代码\n[CommonsChunkPlugin](https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin)可以提取出多个代码块都依赖的模块形成一个单独的模块。要发挥CommonsChunkPlugin的作用还需要浏览器缓存机制的配合。在应用有多个页面的场景下提取出所有页面公共的代码减少单个页面的代码，在不同页面之间切换时所有页面公共的代码之前被加载过而不必重新加载。这个方法可以非常有效的提升应用性能。\n\n#### 在生产环境按照文件内容md5打hash\nwebpack编译在生产环境出来的js、css、图片、字体这些文件应该放到CDN上，再根据文件内容的md5命名文件，利用缓存机制用户只需要加载一次，第二次加载时就直接访问缓存。如果你之后有修改就会为对应的文件生产新的md5值。做到以上你需要这样配置：\n```js\n{\n  output: {\n    publicPath: CND_URL,\n    filename: '[name]_[chunkhash].js',\n  },\n}\n```\n知道以上原理后我们还可以进一步优化：利用CommonsChunkPlugin提取出使用页面都依赖的基础运行环境。比如对于最常见的react体系你可以抽出基础库`react` `react-dom` `redux` `react-redux`到一个单独的文件而不是和其它文件放在一起打包为一个文件，这样做的好处是只要你不升级他们的版本这个文件永远不会被刷新。如果你把这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致浏览器重复下载这些包含基础库的代码。以上的配置为：\n```js\n// vender.js 文件抽离基础库到单独的一个文件里防止跟随业务代码被刷新\n// 所有页面都依赖的第三方库\n// react基础\nimport 'react';\nimport 'react-dom';\nimport 'react-redux';\n// redux基础\nimport 'redux';\nimport 'redux-thunk';\n```\n```js\n// webpack配置\n{\n  entry: {\n    vendor: './path/to/vendor.js',\n  },\n}\n```\n\n#### DedupePlugin 和 OccurrenceOrderPlugin\n在webpack1里经常会使用 `DedupePlugin` 插件来消除重复的模块以及使用 `OccurrenceOrderPlugin` 插件让被依赖次数更高的模块靠前分到更小的id 来达到输出更少的代码，在webpack2里这些已经这两个插件已经被移除了因为这些功能已经被内置了。\n\n除了压缩文本代码外还可以：\n- **用[imagemin-webpack-plugin](https://github.com/Klathmon/imagemin-webpack-plugin) 压缩图片**\n- **用[webpack-spritesmith](https://github.com/mixtur/webpack-spritesmith) 合并雪碧图**\n- **对于支持es6的js运行环境使用[babili](https://github.com/babel/babili)**\n\n以上优化点只需要在构建用于生产环境代码的时候才使用，在开发环境时最好关闭因为它们很耗时。\n\n\n\n# 优化开发体验\n优化开发体验主要从更快的构建和更方便的功能入手。\n\n##  更快的构建\n\n#### 缩小文件搜索范围\nwebpack的`resolve.modules`配置模块库（通常是指node_modules）所在的位置，在js里出现`import 'redux'`这样不是相对也不是绝对路径的写法时会去node_modules目录下找。但是默认的配置会采用向上递归搜索的方式去寻找node_modules，但通常项目目录里只有一个node_modules在项目根目录，为了减少搜索我们直接写明node_modules的全路径：\n```js\nmodule.exports = {\n    resolve: {\n        modules: [path.resolve(__dirname, 'node_modules')]\n    }\n};\n```\n\n除此之外webpack配置loader时也可以缩小文件搜索范围。\n- loader的test正则表达式也应该尽可能的简单，比如在你的项目里只有`.js`文件时就不要把test写成`/\\.jsx?$/`\n- loader使用include命中只需要处理的文件，比如babel-loader的这两个配置:\n\n只对项目目录下src目录里的代码进行babel编译\n```js\n{\n    test: /\\.js$/,\n    loader: 'babel-loader',\n    include: path.resolve(__dirname, 'src')\n}\t\n```\n项目目录下的所有js都会进行babel编译，包括庞大的node_modules下的js\n```js\n{\n    test: /\\.js$/,\n    loader: 'babel-loader'\n}\t\n```\n\n#### 开启 babel-loader 缓存\nbabel编译过程很耗时，好在babel-loader提供缓存编译结果选项，在重启webpack时不需要创新编译而是复用缓存结果减少编译流程。babel-loader缓存机制默认是关闭的，打开的配置如下：\n```js\nmodule.exports = {\n    module: {\n         loaders: [{\n                test: /\\.js$/,\n                loader: 'babel-loader?cacheDirectory',\n         }]\n  }\n};\n```\n\n#### 使用 alias\n`resolve.alias` 配置路径映射。\n发布到npm的库大多数都包含两个目录，一个是放着cmd模块化的lib目录，一个是把所有文件合成一个文件的dist目录，多数的入口文件是指向lib里面下的。\n默认情况下webpack会去读lib目录下的入口文件再去递归加载其它依赖的文件这个过程很耗时，alias配置可以让webpack直接使用dist目录的整体文件减少文件递归解析。配置如下：\n```js\nmodule.exports = {\n  resolve: {\n    alias: {\n      'moment': 'moment/min/moment.min.js',\n      'react': 'react/dist/react.js',\n      'react-dom': 'react-dom/dist/react-dom.js'\n    }\n  }\n};\n```\n\n#### 使用 noParse\n`module.noParse` 配置哪些文件可以脱离webpack的解析。\n有些库是自成一体不依赖其他库的没有使用模块化的，比如jquey、momentjs、chart.js，要使用它们必须整体全部引入。\nwebpack是模块化打包工具完全没有必要去解析这些文件的依赖，因为它们都不依赖其它文件体积也很庞大，要忽略它们配置如下：\n```js\nmodule.exports = {\n  module: {\n    noParse: /node_modules\\/(jquey|moment|chart\\.js)/\n  }\n};\n```\n\n除此以外还有很多可以加速的方法：\n- **使用[happypack](https://github.com/amireh/happypack)多进程并行构建**\n- **使用[DllPlugin](https://github.com/webpack/docs/wiki/list-of-plugins#dllplugin)复用模块**\n\n## 更方便的功能 \n\n#### 模块热替换\n模块热替换是指在开发的过程中修改代码后不用刷新页面直接把变化的模块替换到老模块让页面呈现出最新的效果。\nwebpack-dev-server内置模块热替换，配置起来也很方便，下面以react应用为例，步骤如下：\n- 在启动webpack-dev-server的时候带上`--hot`参数开启模块热替换，在开启`--hot`后针对css的变化是会自动热替换的，但是js涉及到复杂的逻辑还需要进一步配置。\n- 配置页面入口文件\n\n```js\nimport App from './app';\n\nfunction run(){\n\trender(<App/>,document.getElementById('app'));\n}\nrun();\n\n// 只在开发模式下配置模块热替换\nif (process.env.NODE_ENV !== 'production') {\n  module.hot.accept('./app', run);\n}\n```\n\n当./app发生变化或者当./app依赖的文件发生变化时会把./app编译成一个模块去替换老的，替换完毕后重新执行run函数渲染出最新的效果。\n\n#### 自动生成html\nwebpack只做了资源打包的工作还缺少把这些加载到html里运行的功能，在庞大的app里手写html去加载这些资源是很繁琐易错的，我们需要自动正确的加载打包出的资源。\nwebpack原生不支持这个功能于是我做了一个插件 [web-webpack-plugin](https://github.com/gwuhaolin/web-webpack-plugin)\n具体使用点开链接看[详细文档](https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md)，使用大概如下：\n\n[demo](https://github.com/gwuhaolin/web-webpack-plugin/tree/master/demo/out-html)\n\nwebpack配置\n```js\nmodule.exports = {\n    entry: {\n        A: './a',\n        B: './b',\n    },\n    plugins: [\n        new WebPlugin({\n            // 输出的html文件名称，必填，注意不要重名，重名会覆盖相互文件。\n            filename: 'index.html',\n            // 该html文件依赖的entry，必须是一个数组。依赖的资源的注入顺序按照数组的顺序。\n            requires: ['A', 'B'],\n        }),\n    ]\n};\n```\n\n将会输出一个`index.html`文件，这个文件将会自动引入 entry `A` 和 `B` 生成的js文件，\n\n输出的html:\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n<body>\n<script src=\"A.js\"></script>\n<script src=\"B.js\"></script>\n</body>\n</html>\n```\n\n输出的目录结构\n```\n├── A.js\n├── B.js\n└── index.html\n```\n\n#### 管理多页面\n虽然webpack适用于单页应用，但复杂的系统经常是由多个单页应用组成，每个页面一个功能模块。webpack给出了js打包方案但缺少管理多个页面的功能。 [web-webpack-plugin](https://github.com/gwuhaolin/web-webpack-plugin)的`AutoWebPlugin`会自动的为你的系统里每个单页应用生成一个html入口页，这个入口会自动的注入当前单页应用依赖的资源，使用它你只需如下几行代码：\n```js\nplugins: [\n    // ./src/pages/ 代表存放所有页面的根目录，这个目录下的每一个目录被看着是一个单页应用\n    // 会为里面的每一个目录生成一个html入口\n    new AutoWebPlugin('./src/pages/', {\n      //使用单页应用的html模版文件，这里你可以自定义配置\n      template: './src/assets/template.html',\n    }),\n],\n```\n查看web-webpack-plugin的[文档了解更多](https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#自动探测html入口-demo)\n\n### 分析输出结果\n如果你对当前的配置输出或者构建速度不满意，webpack有一个工具叫做[webpack analyze](https://webpack.github.io/analyse/) 以可视化的方式直观的分析构建，来进一步优化构建结果和速度。要使用它你需要在执行webpack的时候带上`--json --profile`2个参数，这代表让webpack把构建结果以json输出并带上构建性能信息，使用如下：\n```bash\nwebpack --json --profile > stats.json \n```\n会生产一个`stats.json `文件，再打开[webpack analyze](https://webpack.github.io/analyse/) 上传这个文件开始分析。\n\n**最后附上这篇文章所讲到的[webpack整体的配置](https://gist.github.com/gwuhaolin/cebd252a23793e742e6acae90ab63e83)，分为开发环境的`webpack.config.js`和生产环境的`webpack-dist.config.js`**\n\n[阅读原文](http://wuhaolin.cn/2017/04/30/webpack2%20%E7%BB%88%E6%9E%81%E4%BC%98%E5%8C%96/)\n","slug":"webpack2 终极优化","published":1,"updated":"2018-11-14T04:39:28.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjogs0ke50006g5tcibju4y26","content":"<p><a href=\"http://webpack.wuhaolin.cn/\" target=\"_blank\" rel=\"noopener\"><img src=\"http://ou8vcvyuy.bkt.clouddn.com/dive-into-webpack-for-blog.jpg\" alt=\"\"></a></p>\n<p>webpack是当下最流行的js打包工具，这得益于网页应用日益复杂和js模块化的流行。<a href=\"https://webpack.js.org\" target=\"_blank\" rel=\"noopener\">webpack2</a>增加了一些新特性也正式发布了一段时间，是时候告诉大家如何用webpack2优化你的构建让它构建出更小的文件尺寸和更好的开发体验。</p>\n<h1 id=\"优化输出\"><a href=\"#优化输出\" class=\"headerlink\" title=\"优化输出\"></a>优化输出</h1><p>打包结果更小可以让网页打开速度更快以及简约宽带。可以通过这以下几点做到</p>\n<h4 id=\"压缩css\"><a href=\"#压缩css\" class=\"headerlink\" title=\"压缩css\"></a>压缩css</h4><p><code>css-loader</code> 在webpack2里默认是没有开启压缩的，最后生成的css文件里有很多空格和tab，通过配置<br><code>css-loader?minimize</code>参数可以开启压缩输出最小的css。css的压缩实际是是通过<a href=\"http://cssnano.co\" target=\"_blank\" rel=\"noopener\">cssnano</a>实现的。</p>\n<h4 id=\"tree-shaking\"><a href=\"#tree-shaking\" class=\"headerlink\" title=\"tree-shaking\"></a>tree-shaking</h4><p>tree-shaking 是指借助es6 <code>import export</code> 语法静态性的特点来删掉export但是没有import过的东西。要让tree-shaking工作需要注意以下几点：</p>\n<ul>\n<li><p>配置babel让它在编译转化es6代码时不把<code>import export</code>转换为cmd的<code>module.export</code>，配置如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"presets\": [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"es2015\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"modules\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>大多数分布到npm的库里的代码都是es5的，但是也有部分库（redux,react-router等等）开始支持tree-shaking。这些库发布到npm里的代码即包含es5的又包含全采用了es6 <code>import export</code> 语法的代码。<br>拿redux库来说，npm下载到的目录结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── es</span><br><span class=\"line\">│   └── utils</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">│   └── utils</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其中lib目录里是编译出的es5代码，es目录里是编译出的采用<code>import export</code> 语法的es5代码，在redux的<code>package.json</code>文件里有这两个配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main&quot;: &quot;lib/index.js&quot;,</span><br><span class=\"line\">&quot;jsnext:main&quot;: &quot;es/index.js&quot;,</span><br></pre></td></tr></table></figure></p>\n<p>这是指这个库的入口文件的位置，所以要让webpack去读取es目录下的代码需要使用jsnext:main字段配置的入口，要做到这点webpack需要这样配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">\tresolve: &#123;</span><br><span class=\"line\">            mainFields: [<span class=\"string\">'jsnext:main'</span>,<span class=\"string\">'main'</span>],</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这会让webpack先使用jsnext:main字段，在没有时使用main字段。这样就可以优化支持tree-shaking的库。</p>\n<h4 id=\"优化-UglifyJsPlugin\"><a href=\"#优化-UglifyJsPlugin\" class=\"headerlink\" title=\"优化 UglifyJsPlugin\"></a>优化 UglifyJsPlugin</h4><p>webpack <code>--optimize-minimize</code> 选项会开启 UglifyJsPlugin来压缩输出的js，但是默认的UglifyJsPlugin配置并没有把代码压缩到最小输出的js里还是有注释和空格，需要覆盖默认的配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> UglifyJsPlugin(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 最紧凑的输出</span></span><br><span class=\"line\">    beautify: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 删除所有的注释</span></span><br><span class=\"line\">    comments: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    compress: &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在UglifyJs删除没有用到的代码时不输出警告  </span></span><br><span class=\"line\">      warnings: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 删除所有的 `console` 语句</span></span><br><span class=\"line\">      <span class=\"comment\">// 还可以兼容ie浏览器</span></span><br><span class=\"line\">      drop_console: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 内嵌定义了但是只用到一次的变量</span></span><br><span class=\"line\">      collapse_vars: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 提取出出现多次但是没有定义成变量去引用的静态值</span></span><br><span class=\"line\">      reduce_vars: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"定义环境变量-NODE-ENV-production\"><a href=\"#定义环境变量-NODE-ENV-production\" class=\"headerlink\" title=\"定义环境变量 NODE_ENV=production\"></a>定义环境变量 NODE_ENV=production</h4><p>很多库里（比如react）有部分代码是这样的：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(process.env.NODE_ENV !== <span class=\"string\">'production'</span>)&#123;</span><br><span class=\"line\"><span class=\"comment\">// 不是生产环境才需要用到的代码，比如控制台里看到的警告    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在环境变量 <code>NODE_ENV</code> 等于 <code>production</code> 的时候UglifyJs会认为if语句里的是死代码在压缩代码时删掉。</p>\n<h4 id=\"使用-CommonsChunkPlugin-抽取公共代码\"><a href=\"#使用-CommonsChunkPlugin-抽取公共代码\" class=\"headerlink\" title=\"使用 CommonsChunkPlugin 抽取公共代码\"></a>使用 CommonsChunkPlugin 抽取公共代码</h4><p><a href=\"https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin\" target=\"_blank\" rel=\"noopener\">CommonsChunkPlugin</a>可以提取出多个代码块都依赖的模块形成一个单独的模块。要发挥CommonsChunkPlugin的作用还需要浏览器缓存机制的配合。在应用有多个页面的场景下提取出所有页面公共的代码减少单个页面的代码，在不同页面之间切换时所有页面公共的代码之前被加载过而不必重新加载。这个方法可以非常有效的提升应用性能。</p>\n<h4 id=\"在生产环境按照文件内容md5打hash\"><a href=\"#在生产环境按照文件内容md5打hash\" class=\"headerlink\" title=\"在生产环境按照文件内容md5打hash\"></a>在生产环境按照文件内容md5打hash</h4><p>webpack编译在生产环境出来的js、css、图片、字体这些文件应该放到CDN上，再根据文件内容的md5命名文件，利用缓存机制用户只需要加载一次，第二次加载时就直接访问缓存。如果你之后有修改就会为对应的文件生产新的md5值。做到以上你需要这样配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    publicPath: CND_URL,</span><br><span class=\"line\">    filename: <span class=\"string\">'[name]_[chunkhash].js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>知道以上原理后我们还可以进一步优化：利用CommonsChunkPlugin提取出使用页面都依赖的基础运行环境。比如对于最常见的react体系你可以抽出基础库<code>react</code> <code>react-dom</code> <code>redux</code> <code>react-redux</code>到一个单独的文件而不是和其它文件放在一起打包为一个文件，这样做的好处是只要你不升级他们的版本这个文件永远不会被刷新。如果你把这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致浏览器重复下载这些包含基础库的代码。以上的配置为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vender.js 文件抽离基础库到单独的一个文件里防止跟随业务代码被刷新</span></span><br><span class=\"line\"><span class=\"comment\">// 所有页面都依赖的第三方库</span></span><br><span class=\"line\"><span class=\"comment\">// react基础</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"comment\">// redux基础</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'redux-thunk'</span>;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack配置</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    vendor: <span class=\"string\">'./path/to/vendor.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"DedupePlugin-和-OccurrenceOrderPlugin\"><a href=\"#DedupePlugin-和-OccurrenceOrderPlugin\" class=\"headerlink\" title=\"DedupePlugin 和 OccurrenceOrderPlugin\"></a>DedupePlugin 和 OccurrenceOrderPlugin</h4><p>在webpack1里经常会使用 <code>DedupePlugin</code> 插件来消除重复的模块以及使用 <code>OccurrenceOrderPlugin</code> 插件让被依赖次数更高的模块靠前分到更小的id 来达到输出更少的代码，在webpack2里这些已经这两个插件已经被移除了因为这些功能已经被内置了。</p>\n<p>除了压缩文本代码外还可以：</p>\n<ul>\n<li><strong>用<a href=\"https://github.com/Klathmon/imagemin-webpack-plugin\" target=\"_blank\" rel=\"noopener\">imagemin-webpack-plugin</a> 压缩图片</strong></li>\n<li><strong>用<a href=\"https://github.com/mixtur/webpack-spritesmith\" target=\"_blank\" rel=\"noopener\">webpack-spritesmith</a> 合并雪碧图</strong></li>\n<li><strong>对于支持es6的js运行环境使用<a href=\"https://github.com/babel/babili\" target=\"_blank\" rel=\"noopener\">babili</a></strong></li>\n</ul>\n<p>以上优化点只需要在构建用于生产环境代码的时候才使用，在开发环境时最好关闭因为它们很耗时。</p>\n<h1 id=\"优化开发体验\"><a href=\"#优化开发体验\" class=\"headerlink\" title=\"优化开发体验\"></a>优化开发体验</h1><p>优化开发体验主要从更快的构建和更方便的功能入手。</p>\n<h2 id=\"更快的构建\"><a href=\"#更快的构建\" class=\"headerlink\" title=\"更快的构建\"></a>更快的构建</h2><h4 id=\"缩小文件搜索范围\"><a href=\"#缩小文件搜索范围\" class=\"headerlink\" title=\"缩小文件搜索范围\"></a>缩小文件搜索范围</h4><p>webpack的<code>resolve.modules</code>配置模块库（通常是指node_modules）所在的位置，在js里出现<code>import &#39;redux&#39;</code>这样不是相对也不是绝对路径的写法时会去node_modules目录下找。但是默认的配置会采用向上递归搜索的方式去寻找node_modules，但通常项目目录里只有一个node_modules在项目根目录，为了减少搜索我们直接写明node_modules的全路径：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    resolve: &#123;</span><br><span class=\"line\">        modules: [path.resolve(__dirname, <span class=\"string\">'node_modules'</span>)]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>除此之外webpack配置loader时也可以缩小文件搜索范围。</p>\n<ul>\n<li>loader的test正则表达式也应该尽可能的简单，比如在你的项目里只有<code>.js</code>文件时就不要把test写成<code>/\\.jsx?$/</code></li>\n<li>loader使用include命中只需要处理的文件，比如babel-loader的这两个配置:</li>\n</ul>\n<p>只对项目目录下src目录里的代码进行babel编译<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">    include: path.resolve(__dirname, <span class=\"string\">'src'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>项目目录下的所有js都会进行babel编译，包括庞大的node_modules下的js<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"开启-babel-loader-缓存\"><a href=\"#开启-babel-loader-缓存\" class=\"headerlink\" title=\"开启 babel-loader 缓存\"></a>开启 babel-loader 缓存</h4><p>babel编译过程很耗时，好在babel-loader提供缓存编译结果选项，在重启webpack时不需要创新编译而是复用缓存结果减少编译流程。babel-loader缓存机制默认是关闭的，打开的配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">         loaders: [&#123;</span><br><span class=\"line\">                test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">                loader: <span class=\"string\">'babel-loader?cacheDirectory'</span>,</span><br><span class=\"line\">         &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用-alias\"><a href=\"#使用-alias\" class=\"headerlink\" title=\"使用 alias\"></a>使用 alias</h4><p><code>resolve.alias</code> 配置路径映射。<br>发布到npm的库大多数都包含两个目录，一个是放着cmd模块化的lib目录，一个是把所有文件合成一个文件的dist目录，多数的入口文件是指向lib里面下的。<br>默认情况下webpack会去读lib目录下的入口文件再去递归加载其它依赖的文件这个过程很耗时，alias配置可以让webpack直接使用dist目录的整体文件减少文件递归解析。配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      <span class=\"string\">'moment'</span>: <span class=\"string\">'moment/min/moment.min.js'</span>,</span><br><span class=\"line\">      <span class=\"string\">'react'</span>: <span class=\"string\">'react/dist/react.js'</span>,</span><br><span class=\"line\">      <span class=\"string\">'react-dom'</span>: <span class=\"string\">'react-dom/dist/react-dom.js'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用-noParse\"><a href=\"#使用-noParse\" class=\"headerlink\" title=\"使用 noParse\"></a>使用 noParse</h4><p><code>module.noParse</code> 配置哪些文件可以脱离webpack的解析。<br>有些库是自成一体不依赖其他库的没有使用模块化的，比如jquey、momentjs、chart.js，要使用它们必须整体全部引入。<br>webpack是模块化打包工具完全没有必要去解析这些文件的依赖，因为它们都不依赖其它文件体积也很庞大，要忽略它们配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    noParse: <span class=\"regexp\">/node_modules\\/(jquey|moment|chart\\.js)/</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>除此以外还有很多可以加速的方法：</p>\n<ul>\n<li><strong>使用<a href=\"https://github.com/amireh/happypack\" target=\"_blank\" rel=\"noopener\">happypack</a>多进程并行构建</strong></li>\n<li><strong>使用<a href=\"https://github.com/webpack/docs/wiki/list-of-plugins#dllplugin\" target=\"_blank\" rel=\"noopener\">DllPlugin</a>复用模块</strong></li>\n</ul>\n<h2 id=\"更方便的功能\"><a href=\"#更方便的功能\" class=\"headerlink\" title=\"更方便的功能\"></a>更方便的功能</h2><h4 id=\"模块热替换\"><a href=\"#模块热替换\" class=\"headerlink\" title=\"模块热替换\"></a>模块热替换</h4><p>模块热替换是指在开发的过程中修改代码后不用刷新页面直接把变化的模块替换到老模块让页面呈现出最新的效果。<br>webpack-dev-server内置模块热替换，配置起来也很方便，下面以react应用为例，步骤如下：</p>\n<ul>\n<li>在启动webpack-dev-server的时候带上<code>--hot</code>参数开启模块热替换，在开启<code>--hot</code>后针对css的变化是会自动热替换的，但是js涉及到复杂的逻辑还需要进一步配置。</li>\n<li>配置页面入口文件</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./app'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\trender(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span>/&gt;</span></span>,<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">run();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只在开发模式下配置模块热替换</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'./app'</span>, run);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当./app发生变化或者当./app依赖的文件发生变化时会把./app编译成一个模块去替换老的，替换完毕后重新执行run函数渲染出最新的效果。</p>\n<h4 id=\"自动生成html\"><a href=\"#自动生成html\" class=\"headerlink\" title=\"自动生成html\"></a>自动生成html</h4><p>webpack只做了资源打包的工作还缺少把这些加载到html里运行的功能，在庞大的app里手写html去加载这些资源是很繁琐易错的，我们需要自动正确的加载打包出的资源。<br>webpack原生不支持这个功能于是我做了一个插件 <a href=\"https://github.com/gwuhaolin/web-webpack-plugin\" target=\"_blank\" rel=\"noopener\">web-webpack-plugin</a><br>具体使用点开链接看<a href=\"https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md\" target=\"_blank\" rel=\"noopener\">详细文档</a>，使用大概如下：</p>\n<p><a href=\"https://github.com/gwuhaolin/web-webpack-plugin/tree/master/demo/out-html\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n<p>webpack配置<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        A: <span class=\"string\">'./a'</span>,</span><br><span class=\"line\">        B: <span class=\"string\">'./b'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> WebPlugin(&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 输出的html文件名称，必填，注意不要重名，重名会覆盖相互文件。</span></span><br><span class=\"line\">            filename: <span class=\"string\">'index.html'</span>,</span><br><span class=\"line\">            <span class=\"comment\">// 该html文件依赖的entry，必须是一个数组。依赖的资源的注入顺序按照数组的顺序。</span></span><br><span class=\"line\">            requires: [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>],</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>将会输出一个<code>index.html</code>文件，这个文件将会自动引入 entry <code>A</code> 和 <code>B</code> 生成的js文件，</p>\n<p>输出的html:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"A.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"B.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>输出的目录结构<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── A.js</span><br><span class=\"line\">├── B.js</span><br><span class=\"line\">└── index.html</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"管理多页面\"><a href=\"#管理多页面\" class=\"headerlink\" title=\"管理多页面\"></a>管理多页面</h4><p>虽然webpack适用于单页应用，但复杂的系统经常是由多个单页应用组成，每个页面一个功能模块。webpack给出了js打包方案但缺少管理多个页面的功能。 <a href=\"https://github.com/gwuhaolin/web-webpack-plugin\" target=\"_blank\" rel=\"noopener\">web-webpack-plugin</a>的<code>AutoWebPlugin</code>会自动的为你的系统里每个单页应用生成一个html入口页，这个入口会自动的注入当前单页应用依赖的资源，使用它你只需如下几行代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// ./src/pages/ 代表存放所有页面的根目录，这个目录下的每一个目录被看着是一个单页应用</span></span><br><span class=\"line\">    <span class=\"comment\">// 会为里面的每一个目录生成一个html入口</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> AutoWebPlugin(<span class=\"string\">'./src/pages/'</span>, &#123;</span><br><span class=\"line\">      <span class=\"comment\">//使用单页应用的html模版文件，这里你可以自定义配置</span></span><br><span class=\"line\">      template: <span class=\"string\">'./src/assets/template.html'</span>,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure></p>\n<p>查看web-webpack-plugin的<a href=\"https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#自动探测html入口-demo\" target=\"_blank\" rel=\"noopener\">文档了解更多</a></p>\n<h3 id=\"分析输出结果\"><a href=\"#分析输出结果\" class=\"headerlink\" title=\"分析输出结果\"></a>分析输出结果</h3><p>如果你对当前的配置输出或者构建速度不满意，webpack有一个工具叫做<a href=\"https://webpack.github.io/analyse/\" target=\"_blank\" rel=\"noopener\">webpack analyze</a> 以可视化的方式直观的分析构建，来进一步优化构建结果和速度。要使用它你需要在执行webpack的时候带上<code>--json --profile</code>2个参数，这代表让webpack把构建结果以json输出并带上构建性能信息，使用如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack --json --profile &gt; stats.json</span><br></pre></td></tr></table></figure></p>\n<p>会生产一个<code>stats.json</code>文件，再打开<a href=\"https://webpack.github.io/analyse/\" target=\"_blank\" rel=\"noopener\">webpack analyze</a> 上传这个文件开始分析。</p>\n<p><strong>最后附上这篇文章所讲到的<a href=\"https://gist.github.com/gwuhaolin/cebd252a23793e742e6acae90ab63e83\" target=\"_blank\" rel=\"noopener\">webpack整体的配置</a>，分为开发环境的<code>webpack.config.js</code>和生产环境的<code>webpack-dist.config.js</code></strong></p>\n<p><a href=\"http://wuhaolin.cn/2017/04/30/webpack2%20%E7%BB%88%E6%9E%81%E4%BC%98%E5%8C%96/\">阅读原文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://webpack.wuhaolin.cn/\" target=\"_blank\" rel=\"noopener\"><img src=\"http://ou8vcvyuy.bkt.clouddn.com/dive-into-webpack-for-blog.jpg\" alt=\"\"></a></p>\n<p>webpack是当下最流行的js打包工具，这得益于网页应用日益复杂和js模块化的流行。<a href=\"https://webpack.js.org\" target=\"_blank\" rel=\"noopener\">webpack2</a>增加了一些新特性也正式发布了一段时间，是时候告诉大家如何用webpack2优化你的构建让它构建出更小的文件尺寸和更好的开发体验。</p>\n<h1 id=\"优化输出\"><a href=\"#优化输出\" class=\"headerlink\" title=\"优化输出\"></a>优化输出</h1><p>打包结果更小可以让网页打开速度更快以及简约宽带。可以通过这以下几点做到</p>\n<h4 id=\"压缩css\"><a href=\"#压缩css\" class=\"headerlink\" title=\"压缩css\"></a>压缩css</h4><p><code>css-loader</code> 在webpack2里默认是没有开启压缩的，最后生成的css文件里有很多空格和tab，通过配置<br><code>css-loader?minimize</code>参数可以开启压缩输出最小的css。css的压缩实际是是通过<a href=\"http://cssnano.co\" target=\"_blank\" rel=\"noopener\">cssnano</a>实现的。</p>\n<h4 id=\"tree-shaking\"><a href=\"#tree-shaking\" class=\"headerlink\" title=\"tree-shaking\"></a>tree-shaking</h4><p>tree-shaking 是指借助es6 <code>import export</code> 语法静态性的特点来删掉export但是没有import过的东西。要让tree-shaking工作需要注意以下几点：</p>\n<ul>\n<li><p>配置babel让它在编译转化es6代码时不把<code>import export</code>转换为cmd的<code>module.export</code>，配置如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"presets\": [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"es2015\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"modules\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>大多数分布到npm的库里的代码都是es5的，但是也有部分库（redux,react-router等等）开始支持tree-shaking。这些库发布到npm里的代码即包含es5的又包含全采用了es6 <code>import export</code> 语法的代码。<br>拿redux库来说，npm下载到的目录结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── es</span><br><span class=\"line\">│   └── utils</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">│   └── utils</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其中lib目录里是编译出的es5代码，es目录里是编译出的采用<code>import export</code> 语法的es5代码，在redux的<code>package.json</code>文件里有这两个配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main&quot;: &quot;lib/index.js&quot;,</span><br><span class=\"line\">&quot;jsnext:main&quot;: &quot;es/index.js&quot;,</span><br></pre></td></tr></table></figure></p>\n<p>这是指这个库的入口文件的位置，所以要让webpack去读取es目录下的代码需要使用jsnext:main字段配置的入口，要做到这点webpack需要这样配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">\tresolve: &#123;</span><br><span class=\"line\">            mainFields: [<span class=\"string\">'jsnext:main'</span>,<span class=\"string\">'main'</span>],</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这会让webpack先使用jsnext:main字段，在没有时使用main字段。这样就可以优化支持tree-shaking的库。</p>\n<h4 id=\"优化-UglifyJsPlugin\"><a href=\"#优化-UglifyJsPlugin\" class=\"headerlink\" title=\"优化 UglifyJsPlugin\"></a>优化 UglifyJsPlugin</h4><p>webpack <code>--optimize-minimize</code> 选项会开启 UglifyJsPlugin来压缩输出的js，但是默认的UglifyJsPlugin配置并没有把代码压缩到最小输出的js里还是有注释和空格，需要覆盖默认的配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> UglifyJsPlugin(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 最紧凑的输出</span></span><br><span class=\"line\">    beautify: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 删除所有的注释</span></span><br><span class=\"line\">    comments: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    compress: &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在UglifyJs删除没有用到的代码时不输出警告  </span></span><br><span class=\"line\">      warnings: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 删除所有的 `console` 语句</span></span><br><span class=\"line\">      <span class=\"comment\">// 还可以兼容ie浏览器</span></span><br><span class=\"line\">      drop_console: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 内嵌定义了但是只用到一次的变量</span></span><br><span class=\"line\">      collapse_vars: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 提取出出现多次但是没有定义成变量去引用的静态值</span></span><br><span class=\"line\">      reduce_vars: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"定义环境变量-NODE-ENV-production\"><a href=\"#定义环境变量-NODE-ENV-production\" class=\"headerlink\" title=\"定义环境变量 NODE_ENV=production\"></a>定义环境变量 NODE_ENV=production</h4><p>很多库里（比如react）有部分代码是这样的：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(process.env.NODE_ENV !== <span class=\"string\">'production'</span>)&#123;</span><br><span class=\"line\"><span class=\"comment\">// 不是生产环境才需要用到的代码，比如控制台里看到的警告    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在环境变量 <code>NODE_ENV</code> 等于 <code>production</code> 的时候UglifyJs会认为if语句里的是死代码在压缩代码时删掉。</p>\n<h4 id=\"使用-CommonsChunkPlugin-抽取公共代码\"><a href=\"#使用-CommonsChunkPlugin-抽取公共代码\" class=\"headerlink\" title=\"使用 CommonsChunkPlugin 抽取公共代码\"></a>使用 CommonsChunkPlugin 抽取公共代码</h4><p><a href=\"https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin\" target=\"_blank\" rel=\"noopener\">CommonsChunkPlugin</a>可以提取出多个代码块都依赖的模块形成一个单独的模块。要发挥CommonsChunkPlugin的作用还需要浏览器缓存机制的配合。在应用有多个页面的场景下提取出所有页面公共的代码减少单个页面的代码，在不同页面之间切换时所有页面公共的代码之前被加载过而不必重新加载。这个方法可以非常有效的提升应用性能。</p>\n<h4 id=\"在生产环境按照文件内容md5打hash\"><a href=\"#在生产环境按照文件内容md5打hash\" class=\"headerlink\" title=\"在生产环境按照文件内容md5打hash\"></a>在生产环境按照文件内容md5打hash</h4><p>webpack编译在生产环境出来的js、css、图片、字体这些文件应该放到CDN上，再根据文件内容的md5命名文件，利用缓存机制用户只需要加载一次，第二次加载时就直接访问缓存。如果你之后有修改就会为对应的文件生产新的md5值。做到以上你需要这样配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    publicPath: CND_URL,</span><br><span class=\"line\">    filename: <span class=\"string\">'[name]_[chunkhash].js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>知道以上原理后我们还可以进一步优化：利用CommonsChunkPlugin提取出使用页面都依赖的基础运行环境。比如对于最常见的react体系你可以抽出基础库<code>react</code> <code>react-dom</code> <code>redux</code> <code>react-redux</code>到一个单独的文件而不是和其它文件放在一起打包为一个文件，这样做的好处是只要你不升级他们的版本这个文件永远不会被刷新。如果你把这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致浏览器重复下载这些包含基础库的代码。以上的配置为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vender.js 文件抽离基础库到单独的一个文件里防止跟随业务代码被刷新</span></span><br><span class=\"line\"><span class=\"comment\">// 所有页面都依赖的第三方库</span></span><br><span class=\"line\"><span class=\"comment\">// react基础</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"comment\">// redux基础</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'redux-thunk'</span>;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack配置</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    vendor: <span class=\"string\">'./path/to/vendor.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"DedupePlugin-和-OccurrenceOrderPlugin\"><a href=\"#DedupePlugin-和-OccurrenceOrderPlugin\" class=\"headerlink\" title=\"DedupePlugin 和 OccurrenceOrderPlugin\"></a>DedupePlugin 和 OccurrenceOrderPlugin</h4><p>在webpack1里经常会使用 <code>DedupePlugin</code> 插件来消除重复的模块以及使用 <code>OccurrenceOrderPlugin</code> 插件让被依赖次数更高的模块靠前分到更小的id 来达到输出更少的代码，在webpack2里这些已经这两个插件已经被移除了因为这些功能已经被内置了。</p>\n<p>除了压缩文本代码外还可以：</p>\n<ul>\n<li><strong>用<a href=\"https://github.com/Klathmon/imagemin-webpack-plugin\" target=\"_blank\" rel=\"noopener\">imagemin-webpack-plugin</a> 压缩图片</strong></li>\n<li><strong>用<a href=\"https://github.com/mixtur/webpack-spritesmith\" target=\"_blank\" rel=\"noopener\">webpack-spritesmith</a> 合并雪碧图</strong></li>\n<li><strong>对于支持es6的js运行环境使用<a href=\"https://github.com/babel/babili\" target=\"_blank\" rel=\"noopener\">babili</a></strong></li>\n</ul>\n<p>以上优化点只需要在构建用于生产环境代码的时候才使用，在开发环境时最好关闭因为它们很耗时。</p>\n<h1 id=\"优化开发体验\"><a href=\"#优化开发体验\" class=\"headerlink\" title=\"优化开发体验\"></a>优化开发体验</h1><p>优化开发体验主要从更快的构建和更方便的功能入手。</p>\n<h2 id=\"更快的构建\"><a href=\"#更快的构建\" class=\"headerlink\" title=\"更快的构建\"></a>更快的构建</h2><h4 id=\"缩小文件搜索范围\"><a href=\"#缩小文件搜索范围\" class=\"headerlink\" title=\"缩小文件搜索范围\"></a>缩小文件搜索范围</h4><p>webpack的<code>resolve.modules</code>配置模块库（通常是指node_modules）所在的位置，在js里出现<code>import &#39;redux&#39;</code>这样不是相对也不是绝对路径的写法时会去node_modules目录下找。但是默认的配置会采用向上递归搜索的方式去寻找node_modules，但通常项目目录里只有一个node_modules在项目根目录，为了减少搜索我们直接写明node_modules的全路径：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    resolve: &#123;</span><br><span class=\"line\">        modules: [path.resolve(__dirname, <span class=\"string\">'node_modules'</span>)]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>除此之外webpack配置loader时也可以缩小文件搜索范围。</p>\n<ul>\n<li>loader的test正则表达式也应该尽可能的简单，比如在你的项目里只有<code>.js</code>文件时就不要把test写成<code>/\\.jsx?$/</code></li>\n<li>loader使用include命中只需要处理的文件，比如babel-loader的这两个配置:</li>\n</ul>\n<p>只对项目目录下src目录里的代码进行babel编译<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">    include: path.resolve(__dirname, <span class=\"string\">'src'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>项目目录下的所有js都会进行babel编译，包括庞大的node_modules下的js<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"开启-babel-loader-缓存\"><a href=\"#开启-babel-loader-缓存\" class=\"headerlink\" title=\"开启 babel-loader 缓存\"></a>开启 babel-loader 缓存</h4><p>babel编译过程很耗时，好在babel-loader提供缓存编译结果选项，在重启webpack时不需要创新编译而是复用缓存结果减少编译流程。babel-loader缓存机制默认是关闭的，打开的配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">         loaders: [&#123;</span><br><span class=\"line\">                test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">                loader: <span class=\"string\">'babel-loader?cacheDirectory'</span>,</span><br><span class=\"line\">         &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用-alias\"><a href=\"#使用-alias\" class=\"headerlink\" title=\"使用 alias\"></a>使用 alias</h4><p><code>resolve.alias</code> 配置路径映射。<br>发布到npm的库大多数都包含两个目录，一个是放着cmd模块化的lib目录，一个是把所有文件合成一个文件的dist目录，多数的入口文件是指向lib里面下的。<br>默认情况下webpack会去读lib目录下的入口文件再去递归加载其它依赖的文件这个过程很耗时，alias配置可以让webpack直接使用dist目录的整体文件减少文件递归解析。配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      <span class=\"string\">'moment'</span>: <span class=\"string\">'moment/min/moment.min.js'</span>,</span><br><span class=\"line\">      <span class=\"string\">'react'</span>: <span class=\"string\">'react/dist/react.js'</span>,</span><br><span class=\"line\">      <span class=\"string\">'react-dom'</span>: <span class=\"string\">'react-dom/dist/react-dom.js'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用-noParse\"><a href=\"#使用-noParse\" class=\"headerlink\" title=\"使用 noParse\"></a>使用 noParse</h4><p><code>module.noParse</code> 配置哪些文件可以脱离webpack的解析。<br>有些库是自成一体不依赖其他库的没有使用模块化的，比如jquey、momentjs、chart.js，要使用它们必须整体全部引入。<br>webpack是模块化打包工具完全没有必要去解析这些文件的依赖，因为它们都不依赖其它文件体积也很庞大，要忽略它们配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    noParse: <span class=\"regexp\">/node_modules\\/(jquey|moment|chart\\.js)/</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>除此以外还有很多可以加速的方法：</p>\n<ul>\n<li><strong>使用<a href=\"https://github.com/amireh/happypack\" target=\"_blank\" rel=\"noopener\">happypack</a>多进程并行构建</strong></li>\n<li><strong>使用<a href=\"https://github.com/webpack/docs/wiki/list-of-plugins#dllplugin\" target=\"_blank\" rel=\"noopener\">DllPlugin</a>复用模块</strong></li>\n</ul>\n<h2 id=\"更方便的功能\"><a href=\"#更方便的功能\" class=\"headerlink\" title=\"更方便的功能\"></a>更方便的功能</h2><h4 id=\"模块热替换\"><a href=\"#模块热替换\" class=\"headerlink\" title=\"模块热替换\"></a>模块热替换</h4><p>模块热替换是指在开发的过程中修改代码后不用刷新页面直接把变化的模块替换到老模块让页面呈现出最新的效果。<br>webpack-dev-server内置模块热替换，配置起来也很方便，下面以react应用为例，步骤如下：</p>\n<ul>\n<li>在启动webpack-dev-server的时候带上<code>--hot</code>参数开启模块热替换，在开启<code>--hot</code>后针对css的变化是会自动热替换的，但是js涉及到复杂的逻辑还需要进一步配置。</li>\n<li>配置页面入口文件</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./app'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\trender(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span>/&gt;</span></span>,<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">run();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只在开发模式下配置模块热替换</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'./app'</span>, run);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当./app发生变化或者当./app依赖的文件发生变化时会把./app编译成一个模块去替换老的，替换完毕后重新执行run函数渲染出最新的效果。</p>\n<h4 id=\"自动生成html\"><a href=\"#自动生成html\" class=\"headerlink\" title=\"自动生成html\"></a>自动生成html</h4><p>webpack只做了资源打包的工作还缺少把这些加载到html里运行的功能，在庞大的app里手写html去加载这些资源是很繁琐易错的，我们需要自动正确的加载打包出的资源。<br>webpack原生不支持这个功能于是我做了一个插件 <a href=\"https://github.com/gwuhaolin/web-webpack-plugin\" target=\"_blank\" rel=\"noopener\">web-webpack-plugin</a><br>具体使用点开链接看<a href=\"https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md\" target=\"_blank\" rel=\"noopener\">详细文档</a>，使用大概如下：</p>\n<p><a href=\"https://github.com/gwuhaolin/web-webpack-plugin/tree/master/demo/out-html\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n<p>webpack配置<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        A: <span class=\"string\">'./a'</span>,</span><br><span class=\"line\">        B: <span class=\"string\">'./b'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> WebPlugin(&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 输出的html文件名称，必填，注意不要重名，重名会覆盖相互文件。</span></span><br><span class=\"line\">            filename: <span class=\"string\">'index.html'</span>,</span><br><span class=\"line\">            <span class=\"comment\">// 该html文件依赖的entry，必须是一个数组。依赖的资源的注入顺序按照数组的顺序。</span></span><br><span class=\"line\">            requires: [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>],</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>将会输出一个<code>index.html</code>文件，这个文件将会自动引入 entry <code>A</code> 和 <code>B</code> 生成的js文件，</p>\n<p>输出的html:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"A.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"B.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>输出的目录结构<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── A.js</span><br><span class=\"line\">├── B.js</span><br><span class=\"line\">└── index.html</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"管理多页面\"><a href=\"#管理多页面\" class=\"headerlink\" title=\"管理多页面\"></a>管理多页面</h4><p>虽然webpack适用于单页应用，但复杂的系统经常是由多个单页应用组成，每个页面一个功能模块。webpack给出了js打包方案但缺少管理多个页面的功能。 <a href=\"https://github.com/gwuhaolin/web-webpack-plugin\" target=\"_blank\" rel=\"noopener\">web-webpack-plugin</a>的<code>AutoWebPlugin</code>会自动的为你的系统里每个单页应用生成一个html入口页，这个入口会自动的注入当前单页应用依赖的资源，使用它你只需如下几行代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// ./src/pages/ 代表存放所有页面的根目录，这个目录下的每一个目录被看着是一个单页应用</span></span><br><span class=\"line\">    <span class=\"comment\">// 会为里面的每一个目录生成一个html入口</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> AutoWebPlugin(<span class=\"string\">'./src/pages/'</span>, &#123;</span><br><span class=\"line\">      <span class=\"comment\">//使用单页应用的html模版文件，这里你可以自定义配置</span></span><br><span class=\"line\">      template: <span class=\"string\">'./src/assets/template.html'</span>,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure></p>\n<p>查看web-webpack-plugin的<a href=\"https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#自动探测html入口-demo\" target=\"_blank\" rel=\"noopener\">文档了解更多</a></p>\n<h3 id=\"分析输出结果\"><a href=\"#分析输出结果\" class=\"headerlink\" title=\"分析输出结果\"></a>分析输出结果</h3><p>如果你对当前的配置输出或者构建速度不满意，webpack有一个工具叫做<a href=\"https://webpack.github.io/analyse/\" target=\"_blank\" rel=\"noopener\">webpack analyze</a> 以可视化的方式直观的分析构建，来进一步优化构建结果和速度。要使用它你需要在执行webpack的时候带上<code>--json --profile</code>2个参数，这代表让webpack把构建结果以json输出并带上构建性能信息，使用如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack --json --profile &gt; stats.json</span><br></pre></td></tr></table></figure></p>\n<p>会生产一个<code>stats.json</code>文件，再打开<a href=\"https://webpack.github.io/analyse/\" target=\"_blank\" rel=\"noopener\">webpack analyze</a> 上传这个文件开始分析。</p>\n<p><strong>最后附上这篇文章所讲到的<a href=\"https://gist.github.com/gwuhaolin/cebd252a23793e742e6acae90ab63e83\" target=\"_blank\" rel=\"noopener\">webpack整体的配置</a>，分为开发环境的<code>webpack.config.js</code>和生产环境的<code>webpack-dist.config.js</code></strong></p>\n<p><a href=\"http://wuhaolin.cn/2017/04/30/webpack2%20%E7%BB%88%E6%9E%81%E4%BC%98%E5%8C%96/\">阅读原文</a></p>\n"},{"title":"使用HeadlessChrome做单页应用SEO","date":"2017-06-27T03:59:22.000Z","url":"https://github.com/gwuhaolin/blog/issues/8","_content":"\n> 随着react、vue、angular等前端框架的流行越来越多的web应用变成了单页应用，它们的特点是异步拉取数据在浏览器中渲染出HTML。使用这些框架极大的提升web用户体验和开发效率的同时缺带来一个新问题，那就是这样的网页无法被搜索引擎收录。虽然这些web框架支持服务端渲染，但这可能又会增加开发成本。\n\n有没有一个可用于任何单页应用的SEO解决方案，让我们不用对代码做改变保持原有的开发效率？[chrome-render](https://github.com/gwuhaolin/chrome-render)可以帮我们做到这点，它通过控制HeadlessChrome渲染出最终的HTML返回给爬虫来实现。\n\n# HeadlessChrome介绍\n前不久chrome团队宣布chrome[支持headless模式](https://developers.google.com/web/updates/2017/04/headless-chrome)，HeadlessChrome支持chrome所具有的所有功能只不过因为不显示界面而更快资源占用更小。相比于之前的[phantomjs](http://phantomjs.org)(作者因为HeadlessChrome的推出而宣布停止维护)chrome的优势在于它又一个很强的爹(google)会一直维护它优化它，并且chrome在用户量、体验、速度、稳定性都是第一的，所以我认为HeadlessChrome会渐渐替代之前所有的HeadlessBrowser方案。\n\n### 如何操控HeadlessChrome\n既然HeadlessChrome是以无界面模式运行的，那要怎么控制它和它交互？\nchrome提供了远程控制接口，目前可以通过[chrome-remote-interface](https://github.com/cyrus-and/chrome-remote-interface)来用js代码向chrome发送命令进行交互。在启动chrome的时候要开启远程控制接口，然后通过 chrome-remote-interface 连接到chrome后再通过协议控制chrome。具体操作见文档：\n- [以headless模式和远程控制模式启动chrome](https://developers.google.com/web/updates/2017/04/headless-chrome)\n- [连接到远程chrome控制它](https://github.com/cyrus-and/chrome-remote-interface#sample-api-usage)\n- [控制chrome时支持哪些操作具体怎么用](https://chromedevtools.github.io/devtools-protocol/)\n\n# chrome-render原理与实践\n### 原理\nchrome-render先会通过[chrome-runner](https://github.com/gwuhaolin/chrome-runner)以headless模式启动和守护你操作上的chrome，再通过chrome-remote-interface操控chrome去访问需要被SEO的网页让chrome运行这个网页，等到包含数据的HTML被渲染出来时读取当前网页DOM转换成字符串后返回。\n\n怎么知道你的网页什么时候已经渲染出包含数据的HTML了可以返回了呢？为了提升chrome-render效率，默认会在`domContentEventFired`时返回。对于复杂的场景还可以通过开启chrome-render的`useReady`选项，等到网页里调用了`window.chromeRenderReady()`时返回。\n\n只渲染出了HTML还不够我们还需要检测出来着搜索引擎爬虫的访问，如果请求来着爬虫就返回chrome-render渲染后的HTML否则返回正常的单页应用所需HTML。\n\n综上，整体架构如下：\n![koa-seo arch](https://github.com/gwuhaolin/koa-seo/raw/master/doc/koa-seo%20arch.png)\n\n### 实践\n只需以下几行简单代码就可让chrome渲染出HTML：\n```js\nconst ChromeRender = require('chrome-render');\nChromeRender.new().then(async(chromeRender)=>{\n    const htmlString = await chromeRender.render({\n       url: 'http://qq.com',\n    });\n});    \n```\nchrome-render只是做了渲染出HTML的工作，要实现SEO还需要和web服务器集成。为了方便大家使用我做了一个koa中间件[koa-seo](https://github.com/gwuhaolin/koa-seo)，要集成到你现有的项目很简单，如下：\n```js\nconst seoMiddleware = require('koa-seo');\nconst app = new Koa();\napp.use(seoMiddleware());\n```\n只需像这样接入一个中间件你的单页应用就被SEO了。\n\n# 应用场景扩展\nchrome-render除了用于通用SEO解决方案其实可以用于通用服务端渲染，因为目的都是渲染出最终的HTML再返回。针对通用服务端渲染我也做了一个koa中间件[koa-chrome-render](https://github.com/gwuhaolin/koa-chrome-render)。使用chrome-render做服务端渲染的\n\n优势在于：\n- 通用，适用于所有单页应用\n- 对原有代码几乎无改动，最多再合适的地方加个`window.chromeRenderReady()`，保持原有开发效率\n\n缺点在于：\n- 和react、vue等只带的服务端渲染相比性能低（经我测试大约 200ms vs 60ms）\n- chrome-render渲染时占用资源高，一次渲染大约占用25Mb内存，当请求量大时服务器可能扛不住。但是可以通过缓存渲染结果优化。\n\n# 总结\n大家可能会说这个很像[prerender.io](https://prerender.io)，没错思路是一样的，chrome-render的优势在于：\n- chrome-render开源可自己部署，prerender要收费是商业产品\n- prerender基于已经停止维护的phantomjs\n\n本文中所提到的相关项目都是开源的并且有详细的使用文档，它们的文档链接如下：\n- [chrome-render](https://github.com/gwuhaolin/chrome-render)\n- [chrome-runner](https://github.com/gwuhaolin/chrome-runner)\n- [koa-seo](https://github.com/gwuhaolin/koa-seo)\n- [koa-chrome-render](https://github.com/gwuhaolin/koa-chrome-render)\n\n喜欢的给个star，希望大家和我一起来改进它们让它们更强大。\n\n\n[阅读原文](http://wuhaolin.cn/2017/06/27/%E4%BD%BF%E7%94%A8HeadlessChrome%E5%81%9A%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8SEO/)","source":"_posts/使用HeadlessChrome做单页应用SEO.md","raw":"---\ntitle: 使用HeadlessChrome做单页应用SEO\ndate: 2017-06-27T11:59:22Z\nurl: https://github.com/gwuhaolin/blog/issues/8\ntags:\n    - chrome\n---\n\n> 随着react、vue、angular等前端框架的流行越来越多的web应用变成了单页应用，它们的特点是异步拉取数据在浏览器中渲染出HTML。使用这些框架极大的提升web用户体验和开发效率的同时缺带来一个新问题，那就是这样的网页无法被搜索引擎收录。虽然这些web框架支持服务端渲染，但这可能又会增加开发成本。\n\n有没有一个可用于任何单页应用的SEO解决方案，让我们不用对代码做改变保持原有的开发效率？[chrome-render](https://github.com/gwuhaolin/chrome-render)可以帮我们做到这点，它通过控制HeadlessChrome渲染出最终的HTML返回给爬虫来实现。\n\n# HeadlessChrome介绍\n前不久chrome团队宣布chrome[支持headless模式](https://developers.google.com/web/updates/2017/04/headless-chrome)，HeadlessChrome支持chrome所具有的所有功能只不过因为不显示界面而更快资源占用更小。相比于之前的[phantomjs](http://phantomjs.org)(作者因为HeadlessChrome的推出而宣布停止维护)chrome的优势在于它又一个很强的爹(google)会一直维护它优化它，并且chrome在用户量、体验、速度、稳定性都是第一的，所以我认为HeadlessChrome会渐渐替代之前所有的HeadlessBrowser方案。\n\n### 如何操控HeadlessChrome\n既然HeadlessChrome是以无界面模式运行的，那要怎么控制它和它交互？\nchrome提供了远程控制接口，目前可以通过[chrome-remote-interface](https://github.com/cyrus-and/chrome-remote-interface)来用js代码向chrome发送命令进行交互。在启动chrome的时候要开启远程控制接口，然后通过 chrome-remote-interface 连接到chrome后再通过协议控制chrome。具体操作见文档：\n- [以headless模式和远程控制模式启动chrome](https://developers.google.com/web/updates/2017/04/headless-chrome)\n- [连接到远程chrome控制它](https://github.com/cyrus-and/chrome-remote-interface#sample-api-usage)\n- [控制chrome时支持哪些操作具体怎么用](https://chromedevtools.github.io/devtools-protocol/)\n\n# chrome-render原理与实践\n### 原理\nchrome-render先会通过[chrome-runner](https://github.com/gwuhaolin/chrome-runner)以headless模式启动和守护你操作上的chrome，再通过chrome-remote-interface操控chrome去访问需要被SEO的网页让chrome运行这个网页，等到包含数据的HTML被渲染出来时读取当前网页DOM转换成字符串后返回。\n\n怎么知道你的网页什么时候已经渲染出包含数据的HTML了可以返回了呢？为了提升chrome-render效率，默认会在`domContentEventFired`时返回。对于复杂的场景还可以通过开启chrome-render的`useReady`选项，等到网页里调用了`window.chromeRenderReady()`时返回。\n\n只渲染出了HTML还不够我们还需要检测出来着搜索引擎爬虫的访问，如果请求来着爬虫就返回chrome-render渲染后的HTML否则返回正常的单页应用所需HTML。\n\n综上，整体架构如下：\n![koa-seo arch](https://github.com/gwuhaolin/koa-seo/raw/master/doc/koa-seo%20arch.png)\n\n### 实践\n只需以下几行简单代码就可让chrome渲染出HTML：\n```js\nconst ChromeRender = require('chrome-render');\nChromeRender.new().then(async(chromeRender)=>{\n    const htmlString = await chromeRender.render({\n       url: 'http://qq.com',\n    });\n});    \n```\nchrome-render只是做了渲染出HTML的工作，要实现SEO还需要和web服务器集成。为了方便大家使用我做了一个koa中间件[koa-seo](https://github.com/gwuhaolin/koa-seo)，要集成到你现有的项目很简单，如下：\n```js\nconst seoMiddleware = require('koa-seo');\nconst app = new Koa();\napp.use(seoMiddleware());\n```\n只需像这样接入一个中间件你的单页应用就被SEO了。\n\n# 应用场景扩展\nchrome-render除了用于通用SEO解决方案其实可以用于通用服务端渲染，因为目的都是渲染出最终的HTML再返回。针对通用服务端渲染我也做了一个koa中间件[koa-chrome-render](https://github.com/gwuhaolin/koa-chrome-render)。使用chrome-render做服务端渲染的\n\n优势在于：\n- 通用，适用于所有单页应用\n- 对原有代码几乎无改动，最多再合适的地方加个`window.chromeRenderReady()`，保持原有开发效率\n\n缺点在于：\n- 和react、vue等只带的服务端渲染相比性能低（经我测试大约 200ms vs 60ms）\n- chrome-render渲染时占用资源高，一次渲染大约占用25Mb内存，当请求量大时服务器可能扛不住。但是可以通过缓存渲染结果优化。\n\n# 总结\n大家可能会说这个很像[prerender.io](https://prerender.io)，没错思路是一样的，chrome-render的优势在于：\n- chrome-render开源可自己部署，prerender要收费是商业产品\n- prerender基于已经停止维护的phantomjs\n\n本文中所提到的相关项目都是开源的并且有详细的使用文档，它们的文档链接如下：\n- [chrome-render](https://github.com/gwuhaolin/chrome-render)\n- [chrome-runner](https://github.com/gwuhaolin/chrome-runner)\n- [koa-seo](https://github.com/gwuhaolin/koa-seo)\n- [koa-chrome-render](https://github.com/gwuhaolin/koa-chrome-render)\n\n喜欢的给个star，希望大家和我一起来改进它们让它们更强大。\n\n\n[阅读原文](http://wuhaolin.cn/2017/06/27/%E4%BD%BF%E7%94%A8HeadlessChrome%E5%81%9A%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8SEO/)","slug":"使用HeadlessChrome做单页应用SEO","published":1,"updated":"2018-11-14T04:39:28.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjogs0ke60009g5tclurrlu10","content":"<blockquote>\n<p>随着react、vue、angular等前端框架的流行越来越多的web应用变成了单页应用，它们的特点是异步拉取数据在浏览器中渲染出HTML。使用这些框架极大的提升web用户体验和开发效率的同时缺带来一个新问题，那就是这样的网页无法被搜索引擎收录。虽然这些web框架支持服务端渲染，但这可能又会增加开发成本。</p>\n</blockquote>\n<p>有没有一个可用于任何单页应用的SEO解决方案，让我们不用对代码做改变保持原有的开发效率？<a href=\"https://github.com/gwuhaolin/chrome-render\" target=\"_blank\" rel=\"noopener\">chrome-render</a>可以帮我们做到这点，它通过控制HeadlessChrome渲染出最终的HTML返回给爬虫来实现。</p>\n<h1 id=\"HeadlessChrome介绍\"><a href=\"#HeadlessChrome介绍\" class=\"headerlink\" title=\"HeadlessChrome介绍\"></a>HeadlessChrome介绍</h1><p>前不久chrome团队宣布chrome<a href=\"https://developers.google.com/web/updates/2017/04/headless-chrome\" target=\"_blank\" rel=\"noopener\">支持headless模式</a>，HeadlessChrome支持chrome所具有的所有功能只不过因为不显示界面而更快资源占用更小。相比于之前的<a href=\"http://phantomjs.org\" target=\"_blank\" rel=\"noopener\">phantomjs</a>(作者因为HeadlessChrome的推出而宣布停止维护)chrome的优势在于它又一个很强的爹(google)会一直维护它优化它，并且chrome在用户量、体验、速度、稳定性都是第一的，所以我认为HeadlessChrome会渐渐替代之前所有的HeadlessBrowser方案。</p>\n<h3 id=\"如何操控HeadlessChrome\"><a href=\"#如何操控HeadlessChrome\" class=\"headerlink\" title=\"如何操控HeadlessChrome\"></a>如何操控HeadlessChrome</h3><p>既然HeadlessChrome是以无界面模式运行的，那要怎么控制它和它交互？<br>chrome提供了远程控制接口，目前可以通过<a href=\"https://github.com/cyrus-and/chrome-remote-interface\" target=\"_blank\" rel=\"noopener\">chrome-remote-interface</a>来用js代码向chrome发送命令进行交互。在启动chrome的时候要开启远程控制接口，然后通过 chrome-remote-interface 连接到chrome后再通过协议控制chrome。具体操作见文档：</p>\n<ul>\n<li><a href=\"https://developers.google.com/web/updates/2017/04/headless-chrome\" target=\"_blank\" rel=\"noopener\">以headless模式和远程控制模式启动chrome</a></li>\n<li><a href=\"https://github.com/cyrus-and/chrome-remote-interface#sample-api-usage\" target=\"_blank\" rel=\"noopener\">连接到远程chrome控制它</a></li>\n<li><a href=\"https://chromedevtools.github.io/devtools-protocol/\" target=\"_blank\" rel=\"noopener\">控制chrome时支持哪些操作具体怎么用</a></li>\n</ul>\n<h1 id=\"chrome-render原理与实践\"><a href=\"#chrome-render原理与实践\" class=\"headerlink\" title=\"chrome-render原理与实践\"></a>chrome-render原理与实践</h1><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>chrome-render先会通过<a href=\"https://github.com/gwuhaolin/chrome-runner\" target=\"_blank\" rel=\"noopener\">chrome-runner</a>以headless模式启动和守护你操作上的chrome，再通过chrome-remote-interface操控chrome去访问需要被SEO的网页让chrome运行这个网页，等到包含数据的HTML被渲染出来时读取当前网页DOM转换成字符串后返回。</p>\n<p>怎么知道你的网页什么时候已经渲染出包含数据的HTML了可以返回了呢？为了提升chrome-render效率，默认会在<code>domContentEventFired</code>时返回。对于复杂的场景还可以通过开启chrome-render的<code>useReady</code>选项，等到网页里调用了<code>window.chromeRenderReady()</code>时返回。</p>\n<p>只渲染出了HTML还不够我们还需要检测出来着搜索引擎爬虫的访问，如果请求来着爬虫就返回chrome-render渲染后的HTML否则返回正常的单页应用所需HTML。</p>\n<p>综上，整体架构如下：<br><img src=\"https://github.com/gwuhaolin/koa-seo/raw/master/doc/koa-seo%20arch.png\" alt=\"koa-seo arch\"></p>\n<h3 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h3><p>只需以下几行简单代码就可让chrome渲染出HTML：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ChromeRender = <span class=\"built_in\">require</span>(<span class=\"string\">'chrome-render'</span>);</span><br><span class=\"line\">ChromeRender.new().then(<span class=\"keyword\">async</span>(chromeRender)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> htmlString = <span class=\"keyword\">await</span> chromeRender.render(&#123;</span><br><span class=\"line\">       url: <span class=\"string\">'http://qq.com'</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>chrome-render只是做了渲染出HTML的工作，要实现SEO还需要和web服务器集成。为了方便大家使用我做了一个koa中间件<a href=\"https://github.com/gwuhaolin/koa-seo\" target=\"_blank\" rel=\"noopener\">koa-seo</a>，要集成到你现有的项目很简单，如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> seoMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-seo'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\">app.use(seoMiddleware());</span><br></pre></td></tr></table></figure></p>\n<p>只需像这样接入一个中间件你的单页应用就被SEO了。</p>\n<h1 id=\"应用场景扩展\"><a href=\"#应用场景扩展\" class=\"headerlink\" title=\"应用场景扩展\"></a>应用场景扩展</h1><p>chrome-render除了用于通用SEO解决方案其实可以用于通用服务端渲染，因为目的都是渲染出最终的HTML再返回。针对通用服务端渲染我也做了一个koa中间件<a href=\"https://github.com/gwuhaolin/koa-chrome-render\" target=\"_blank\" rel=\"noopener\">koa-chrome-render</a>。使用chrome-render做服务端渲染的</p>\n<p>优势在于：</p>\n<ul>\n<li>通用，适用于所有单页应用</li>\n<li>对原有代码几乎无改动，最多再合适的地方加个<code>window.chromeRenderReady()</code>，保持原有开发效率</li>\n</ul>\n<p>缺点在于：</p>\n<ul>\n<li>和react、vue等只带的服务端渲染相比性能低（经我测试大约 200ms vs 60ms）</li>\n<li>chrome-render渲染时占用资源高，一次渲染大约占用25Mb内存，当请求量大时服务器可能扛不住。但是可以通过缓存渲染结果优化。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>大家可能会说这个很像<a href=\"https://prerender.io\" target=\"_blank\" rel=\"noopener\">prerender.io</a>，没错思路是一样的，chrome-render的优势在于：</p>\n<ul>\n<li>chrome-render开源可自己部署，prerender要收费是商业产品</li>\n<li>prerender基于已经停止维护的phantomjs</li>\n</ul>\n<p>本文中所提到的相关项目都是开源的并且有详细的使用文档，它们的文档链接如下：</p>\n<ul>\n<li><a href=\"https://github.com/gwuhaolin/chrome-render\" target=\"_blank\" rel=\"noopener\">chrome-render</a></li>\n<li><a href=\"https://github.com/gwuhaolin/chrome-runner\" target=\"_blank\" rel=\"noopener\">chrome-runner</a></li>\n<li><a href=\"https://github.com/gwuhaolin/koa-seo\" target=\"_blank\" rel=\"noopener\">koa-seo</a></li>\n<li><a href=\"https://github.com/gwuhaolin/koa-chrome-render\" target=\"_blank\" rel=\"noopener\">koa-chrome-render</a></li>\n</ul>\n<p>喜欢的给个star，希望大家和我一起来改进它们让它们更强大。</p>\n<p><a href=\"http://wuhaolin.cn/2017/06/27/%E4%BD%BF%E7%94%A8HeadlessChrome%E5%81%9A%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8SEO/\">阅读原文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>随着react、vue、angular等前端框架的流行越来越多的web应用变成了单页应用，它们的特点是异步拉取数据在浏览器中渲染出HTML。使用这些框架极大的提升web用户体验和开发效率的同时缺带来一个新问题，那就是这样的网页无法被搜索引擎收录。虽然这些web框架支持服务端渲染，但这可能又会增加开发成本。</p>\n</blockquote>\n<p>有没有一个可用于任何单页应用的SEO解决方案，让我们不用对代码做改变保持原有的开发效率？<a href=\"https://github.com/gwuhaolin/chrome-render\" target=\"_blank\" rel=\"noopener\">chrome-render</a>可以帮我们做到这点，它通过控制HeadlessChrome渲染出最终的HTML返回给爬虫来实现。</p>\n<h1 id=\"HeadlessChrome介绍\"><a href=\"#HeadlessChrome介绍\" class=\"headerlink\" title=\"HeadlessChrome介绍\"></a>HeadlessChrome介绍</h1><p>前不久chrome团队宣布chrome<a href=\"https://developers.google.com/web/updates/2017/04/headless-chrome\" target=\"_blank\" rel=\"noopener\">支持headless模式</a>，HeadlessChrome支持chrome所具有的所有功能只不过因为不显示界面而更快资源占用更小。相比于之前的<a href=\"http://phantomjs.org\" target=\"_blank\" rel=\"noopener\">phantomjs</a>(作者因为HeadlessChrome的推出而宣布停止维护)chrome的优势在于它又一个很强的爹(google)会一直维护它优化它，并且chrome在用户量、体验、速度、稳定性都是第一的，所以我认为HeadlessChrome会渐渐替代之前所有的HeadlessBrowser方案。</p>\n<h3 id=\"如何操控HeadlessChrome\"><a href=\"#如何操控HeadlessChrome\" class=\"headerlink\" title=\"如何操控HeadlessChrome\"></a>如何操控HeadlessChrome</h3><p>既然HeadlessChrome是以无界面模式运行的，那要怎么控制它和它交互？<br>chrome提供了远程控制接口，目前可以通过<a href=\"https://github.com/cyrus-and/chrome-remote-interface\" target=\"_blank\" rel=\"noopener\">chrome-remote-interface</a>来用js代码向chrome发送命令进行交互。在启动chrome的时候要开启远程控制接口，然后通过 chrome-remote-interface 连接到chrome后再通过协议控制chrome。具体操作见文档：</p>\n<ul>\n<li><a href=\"https://developers.google.com/web/updates/2017/04/headless-chrome\" target=\"_blank\" rel=\"noopener\">以headless模式和远程控制模式启动chrome</a></li>\n<li><a href=\"https://github.com/cyrus-and/chrome-remote-interface#sample-api-usage\" target=\"_blank\" rel=\"noopener\">连接到远程chrome控制它</a></li>\n<li><a href=\"https://chromedevtools.github.io/devtools-protocol/\" target=\"_blank\" rel=\"noopener\">控制chrome时支持哪些操作具体怎么用</a></li>\n</ul>\n<h1 id=\"chrome-render原理与实践\"><a href=\"#chrome-render原理与实践\" class=\"headerlink\" title=\"chrome-render原理与实践\"></a>chrome-render原理与实践</h1><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>chrome-render先会通过<a href=\"https://github.com/gwuhaolin/chrome-runner\" target=\"_blank\" rel=\"noopener\">chrome-runner</a>以headless模式启动和守护你操作上的chrome，再通过chrome-remote-interface操控chrome去访问需要被SEO的网页让chrome运行这个网页，等到包含数据的HTML被渲染出来时读取当前网页DOM转换成字符串后返回。</p>\n<p>怎么知道你的网页什么时候已经渲染出包含数据的HTML了可以返回了呢？为了提升chrome-render效率，默认会在<code>domContentEventFired</code>时返回。对于复杂的场景还可以通过开启chrome-render的<code>useReady</code>选项，等到网页里调用了<code>window.chromeRenderReady()</code>时返回。</p>\n<p>只渲染出了HTML还不够我们还需要检测出来着搜索引擎爬虫的访问，如果请求来着爬虫就返回chrome-render渲染后的HTML否则返回正常的单页应用所需HTML。</p>\n<p>综上，整体架构如下：<br><img src=\"https://github.com/gwuhaolin/koa-seo/raw/master/doc/koa-seo%20arch.png\" alt=\"koa-seo arch\"></p>\n<h3 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h3><p>只需以下几行简单代码就可让chrome渲染出HTML：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ChromeRender = <span class=\"built_in\">require</span>(<span class=\"string\">'chrome-render'</span>);</span><br><span class=\"line\">ChromeRender.new().then(<span class=\"keyword\">async</span>(chromeRender)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> htmlString = <span class=\"keyword\">await</span> chromeRender.render(&#123;</span><br><span class=\"line\">       url: <span class=\"string\">'http://qq.com'</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>chrome-render只是做了渲染出HTML的工作，要实现SEO还需要和web服务器集成。为了方便大家使用我做了一个koa中间件<a href=\"https://github.com/gwuhaolin/koa-seo\" target=\"_blank\" rel=\"noopener\">koa-seo</a>，要集成到你现有的项目很简单，如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> seoMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-seo'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\">app.use(seoMiddleware());</span><br></pre></td></tr></table></figure></p>\n<p>只需像这样接入一个中间件你的单页应用就被SEO了。</p>\n<h1 id=\"应用场景扩展\"><a href=\"#应用场景扩展\" class=\"headerlink\" title=\"应用场景扩展\"></a>应用场景扩展</h1><p>chrome-render除了用于通用SEO解决方案其实可以用于通用服务端渲染，因为目的都是渲染出最终的HTML再返回。针对通用服务端渲染我也做了一个koa中间件<a href=\"https://github.com/gwuhaolin/koa-chrome-render\" target=\"_blank\" rel=\"noopener\">koa-chrome-render</a>。使用chrome-render做服务端渲染的</p>\n<p>优势在于：</p>\n<ul>\n<li>通用，适用于所有单页应用</li>\n<li>对原有代码几乎无改动，最多再合适的地方加个<code>window.chromeRenderReady()</code>，保持原有开发效率</li>\n</ul>\n<p>缺点在于：</p>\n<ul>\n<li>和react、vue等只带的服务端渲染相比性能低（经我测试大约 200ms vs 60ms）</li>\n<li>chrome-render渲染时占用资源高，一次渲染大约占用25Mb内存，当请求量大时服务器可能扛不住。但是可以通过缓存渲染结果优化。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>大家可能会说这个很像<a href=\"https://prerender.io\" target=\"_blank\" rel=\"noopener\">prerender.io</a>，没错思路是一样的，chrome-render的优势在于：</p>\n<ul>\n<li>chrome-render开源可自己部署，prerender要收费是商业产品</li>\n<li>prerender基于已经停止维护的phantomjs</li>\n</ul>\n<p>本文中所提到的相关项目都是开源的并且有详细的使用文档，它们的文档链接如下：</p>\n<ul>\n<li><a href=\"https://github.com/gwuhaolin/chrome-render\" target=\"_blank\" rel=\"noopener\">chrome-render</a></li>\n<li><a href=\"https://github.com/gwuhaolin/chrome-runner\" target=\"_blank\" rel=\"noopener\">chrome-runner</a></li>\n<li><a href=\"https://github.com/gwuhaolin/koa-seo\" target=\"_blank\" rel=\"noopener\">koa-seo</a></li>\n<li><a href=\"https://github.com/gwuhaolin/koa-chrome-render\" target=\"_blank\" rel=\"noopener\">koa-chrome-render</a></li>\n</ul>\n<p>喜欢的给个star，希望大家和我一起来改进它们让它们更强大。</p>\n<p><a href=\"http://wuhaolin.cn/2017/06/27/%E4%BD%BF%E7%94%A8HeadlessChrome%E5%81%9A%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8SEO/\">阅读原文</a></p>\n"},{"title":"你也能写个 Shadowsocks","date":"2017-11-03T03:24:28.000Z","url":"https://github.com/gwuhaolin/blog/issues/12","_content":"\n本文将教你从0写一个[Shadowsocks](https://github.com/shadowsocks/shadowsocks-go)，无需任何基础，读完本文你就能完成一个轻量级、高性能的 Shadowsocks 代替品。\n\n我们暂且把最终完成的项目叫做 Lightsocks，如果你很急切地想看到结果，可以先体验本文最终完成的项目 [Lightsocks](https://github.com/gwuhaolin/lightsocks) ，也可以下载阅读源码。\n\n## 认识 Shadowsocks\nShadowsocks 是一个能骗过防火墙的网络代理工具。它把要传输的原数据经过加密后再传输，网络中的防火墙由于得不出要传输的原内容是什么而只好放行，于是就完成了防火墙穿透，也即是所谓的“翻墙”。\n\n在自由的网络环境下，在本机上访问服务时是直接和远程服务建立连接传输数据，流程如图：\n![自由网络环境下的传输流程](https://user-images.githubusercontent.com/5773264/32371367-8c231024-c05e-11e7-87a8-f977577a6b89.png)\n\n但在受限的网络环境下会有防火墙，本机电脑和远程服务之间传输的数据都必须通过防火墙的检查，流程如图：\n![受限网络环境下的传输流程](https://user-images.githubusercontent.com/5773264/32371437-d8cb8852-c05e-11e7-9872-a6708bbe65ba.png)\n如果防火墙发现你在传输受限的内容，就把拦截本次传输，就会导致在本机无法访问远程服务。\n\n而 Shadowsocks 所做的就是把传输的数据加密，防火墙得到的数据是加密后的数据，防火墙不知道传输的原内容是什么，于是防火墙就放行本次请求，于是在本机就访问到了远程服务，流程如图：\n![shadowsocks下的传输流程](https://user-images.githubusercontent.com/5773264/32371932-cdc55044-c060-11e7-9b0e-c1a7fec2b428.png)\n\n也就是说使用 Shadowsocks 的前提是：\n- 一台在防火墙之外的服务器；\n- 在本机需要安装 Shadowsocks 本地端，用于加密传输数据；\n- 服务器需要安装 Shadowsocks 服务端，用于解密加密后的传输数据，解密出原数据后发送到目标服务器。\n\n## Shadowsocks 原理\nShadowsocks 由两部分组成，运行在本地的 ss-local 和运行在防火墙之外服务器上的 ss-server，下面来分别详细介绍它们的职责（以下对 Shadowsocks 原理的解析只是我的大概估计，可能会有细微的差别）。\n\n#### ss-local\nss-local 的职责是在本机启动和监听着一个服务，本地软件的网络请求都先发送到 ss-local，ss-local 收到来自本地软件的网络请求后，把要传输的原数据根据用户配置的加密方法和密码进行加密，再转发到墙外的服务器去。\n\n#### ss-server\nss-server 的职责是在墙外服务器启动和监听一个服务，该服务监听来自本机的 ss-local 的请求。在收到来自 ss-local 转发过来的数据时，会先根据用户配置的加密方法和密码对数据进行对称解密，以获得加密后的数据的原内容。同时还会解 SOCKS5 协议，读出本次请求真正的目标服务地址(例如 Google 服务器地址)，再把解密后得到的原数据转发到真正的目标服务。\n\n当真正的目标服务返回了数据时，ss-server 端会把返回的数据加密后转发给对应的 ss-local 端，ss-local 端收到数据再解密后，转发给本机的软件。这是一个对称相反的过程。\n\n由于 ss-local 和 ss-server 端都需要用对称加密算法对数据进行加密和解密，因此这两端的加密方法和密码必须配置为一样。Shadowsocks 提供了一系列标准可靠的对称算法可供用户选择，例如 rc4、aes、des、chacha20 等等。Shadowsocks 对数据加密后再传输的目的是为了混淆原数据，让途中的防火墙无法得出传输的原数据。但其实用这些安全性高计算量大的对称加密算法去实现混淆有点“杀鸡用牛刀”。\n\n## SOCKS5 协议介绍\nShadowsocks 的数据传输是建立在 SOCKS5 协议之上的，SOCKS5 是 TCP/IP 层面的网络代理协议。\nss-server 端解密出来的数据就是采用 SOCKS5 协议封装的，通过 SOCKS5 协议 ss-server 端能读出本机软件想访问的服务的真正地址以及要传输的原数据，下面来详细介绍  SOCKS5 协议的通信细节。\n\n#### 建立连接\n客户端向服务端连接连接，客户端发送的数据包如下：\n\n| VER | NMETHODS | METHODS |\n| --- | --- | --- |\n| 1 | 1 | 1 |\n\n其中各个字段的含义如下：\n-`VER`：代表 SOCKS 的版本，SOCKS5 默认为`0x05`，其固定长度为1个字节；\n-`NMETHODS`：表示第三个字段METHODS的长度，它的长度也是1个字节；\n-`METHODS`：表示客户端支持的验证方式，可以有多种，他的长度是1-255个字节。\n\n目前支持的验证方式共有：\n- `0x00`：NO AUTHENTICATION REQUIRED（不需要验证）\n- `0x01`：GSSAPI\n- `0x02`：USERNAME/PASSWORD（用户名密码）\n- `0x03`: to X'7F' IANA ASSIGNED\n- `0x80`: to X'FE' RESERVED FOR PRIVATE METHODS\n- `0xFF`: NO ACCEPTABLE METHODS（都不支持，没法连接了）\n\n#### 响应连接\n服务端收到客户端的验证信息之后，就要回应客户端，服务端需要客户端提供哪种验证方式的信息。服务端回应的包格式如下：\n\n| VER | METHOD |\n| --- | --- |\n| 1 | 1 |\n\n其中各个字段的含义如下：\n- `VER`：代表 SOCKS 的版本，SOCKS5 默认为`0x05`，其固定长度为1个字节；\n- `METHOD`：代表服务端需要客户端按此验证方式提供的验证信息，其值长度为1个字节，可为上面六种验证方式之一。\n\n举例说明，比如服务端不需要验证的话，可以这么回应客户端：\n\n| VER | METHOD |\n| --- | --- |\n| `0x05` | `0x00` |\n\n#### 和目标服务建立连接\n客户端发起的连接由服务端验证通过后，客户端下一步应该告诉真正目标服务的地址给服务器，服务器得到地址后再去请求真正的目标服务。也就是说客户端需要把 Google 服务的地址`google.com:80`告诉服务端，服务端再去请求`google.com:80`。\n目标服务地址的格式为 (IP或域名)+端口，客户端需要发送的包格式如下：\n\n| VER | CMD | RSV | ATYP | DST.ADDR | DST.PORT |\n| -- | -- | -- | -- | -- | -- |\n| 1 | 1 | `0x00` | 1 | Variable | 2 |\n\n各个字段的含义如下：\n- `VER`：代表 SOCKS 协议的版本，SOCKS 默认为0x05，其值长度为1个字节；\n- `CMD`：代表客户端请求的类型，值长度也是1个字节，有三种类型；\n  - `CONNECT`： `0x01`；\n  - `BIND`： `0x02`；\n  - `UDP`： ASSOCIATE `0x03`；\n- `RSV`：保留字，值长度为1个字节；\n- `ATYP`：代表请求的远程服务器地址类型，值长度1个字节，有三种类型；\n  - `IPV4`： address: `0x01`；\n  - `DOMAINNAME`: `0x03`；\n  - `IPV6`： address: `0x04`；\n- `DST.ADDR`：代表远程服务器的地址，根据 `ATYP` 进行解析，值长度不定；\n- `DST.PORT`：代表远程服务器的端口，要访问哪个端口的意思，值长度2个字节。\n\n服务端在得到来自客户端告诉的目标服务地址后，便和目标服务进行连接，不管连接成功与否，服务器都应该把连接的结果告诉客户端。在连接成功的情况下，服务端返回的包格式如下：\n\n| VER | REP | RSV | ATYP | BND.ADDR | BND.PORT\n| -- | -- | -- | -- | -- | -- |\n| 1 | 1 | `0x00` | 1 | Variable | 2 |\n\n各个字段的含义如下：\n- `VER`：代表 SOCKS 协议的版本，SOCKS 默认为0x05，其值长度为1个字节；\n- REP代表响应状态码，值长度也是1个字节，有以下几种类型\n  - `0x00` succeeded\n  - `0x01` general SOCKS server failure\n  - `0x02` connection not allowed by ruleset\n  - `0x03` Network unreachable\n  - `0x04` Host unreachable\n  - `0x05` Connection refused\n  - `0x06` TTL expired\n  - `0x07` Command not supported\n  - `0x08` Address type not supported\n  - `0x09` to `0xFF` unassigned\n- `RSV`：保留字，值长度为1个字节\n- `ATYP`：代表请求的远程服务器地址类型，值长度1个字节，有三种类型\n  - IP V4 address： `0x01`\n  - DOMAINNAME： `0x03`\n  - IP V6 address： `0x04`\n- `BND.ADDR`：表示绑定地址，值长度不定。\n- `BND.PORT`： 表示绑定端口，值长度2个字节\n\n#### 数据转发\n客户端在收到来自服务器成功的响应后，就会开始发送数据了，服务端在收到来自客户端的数据后，会转发到目标服务。\n\n#### 总结\nSOCKS5 协议的目的其实就是为了把来自原本应该在本机直接请求目标服务的流程，放到了服务端去代理客户端访问。\n其运行流程总结如下：\n\n1. 本机和代理服务端协商和建立连接；\n2. 本机告诉代理服务端目标服务的地址；\n3. 代理服务端去连接目标服务，成功后告诉本机；\n4. 本机开始发送原本应发送到目标服务的数据给代理服务端，由代理服务端完成数据转发。\n\n以上内容来自 [SOCKS5 协议规范 rfc1928](http://www.ietf.org/rfc/rfc1928.txt)。\n\n## [Lightsocks](https://github.com/gwuhaolin/lightsocks) 实现\n要实现 Lightsocks 需要实现两部分：运行在本地的 lightsocks-local，和运行在墙外代理服务器上 lightsocks-server。\n下面来分别教你如果使用 Golang 来实现它们，采用 Golang 语言的原因在于：性能好、跨平台、适合高并发、学习门槛低。对Golang感兴趣？请看[Golang 中文学习资料汇总](http://go.wuhaolin.cn/)\n\n#### 实现数据混淆\n在 Shadowsocks 中是采用的标准的对称加密算法去实现数据混淆的，对称算法在加密和解密过程中需要大量计算。\n为了简单起见，Lightsocks 将采用最简单高效的方法去实现数据混淆，具体原理如下。\n\n这个数据混淆算法和对称加密很相似，两端都需要有同样的密钥。\n这个密钥有如下要求：\n- 由256个 byte 组成，也就是一个数组，在 Golang 中类型表示为 `[256]byte`；\n- 这个数组必须由 0～255 这256个数字组成，一个都不能差；\n- 这个数组中第`I`个的值不能等于`I`；\n\n例如以下为一个合法的密钥(上为索引，下为值)：\n\n|0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 91 | 92 | 93 | 94 | 95 | 96 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 123 | 124 | 125 | 126 | 127 | 128 | 129 | 130 | 131 | 132 | 133 | 134 | 135 | 136 | 137 | 138 | 139 | 140 | 141 | 142 | 143 | 144 | 145 | 146 | 147 | 148 | 149 | 150 | 151 | 152 | 153 | 154 | 155 | 156 | 157 | 158 | 159 | 160 | 161 | 162 | 163 | 164 | 165 | 166 | 167 | 168 | 169 | 170 | 171 | 172 | 173 | 174 | 175 | 176 | 177 | 178 | 179 | 180 | 181 | 182 | 183 | 184 | 185 | 186 | 187 | 188 | 189 | 190 | 191 | 192 | 193 | 194 | 195 | 196 | 197 | 198 | 199 | 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214 | 215 | 216 | 217 | 218 | 219 | 220 | 221 | 222 | 223 | 224 | 225 | 226 | 227 | 228 | 229 | 230 | 231 | 232 | 233 | 234 | 235 | 236 | 237 | 238 | 239 | 240 | 241 | 242 | 243 | 244 | 245 | 246 | 247 | 248 | 249 | 250 | 251 | 252 | 253 | 254 | 255 |\n|--- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n|186 | 118 | 82 | 201 | 235 | 236 | 180 | 66 | 228 | 96 | 43 | 90 | 203 | 200 | 34 | 104 | 41 | 222 | 165 | 74 | 240 | 20 | 244 | 67 | 114 | 191 | 220 | 147 | 196 | 183 | 229 | 123 | 208 | 19 | 127 | 187 | 84 | 148 | 56 | 170 | 133 | 160 | 202 | 21 | 53 | 78 | 59 | 64 | 120 | 27 | 167 | 175 | 39 | 10 | 4 | 132 | 89 | 230 | 152 | 73 | 221 | 88 | 141 | 158 | 251 | 79 | 225 | 87 | 14 | 23 | 68 | 250 | 199 | 168 | 218 | 60 | 40 | 169 | 75 | 86 | 153 | 134 | 83 | 49 | 128 | 231 | 217 | 239 | 226 | 177 | 57 | 24 | 234 | 63 | 7 | 112 | 166 | 211 | 254 | 179 | 157 | 215 | 227 | 224 | 233 | 81 | 172 | 26 | 122 | 219 | 48 | 151 | 232 | 50 | 108 | 44 | 0 | 192 | 65 | 76 | 109 | 252 | 248 | 47 | 154 | 33 | 209 | 115 | 31 | 15 | 45 | 206 | 247 | 124 | 77 | 8 | 182 | 144 | 1 | 72 | 131 | 52 | 245 | 198 | 238 | 5 | 188 | 116 | 55 | 216 | 155 | 2 | 178 | 189 | 162 | 136 | 243 | 184 | 58 | 69 | 70 | 99 | 36 | 25 | 35 | 174 | 195 | 18 | 205 | 30 | 190 | 142 | 210 | 113 | 145 | 101 | 97 | 161 | 100 | 91 | 242 | 138 | 93 | 171 | 98 | 237 | 212 | 255 | 80 | 102 | 119 | 204 | 107 | 105 | 111 | 11 | 29 | 146 | 129 | 117 | 135 | 176 | 163 | 207 | 103 | 22 | 246 | 125 | 150 | 106 | 126 | 197 | 249 | 62 | 51 | 193 | 32 | 3 | 110 | 46 | 85 | 71 | 159 | 139 | 12 | 164 | 95 | 121 | 140 | 241 | 253 | 130 | 173 | 213 | 54 | 143 | 16 | 94 | 9 | 61 | 156 | 214 | 28 | 17 | 37 | 42 | 181 | 149 | 185 | 223 | 92 | 38 | 13 | 194 | 6 | 137 |\n\n\n如果原数据为 `[5,0,1,2,3]`，则采用以上密钥加密后变成 `[236,186,118,82,201]`。\n如果加密后的数据为 `[186,118,82,201,235]`，则采用以上密钥解密得到的原数据为 `[0,1,2,3,4]`\n\n聪明的你肯定看懂了其中的规律：把1～255 这256个数字确定一种一对一的映射关系，加密是从一个数字得到对应的一个数字，而解密则是反向的过程，而这个密钥的作用正是描述这个映射关系。\n这其实就是中学学的**反函数**。\n\n为什么要这样设计数据混淆算法呢？在数据传输时，数据是以 byte 为最小单位流式传输的。一个 byte 的取值只可能是 0～255。该混淆算法可以直接对一个个 byte 进行加解密，而无需像标准的对称算法那样只能对一大块数据进行加密。\n再加上本算法的加解密 N byte 数据的算法复杂度为 N（直接通过数组索引访问），非常适合流式加密。\n\n以上加密算法的安全性怎么样呢？符合以上要求的密钥匙有多少种组合呢？我们来算算：\n这其实就是初中学的排列组合中的排列问题，形象点其实就是，把 0～255 个不同编号的人安排到 0～255 个不同编号的坑去，并且不能有编号一样的情况，有多少种排法。\n也就是 `A(255,255)=255*254*253*...*1=255!`，但其中有一半为有重复的情况，\n最终结果为 `255!/2`，\n其值大概为 `10^500` 这个数量级。\n\n以上加密算法虽然破绽很多，但足以实现高效的数据混淆，骗过防火墙。\n\n目前采用对称加密算法实现数据混淆的 Shadowsocks 已经能被一些防火墙通过机器学习算法通过特征分析识别出传输的原内容适合合法，而 Lightsocks 的这套混淆算法目前还不能被轻易的识别出来。\n\n随机产生一个以上密钥匙的[代码如下](https://github.com/gwuhaolin/lightsocks/blob/master/core/password.go)：\n```go\npackage core\nimport (\n\t\"math/rand\"\n\t\"time\"\n)\nconst PasswordLength = 256\ntype Password [PasswordLength]byte\n\nfunc init() {\n\t// 更新随机种子，防止生成一样的随机密码\n\trand.Seed(time.Now().Unix())\n}\n\n// 产生 256个byte随机组合的 密码\nfunc RandPassword() *Password {\n\t// 随机生成一个由  0~255 组成的 byte 数组\n\tintArr := rand.Perm(PasswordLength)\n\tpassword := &Password{}\n\tfor i, v := range intArr {\n\t\tpassword[i] = byte(v)\n\t\tif i == v {\n\t\t\t// 确保不会出现如何一个byte位出现重复\n\t\t\treturn RandPassword()\n\t\t}\n\t}\n\treturn password\n}\n```\n\n对数据进行加密解密的[代码如下](https://github.com/gwuhaolin/lightsocks/blob/master/core/cipher.go)：\n```go\npackage core\n\ntype Cipher struct {\n\t// 编码用的密码\n\tencodePassword *Password\n\t// 解码用的密码\n\tdecodePassword *Password\n}\n\n// 加密原数据\nfunc (cipher *Cipher) encode(bs []byte) {\n\tfor i, v := range bs {\n\t\tbs[i] = cipher.encodePassword[v]\n\t}\n}\n\n// 解码加密后的数据到原数据\nfunc (cipher *Cipher) decode(bs []byte) {\n\tfor i, v := range bs {\n\t\tbs[i] = cipher.decodePassword[v]\n\t}\n}\n\n// 新建一个编码解码器\nfunc NewCipher(encodePassword *Password) *Cipher {\n\tdecodePassword := &Password{}\n\tfor i, v := range encodePassword {\n\t\tencodePassword[i] = v\n\t\tdecodePassword[v] = byte(i)\n\t}\n\treturn &Cipher{\n\t\tencodePassword: encodePassword,\n\t\tdecodePassword: decodePassword,\n\t}\n}\n```\n\n再使用以上的 Cipher 去封装一个加密传输的 SecureSocket，以方便直接加解密 TCP Socket 中的流式数据，[代码如下](https://github.com/gwuhaolin/lightsocks/blob/master/core/securesocket.go)：\n```go\npackage core\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n)\n\nconst (\n\tBufSize = 1024\n)\n\n// 加密传输的 TCP Socket\ntype SecureSocket struct {\n\tCipher     *Cipher\n\tListenAddr *net.TCPAddr\n\tRemoteAddr *net.TCPAddr\n}\n\n// 从输入流里读取加密过的数据，解密后把原数据放到bs里\nfunc (secureSocket *SecureSocket) DecodeRead(conn *net.TCPConn, bs []byte) (n int, err error) {\n\tn, err = conn.Read(bs)\n\tif err != nil {\n\t\treturn\n\t}\n\tsecureSocket.Cipher.decode(bs[:n])\n\treturn\n}\n\n// 把放在bs里的数据加密后立即全部写入输出流\nfunc (secureSocket *SecureSocket) EncodeWrite(conn *net.TCPConn, bs []byte) (int, error) {\n\tsecureSocket.Cipher.encode(bs)\n\treturn conn.Write(bs)\n}\n\n// 从src中源源不断的读取原数据加密后写入到dst，直到src中没有数据可以再读取\nfunc (secureSocket *SecureSocket) EncodeCopy(dst *net.TCPConn, src *net.TCPConn) error {\n\tbuf := make([]byte, BufSize)\n\tfor {\n\t\treadCount, errRead := src.Read(buf)\n\t\tif errRead != nil {\n\t\t\tif errRead != io.EOF {\n\t\t\t\treturn errRead\n\t\t\t} else {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tif readCount > 0 {\n\t\t\twriteCount, errWrite := secureSocket.EncodeWrite(dst, buf[0:readCount])\n\t\t\tif errWrite != nil {\n\t\t\t\treturn errWrite\n\t\t\t}\n\t\t\tif readCount != writeCount {\n\t\t\t\treturn io.ErrShortWrite\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 从src中源源不断的读取加密后的数据解密后写入到dst，直到src中没有数据可以再读取\nfunc (secureSocket *SecureSocket) DecodeCopy(dst *net.TCPConn, src *net.TCPConn) error {\n\tbuf := make([]byte, BufSize)\n\tfor {\n\t\treadCount, errRead := secureSocket.DecodeRead(src, buf)\n\t\tif errRead != nil {\n\t\t\tif errRead != io.EOF {\n\t\t\t\treturn errRead\n\t\t\t} else {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tif readCount > 0 {\n\t\t\twriteCount, errWrite := dst.Write(buf[0:readCount])\n\t\t\tif errWrite != nil {\n\t\t\t\treturn errWrite\n\t\t\t}\n\t\t\tif readCount != writeCount {\n\t\t\t\treturn io.ErrShortWrite\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 和远程的socket建立连接，他们之间的数据传输会加密\nfunc (secureSocket *SecureSocket) DialRemote() (*net.TCPConn, error) {\n\tremoteConn, err := net.DialTCP(\"tcp\", nil, secureSocket.RemoteAddr)\n\tif err != nil {\n\t\treturn nil, errors.New(fmt.Sprintf(\"连接到远程服务器 %s 失败:%s\", secureSocket.RemoteAddr, err))\n\t}\n\treturn remoteConn, nil\n}\n```\n这个 SecureSocket 用于 local 端和 server 端之间进行 TCP 通信，并且只使用 SecureSocket 通信时中间传输的数据会被加密，防火墙无法读到原数据。 \n\n#### 实现 local 端\n运行在本机的 local 端的职责是把本机程序发送给它的数据经过加密后转发给墙外的代理服务器，总体工作流程如下：\n\n1. 监听来自本机浏览器的代理请求；\n2. 转发前加密数据；\n3. 转发socket数据到墙外代理服务端；\n4. 把服务端返回的数据转发给用户的浏览器。\n\n实现以上功能的 local 端[代码如下](https://github.com/gwuhaolin/lightsocks/blob/master/local/local.go)：\n```go\npackage local\n\nimport (\n\t\"github.com/gwuhaolin/lightsocks/core\"\n\t\"log\"\n\t\"net\"\n)\n\ntype LsLocal struct {\n\t*core.SecureSocket\n}\n\n// 新建一个本地端\nfunc New(password *core.Password, listenAddr, remoteAddr *net.TCPAddr) *LsLocal {\n\treturn &LsLocal{\n\t\tSecureSocket: &core.SecureSocket{\n\t\t\tCipher:     core.NewCipher(password),\n\t\t\tListenAddr: listenAddr,\n\t\t\tRemoteAddr: remoteAddr,\n\t\t},\n\t}\n}\n\n// 本地端启动监听，接收来自本机浏览器的连接\nfunc (local *LsLocal) Listen(didListen func(listenAddr net.Addr)) error {\n\tlistener, err := net.ListenTCP(\"tcp\", local.ListenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer listener.Close()\n\n\tif didListen != nil {\n\t\tdidListen(listener.Addr())\n\t}\n\n\tfor {\n\t\tuserConn, err := listener.AcceptTCP()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\t// userConn被关闭时直接清除所有数据 不管没有发送的数据\n\t\tuserConn.SetLinger(0)\n\t\tgo local.handleConn(userConn)\n\t}\n\treturn nil\n}\n\nfunc (local *LsLocal) handleConn(userConn *net.TCPConn) {\n\tdefer userConn.Close()\n\n\tproxyServer, err := local.DialRemote()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\tdefer proxyServer.Close()\n\t// Conn被关闭时直接清除所有数据 不管没有发送的数据\n\tproxyServer.SetLinger(0)\n\n\t// 进行转发\n\t// 从 proxyServer 读取数据发送到 localUser\n\tgo func() {\n\t\terr := local.DecodeCopy(userConn, proxyServer)\n\t\tif err != nil {\n\t\t\t// 在 copy 的过程中可能会存在网络超时等 error 被 return，只要有一个发生了错误就退出本次工作\n\t\t\tuserConn.Close()\n\t\t\tproxyServer.Close()\n\t\t}\n\t}()\n\t// 从 localUser 发送数据发送到 proxyServer，这里因为处在翻墙阶段出现网络错误的概率更大\n\tlocal.EncodeCopy(proxyServer, userConn)\n}\n```\n\n#### 实现 server 端\n运行在墙外代理服务器的 server 端职责如下：\n\n1. 监听来自本地代理客户端的请求；\n2. 解密本地代理客户端请求的数据，解析 SOCKS5 协议，连接用户浏览器真正想要连接的远程服务器；\n3. 转发用户浏览器真正想要连接的远程服务器返回的数据的加密后的内容到本地代理客户端。\n\n实现以上功能的[代码如下](https://github.com/gwuhaolin/lightsocks/blob/master/server/server.go)：\n```go\npackage server\n\nimport (\n\t\"encoding/binary\"\n\t\"github.com/gwuhaolin/lightsocks/core\"\n\t\"log\"\n\t\"net\"\n)\n\ntype LsServer struct {\n\t*core.SecureSocket\n}\n\n// 新建一个服务端\nfunc New(password *core.Password, listenAddr *net.TCPAddr) *LsServer {\n\treturn &LsServer{\n\t\tSecureSocket: &core.SecureSocket{\n\t\t\tCipher:     core.NewCipher(password),\n\t\t\tListenAddr: listenAddr,\n\t\t},\n\t}\n}\n\n// 运行服务端并且监听来自本地代理客户端的请求\nfunc (lsServer *LsServer) Listen(didListen func(listenAddr net.Addr)) error {\n\tlistener, err := net.ListenTCP(\"tcp\", lsServer.ListenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer listener.Close()\n\n\tif didListen != nil {\n\t\tdidListen(listener.Addr())\n\t}\n\n\tfor {\n\t\tlocalConn, err := listener.AcceptTCP()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\t// localConn被关闭时直接清除所有数据 不管没有发送的数据\n\t\tlocalConn.SetLinger(0)\n\t\tgo lsServer.handleConn(localConn)\n\t}\n\treturn nil\n}\n\n// 解 SOCKS5 协议\n// https://www.ietf.org/rfc/rfc1928.txt\nfunc (lsServer *LsServer) handleConn(localConn *net.TCPConn) {\n\tdefer localConn.Close()\n\tbuf := make([]byte, 256)\n\n\t/**\n\t   The localConn connects to the dstServer, and sends a ver\n\t   identifier/method selection message:\n\t\t          +----+----------+----------+\n\t\t          |VER | NMETHODS | METHODS  |\n\t\t          +----+----------+----------+\n\t\t          | 1  |    1     | 1 to 255 |\n\t\t          +----+----------+----------+\n\t   The VER field is set to X'05' for this ver of the protocol.  The\n\t   NMETHODS field contains the number of method identifier octets that\n\t   appear in the METHODS field.\n\t*/\n\t// 第一个字段VER代表Socks的版本，Socks5默认为0x05，其固定长度为1个字节\n\t_, err := lsServer.DecodeRead(localConn, buf)\n\t// 只支持版本5\n\tif err != nil || buf[0] != 0x05 {\n\t\treturn\n\t}\n\n\t/**\n\t   The dstServer selects from one of the methods given in METHODS, and\n\t   sends a METHOD selection message:\n\n\t\t          +----+--------+\n\t\t          |VER | METHOD |\n\t\t          +----+--------+\n\t\t          | 1  |   1    |\n\t\t          +----+--------+\n\t*/\n\t// 不需要验证，直接验证通过\n\tlsServer.EncodeWrite(localConn, []byte{0x05, 0x00})\n\n\t/**\n\t\t          +----+-----+-------+------+----------+----------+\n\t\t          |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n\t\t          +----+-----+-------+------+----------+----------+\n\t\t          | 1  |  1  | X'00' |  1   | Variable |    2     |\n\t\t          +----+-----+-------+------+----------+----------+\n\t*/\n\n\t// 获取真正的远程服务的地址\n\tn, err := lsServer.DecodeRead(localConn, buf)\n\t// n 最短的长度为7 情况为 ATYP=3 DST.ADDR占用1字节 值为0x0\n\tif err != nil || n < 7 {\n\t\treturn\n\t}\n\n\t// CMD代表客户端请求的类型，值长度也是1个字节，有三种类型\n\t// CONNECT X'01'\n\tif buf[1] != 0x01 {\n\t\t// 目前只支持 CONNECT\n\t\treturn\n\t}\n\n\tvar dIP []byte\n\t// aType 代表请求的远程服务器地址类型，值长度1个字节，有三种类型\n\tswitch buf[3] {\n\tcase 0x01:\n\t\t//\tIP V4 address: X'01'\n\t\tdIP = buf[4 : 4+net.IPv4len]\n\tcase 0x03:\n\t\t//\tDOMAINNAME: X'03'\n\t\tipAddr, err := net.ResolveIPAddr(\"ip\", string(buf[5:n-2]))\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tdIP = ipAddr.IP\n\tcase 0x04:\n\t\t//\tIP V6 address: X'04'\n\t\tdIP = buf[4 : 4+net.IPv6len]\n\tdefault:\n\t\treturn\n\t}\n\tdPort := buf[n-2:]\n\tdstAddr := &net.TCPAddr{\n\t\tIP:   dIP,\n\t\tPort: int(binary.BigEndian.Uint16(dPort)),\n\t}\n\n\t// 连接真正的远程服务\n\tdstServer, err := net.DialTCP(\"tcp\", nil, dstAddr)\n\tif err != nil {\n\t\treturn\n\t} else {\n\t\tdefer dstServer.Close()\n\t\t// Conn被关闭时直接清除所有数据 不管没有发送的数据\n\t\tdstServer.SetLinger(0)\n\n\t\t// 响应客户端连接成功\n\t\t/**\n\t\t          +----+-----+-------+------+----------+----------+\n\t\t          |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |\n\t\t          +----+-----+-------+------+----------+----------+\n\t\t          | 1  |  1  | X'00' |  1   | Variable |    2     |\n\t\t          +----+-----+-------+------+----------+----------+\n\t\t*/\n\t\t// 响应客户端连接成功\n\t\tlsServer.EncodeWrite(localConn, []byte{0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})\n\t}\n\n\t// 进行转发\n\t// 从 localUser 读取数据发送到 dstServer\n\tgo func() {\n\t\terr := lsServer.DecodeCopy(dstServer, localConn)\n\t\tif err != nil {\n\t\t\t// 在 copy 的过程中可能会存在网络超时等 error 被 return，只要有一个发生了错误就退出本次工作\n\t\t\tlocalConn.Close()\n\t\t\tdstServer.Close()\n\t\t}\n\t}()\n\t// 从 dstServer 读取数据发送到 localUser，这里因为处在翻墙阶段出现网络错误的概率更大\n\tlsServer.EncodeCopy(localConn, dstServer)\n}\n```\n\n---\n\n以上就是实现一个轻量级 Shadowsocks 的核心代码。其它一些零碎的代码，例如启动入口、配置读写等，可以去 [lightsocks](https://github.com/gwuhaolin/lightsocks) 项目中阅读完整代码。\n\n[阅读原文](http://wuhaolin.cn/2017/11/03/%E4%BD%A0%E4%B9%9F%E8%83%BD%E5%86%99%E4%B8%AA%20Shadowsocks/)","source":"_posts/你也能写个 Shadowsocks.md","raw":"---\ntitle: 你也能写个 Shadowsocks\ndate: 2017-11-03T11:24:28Z\nurl: https://github.com/gwuhaolin/blog/issues/12\ntags:\n    - 网络\n---\n\n本文将教你从0写一个[Shadowsocks](https://github.com/shadowsocks/shadowsocks-go)，无需任何基础，读完本文你就能完成一个轻量级、高性能的 Shadowsocks 代替品。\n\n我们暂且把最终完成的项目叫做 Lightsocks，如果你很急切地想看到结果，可以先体验本文最终完成的项目 [Lightsocks](https://github.com/gwuhaolin/lightsocks) ，也可以下载阅读源码。\n\n## 认识 Shadowsocks\nShadowsocks 是一个能骗过防火墙的网络代理工具。它把要传输的原数据经过加密后再传输，网络中的防火墙由于得不出要传输的原内容是什么而只好放行，于是就完成了防火墙穿透，也即是所谓的“翻墙”。\n\n在自由的网络环境下，在本机上访问服务时是直接和远程服务建立连接传输数据，流程如图：\n![自由网络环境下的传输流程](https://user-images.githubusercontent.com/5773264/32371367-8c231024-c05e-11e7-87a8-f977577a6b89.png)\n\n但在受限的网络环境下会有防火墙，本机电脑和远程服务之间传输的数据都必须通过防火墙的检查，流程如图：\n![受限网络环境下的传输流程](https://user-images.githubusercontent.com/5773264/32371437-d8cb8852-c05e-11e7-9872-a6708bbe65ba.png)\n如果防火墙发现你在传输受限的内容，就把拦截本次传输，就会导致在本机无法访问远程服务。\n\n而 Shadowsocks 所做的就是把传输的数据加密，防火墙得到的数据是加密后的数据，防火墙不知道传输的原内容是什么，于是防火墙就放行本次请求，于是在本机就访问到了远程服务，流程如图：\n![shadowsocks下的传输流程](https://user-images.githubusercontent.com/5773264/32371932-cdc55044-c060-11e7-9b0e-c1a7fec2b428.png)\n\n也就是说使用 Shadowsocks 的前提是：\n- 一台在防火墙之外的服务器；\n- 在本机需要安装 Shadowsocks 本地端，用于加密传输数据；\n- 服务器需要安装 Shadowsocks 服务端，用于解密加密后的传输数据，解密出原数据后发送到目标服务器。\n\n## Shadowsocks 原理\nShadowsocks 由两部分组成，运行在本地的 ss-local 和运行在防火墙之外服务器上的 ss-server，下面来分别详细介绍它们的职责（以下对 Shadowsocks 原理的解析只是我的大概估计，可能会有细微的差别）。\n\n#### ss-local\nss-local 的职责是在本机启动和监听着一个服务，本地软件的网络请求都先发送到 ss-local，ss-local 收到来自本地软件的网络请求后，把要传输的原数据根据用户配置的加密方法和密码进行加密，再转发到墙外的服务器去。\n\n#### ss-server\nss-server 的职责是在墙外服务器启动和监听一个服务，该服务监听来自本机的 ss-local 的请求。在收到来自 ss-local 转发过来的数据时，会先根据用户配置的加密方法和密码对数据进行对称解密，以获得加密后的数据的原内容。同时还会解 SOCKS5 协议，读出本次请求真正的目标服务地址(例如 Google 服务器地址)，再把解密后得到的原数据转发到真正的目标服务。\n\n当真正的目标服务返回了数据时，ss-server 端会把返回的数据加密后转发给对应的 ss-local 端，ss-local 端收到数据再解密后，转发给本机的软件。这是一个对称相反的过程。\n\n由于 ss-local 和 ss-server 端都需要用对称加密算法对数据进行加密和解密，因此这两端的加密方法和密码必须配置为一样。Shadowsocks 提供了一系列标准可靠的对称算法可供用户选择，例如 rc4、aes、des、chacha20 等等。Shadowsocks 对数据加密后再传输的目的是为了混淆原数据，让途中的防火墙无法得出传输的原数据。但其实用这些安全性高计算量大的对称加密算法去实现混淆有点“杀鸡用牛刀”。\n\n## SOCKS5 协议介绍\nShadowsocks 的数据传输是建立在 SOCKS5 协议之上的，SOCKS5 是 TCP/IP 层面的网络代理协议。\nss-server 端解密出来的数据就是采用 SOCKS5 协议封装的，通过 SOCKS5 协议 ss-server 端能读出本机软件想访问的服务的真正地址以及要传输的原数据，下面来详细介绍  SOCKS5 协议的通信细节。\n\n#### 建立连接\n客户端向服务端连接连接，客户端发送的数据包如下：\n\n| VER | NMETHODS | METHODS |\n| --- | --- | --- |\n| 1 | 1 | 1 |\n\n其中各个字段的含义如下：\n-`VER`：代表 SOCKS 的版本，SOCKS5 默认为`0x05`，其固定长度为1个字节；\n-`NMETHODS`：表示第三个字段METHODS的长度，它的长度也是1个字节；\n-`METHODS`：表示客户端支持的验证方式，可以有多种，他的长度是1-255个字节。\n\n目前支持的验证方式共有：\n- `0x00`：NO AUTHENTICATION REQUIRED（不需要验证）\n- `0x01`：GSSAPI\n- `0x02`：USERNAME/PASSWORD（用户名密码）\n- `0x03`: to X'7F' IANA ASSIGNED\n- `0x80`: to X'FE' RESERVED FOR PRIVATE METHODS\n- `0xFF`: NO ACCEPTABLE METHODS（都不支持，没法连接了）\n\n#### 响应连接\n服务端收到客户端的验证信息之后，就要回应客户端，服务端需要客户端提供哪种验证方式的信息。服务端回应的包格式如下：\n\n| VER | METHOD |\n| --- | --- |\n| 1 | 1 |\n\n其中各个字段的含义如下：\n- `VER`：代表 SOCKS 的版本，SOCKS5 默认为`0x05`，其固定长度为1个字节；\n- `METHOD`：代表服务端需要客户端按此验证方式提供的验证信息，其值长度为1个字节，可为上面六种验证方式之一。\n\n举例说明，比如服务端不需要验证的话，可以这么回应客户端：\n\n| VER | METHOD |\n| --- | --- |\n| `0x05` | `0x00` |\n\n#### 和目标服务建立连接\n客户端发起的连接由服务端验证通过后，客户端下一步应该告诉真正目标服务的地址给服务器，服务器得到地址后再去请求真正的目标服务。也就是说客户端需要把 Google 服务的地址`google.com:80`告诉服务端，服务端再去请求`google.com:80`。\n目标服务地址的格式为 (IP或域名)+端口，客户端需要发送的包格式如下：\n\n| VER | CMD | RSV | ATYP | DST.ADDR | DST.PORT |\n| -- | -- | -- | -- | -- | -- |\n| 1 | 1 | `0x00` | 1 | Variable | 2 |\n\n各个字段的含义如下：\n- `VER`：代表 SOCKS 协议的版本，SOCKS 默认为0x05，其值长度为1个字节；\n- `CMD`：代表客户端请求的类型，值长度也是1个字节，有三种类型；\n  - `CONNECT`： `0x01`；\n  - `BIND`： `0x02`；\n  - `UDP`： ASSOCIATE `0x03`；\n- `RSV`：保留字，值长度为1个字节；\n- `ATYP`：代表请求的远程服务器地址类型，值长度1个字节，有三种类型；\n  - `IPV4`： address: `0x01`；\n  - `DOMAINNAME`: `0x03`；\n  - `IPV6`： address: `0x04`；\n- `DST.ADDR`：代表远程服务器的地址，根据 `ATYP` 进行解析，值长度不定；\n- `DST.PORT`：代表远程服务器的端口，要访问哪个端口的意思，值长度2个字节。\n\n服务端在得到来自客户端告诉的目标服务地址后，便和目标服务进行连接，不管连接成功与否，服务器都应该把连接的结果告诉客户端。在连接成功的情况下，服务端返回的包格式如下：\n\n| VER | REP | RSV | ATYP | BND.ADDR | BND.PORT\n| -- | -- | -- | -- | -- | -- |\n| 1 | 1 | `0x00` | 1 | Variable | 2 |\n\n各个字段的含义如下：\n- `VER`：代表 SOCKS 协议的版本，SOCKS 默认为0x05，其值长度为1个字节；\n- REP代表响应状态码，值长度也是1个字节，有以下几种类型\n  - `0x00` succeeded\n  - `0x01` general SOCKS server failure\n  - `0x02` connection not allowed by ruleset\n  - `0x03` Network unreachable\n  - `0x04` Host unreachable\n  - `0x05` Connection refused\n  - `0x06` TTL expired\n  - `0x07` Command not supported\n  - `0x08` Address type not supported\n  - `0x09` to `0xFF` unassigned\n- `RSV`：保留字，值长度为1个字节\n- `ATYP`：代表请求的远程服务器地址类型，值长度1个字节，有三种类型\n  - IP V4 address： `0x01`\n  - DOMAINNAME： `0x03`\n  - IP V6 address： `0x04`\n- `BND.ADDR`：表示绑定地址，值长度不定。\n- `BND.PORT`： 表示绑定端口，值长度2个字节\n\n#### 数据转发\n客户端在收到来自服务器成功的响应后，就会开始发送数据了，服务端在收到来自客户端的数据后，会转发到目标服务。\n\n#### 总结\nSOCKS5 协议的目的其实就是为了把来自原本应该在本机直接请求目标服务的流程，放到了服务端去代理客户端访问。\n其运行流程总结如下：\n\n1. 本机和代理服务端协商和建立连接；\n2. 本机告诉代理服务端目标服务的地址；\n3. 代理服务端去连接目标服务，成功后告诉本机；\n4. 本机开始发送原本应发送到目标服务的数据给代理服务端，由代理服务端完成数据转发。\n\n以上内容来自 [SOCKS5 协议规范 rfc1928](http://www.ietf.org/rfc/rfc1928.txt)。\n\n## [Lightsocks](https://github.com/gwuhaolin/lightsocks) 实现\n要实现 Lightsocks 需要实现两部分：运行在本地的 lightsocks-local，和运行在墙外代理服务器上 lightsocks-server。\n下面来分别教你如果使用 Golang 来实现它们，采用 Golang 语言的原因在于：性能好、跨平台、适合高并发、学习门槛低。对Golang感兴趣？请看[Golang 中文学习资料汇总](http://go.wuhaolin.cn/)\n\n#### 实现数据混淆\n在 Shadowsocks 中是采用的标准的对称加密算法去实现数据混淆的，对称算法在加密和解密过程中需要大量计算。\n为了简单起见，Lightsocks 将采用最简单高效的方法去实现数据混淆，具体原理如下。\n\n这个数据混淆算法和对称加密很相似，两端都需要有同样的密钥。\n这个密钥有如下要求：\n- 由256个 byte 组成，也就是一个数组，在 Golang 中类型表示为 `[256]byte`；\n- 这个数组必须由 0～255 这256个数字组成，一个都不能差；\n- 这个数组中第`I`个的值不能等于`I`；\n\n例如以下为一个合法的密钥(上为索引，下为值)：\n\n|0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 91 | 92 | 93 | 94 | 95 | 96 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 123 | 124 | 125 | 126 | 127 | 128 | 129 | 130 | 131 | 132 | 133 | 134 | 135 | 136 | 137 | 138 | 139 | 140 | 141 | 142 | 143 | 144 | 145 | 146 | 147 | 148 | 149 | 150 | 151 | 152 | 153 | 154 | 155 | 156 | 157 | 158 | 159 | 160 | 161 | 162 | 163 | 164 | 165 | 166 | 167 | 168 | 169 | 170 | 171 | 172 | 173 | 174 | 175 | 176 | 177 | 178 | 179 | 180 | 181 | 182 | 183 | 184 | 185 | 186 | 187 | 188 | 189 | 190 | 191 | 192 | 193 | 194 | 195 | 196 | 197 | 198 | 199 | 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214 | 215 | 216 | 217 | 218 | 219 | 220 | 221 | 222 | 223 | 224 | 225 | 226 | 227 | 228 | 229 | 230 | 231 | 232 | 233 | 234 | 235 | 236 | 237 | 238 | 239 | 240 | 241 | 242 | 243 | 244 | 245 | 246 | 247 | 248 | 249 | 250 | 251 | 252 | 253 | 254 | 255 |\n|--- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n|186 | 118 | 82 | 201 | 235 | 236 | 180 | 66 | 228 | 96 | 43 | 90 | 203 | 200 | 34 | 104 | 41 | 222 | 165 | 74 | 240 | 20 | 244 | 67 | 114 | 191 | 220 | 147 | 196 | 183 | 229 | 123 | 208 | 19 | 127 | 187 | 84 | 148 | 56 | 170 | 133 | 160 | 202 | 21 | 53 | 78 | 59 | 64 | 120 | 27 | 167 | 175 | 39 | 10 | 4 | 132 | 89 | 230 | 152 | 73 | 221 | 88 | 141 | 158 | 251 | 79 | 225 | 87 | 14 | 23 | 68 | 250 | 199 | 168 | 218 | 60 | 40 | 169 | 75 | 86 | 153 | 134 | 83 | 49 | 128 | 231 | 217 | 239 | 226 | 177 | 57 | 24 | 234 | 63 | 7 | 112 | 166 | 211 | 254 | 179 | 157 | 215 | 227 | 224 | 233 | 81 | 172 | 26 | 122 | 219 | 48 | 151 | 232 | 50 | 108 | 44 | 0 | 192 | 65 | 76 | 109 | 252 | 248 | 47 | 154 | 33 | 209 | 115 | 31 | 15 | 45 | 206 | 247 | 124 | 77 | 8 | 182 | 144 | 1 | 72 | 131 | 52 | 245 | 198 | 238 | 5 | 188 | 116 | 55 | 216 | 155 | 2 | 178 | 189 | 162 | 136 | 243 | 184 | 58 | 69 | 70 | 99 | 36 | 25 | 35 | 174 | 195 | 18 | 205 | 30 | 190 | 142 | 210 | 113 | 145 | 101 | 97 | 161 | 100 | 91 | 242 | 138 | 93 | 171 | 98 | 237 | 212 | 255 | 80 | 102 | 119 | 204 | 107 | 105 | 111 | 11 | 29 | 146 | 129 | 117 | 135 | 176 | 163 | 207 | 103 | 22 | 246 | 125 | 150 | 106 | 126 | 197 | 249 | 62 | 51 | 193 | 32 | 3 | 110 | 46 | 85 | 71 | 159 | 139 | 12 | 164 | 95 | 121 | 140 | 241 | 253 | 130 | 173 | 213 | 54 | 143 | 16 | 94 | 9 | 61 | 156 | 214 | 28 | 17 | 37 | 42 | 181 | 149 | 185 | 223 | 92 | 38 | 13 | 194 | 6 | 137 |\n\n\n如果原数据为 `[5,0,1,2,3]`，则采用以上密钥加密后变成 `[236,186,118,82,201]`。\n如果加密后的数据为 `[186,118,82,201,235]`，则采用以上密钥解密得到的原数据为 `[0,1,2,3,4]`\n\n聪明的你肯定看懂了其中的规律：把1～255 这256个数字确定一种一对一的映射关系，加密是从一个数字得到对应的一个数字，而解密则是反向的过程，而这个密钥的作用正是描述这个映射关系。\n这其实就是中学学的**反函数**。\n\n为什么要这样设计数据混淆算法呢？在数据传输时，数据是以 byte 为最小单位流式传输的。一个 byte 的取值只可能是 0～255。该混淆算法可以直接对一个个 byte 进行加解密，而无需像标准的对称算法那样只能对一大块数据进行加密。\n再加上本算法的加解密 N byte 数据的算法复杂度为 N（直接通过数组索引访问），非常适合流式加密。\n\n以上加密算法的安全性怎么样呢？符合以上要求的密钥匙有多少种组合呢？我们来算算：\n这其实就是初中学的排列组合中的排列问题，形象点其实就是，把 0～255 个不同编号的人安排到 0～255 个不同编号的坑去，并且不能有编号一样的情况，有多少种排法。\n也就是 `A(255,255)=255*254*253*...*1=255!`，但其中有一半为有重复的情况，\n最终结果为 `255!/2`，\n其值大概为 `10^500` 这个数量级。\n\n以上加密算法虽然破绽很多，但足以实现高效的数据混淆，骗过防火墙。\n\n目前采用对称加密算法实现数据混淆的 Shadowsocks 已经能被一些防火墙通过机器学习算法通过特征分析识别出传输的原内容适合合法，而 Lightsocks 的这套混淆算法目前还不能被轻易的识别出来。\n\n随机产生一个以上密钥匙的[代码如下](https://github.com/gwuhaolin/lightsocks/blob/master/core/password.go)：\n```go\npackage core\nimport (\n\t\"math/rand\"\n\t\"time\"\n)\nconst PasswordLength = 256\ntype Password [PasswordLength]byte\n\nfunc init() {\n\t// 更新随机种子，防止生成一样的随机密码\n\trand.Seed(time.Now().Unix())\n}\n\n// 产生 256个byte随机组合的 密码\nfunc RandPassword() *Password {\n\t// 随机生成一个由  0~255 组成的 byte 数组\n\tintArr := rand.Perm(PasswordLength)\n\tpassword := &Password{}\n\tfor i, v := range intArr {\n\t\tpassword[i] = byte(v)\n\t\tif i == v {\n\t\t\t// 确保不会出现如何一个byte位出现重复\n\t\t\treturn RandPassword()\n\t\t}\n\t}\n\treturn password\n}\n```\n\n对数据进行加密解密的[代码如下](https://github.com/gwuhaolin/lightsocks/blob/master/core/cipher.go)：\n```go\npackage core\n\ntype Cipher struct {\n\t// 编码用的密码\n\tencodePassword *Password\n\t// 解码用的密码\n\tdecodePassword *Password\n}\n\n// 加密原数据\nfunc (cipher *Cipher) encode(bs []byte) {\n\tfor i, v := range bs {\n\t\tbs[i] = cipher.encodePassword[v]\n\t}\n}\n\n// 解码加密后的数据到原数据\nfunc (cipher *Cipher) decode(bs []byte) {\n\tfor i, v := range bs {\n\t\tbs[i] = cipher.decodePassword[v]\n\t}\n}\n\n// 新建一个编码解码器\nfunc NewCipher(encodePassword *Password) *Cipher {\n\tdecodePassword := &Password{}\n\tfor i, v := range encodePassword {\n\t\tencodePassword[i] = v\n\t\tdecodePassword[v] = byte(i)\n\t}\n\treturn &Cipher{\n\t\tencodePassword: encodePassword,\n\t\tdecodePassword: decodePassword,\n\t}\n}\n```\n\n再使用以上的 Cipher 去封装一个加密传输的 SecureSocket，以方便直接加解密 TCP Socket 中的流式数据，[代码如下](https://github.com/gwuhaolin/lightsocks/blob/master/core/securesocket.go)：\n```go\npackage core\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n)\n\nconst (\n\tBufSize = 1024\n)\n\n// 加密传输的 TCP Socket\ntype SecureSocket struct {\n\tCipher     *Cipher\n\tListenAddr *net.TCPAddr\n\tRemoteAddr *net.TCPAddr\n}\n\n// 从输入流里读取加密过的数据，解密后把原数据放到bs里\nfunc (secureSocket *SecureSocket) DecodeRead(conn *net.TCPConn, bs []byte) (n int, err error) {\n\tn, err = conn.Read(bs)\n\tif err != nil {\n\t\treturn\n\t}\n\tsecureSocket.Cipher.decode(bs[:n])\n\treturn\n}\n\n// 把放在bs里的数据加密后立即全部写入输出流\nfunc (secureSocket *SecureSocket) EncodeWrite(conn *net.TCPConn, bs []byte) (int, error) {\n\tsecureSocket.Cipher.encode(bs)\n\treturn conn.Write(bs)\n}\n\n// 从src中源源不断的读取原数据加密后写入到dst，直到src中没有数据可以再读取\nfunc (secureSocket *SecureSocket) EncodeCopy(dst *net.TCPConn, src *net.TCPConn) error {\n\tbuf := make([]byte, BufSize)\n\tfor {\n\t\treadCount, errRead := src.Read(buf)\n\t\tif errRead != nil {\n\t\t\tif errRead != io.EOF {\n\t\t\t\treturn errRead\n\t\t\t} else {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tif readCount > 0 {\n\t\t\twriteCount, errWrite := secureSocket.EncodeWrite(dst, buf[0:readCount])\n\t\t\tif errWrite != nil {\n\t\t\t\treturn errWrite\n\t\t\t}\n\t\t\tif readCount != writeCount {\n\t\t\t\treturn io.ErrShortWrite\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 从src中源源不断的读取加密后的数据解密后写入到dst，直到src中没有数据可以再读取\nfunc (secureSocket *SecureSocket) DecodeCopy(dst *net.TCPConn, src *net.TCPConn) error {\n\tbuf := make([]byte, BufSize)\n\tfor {\n\t\treadCount, errRead := secureSocket.DecodeRead(src, buf)\n\t\tif errRead != nil {\n\t\t\tif errRead != io.EOF {\n\t\t\t\treturn errRead\n\t\t\t} else {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tif readCount > 0 {\n\t\t\twriteCount, errWrite := dst.Write(buf[0:readCount])\n\t\t\tif errWrite != nil {\n\t\t\t\treturn errWrite\n\t\t\t}\n\t\t\tif readCount != writeCount {\n\t\t\t\treturn io.ErrShortWrite\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 和远程的socket建立连接，他们之间的数据传输会加密\nfunc (secureSocket *SecureSocket) DialRemote() (*net.TCPConn, error) {\n\tremoteConn, err := net.DialTCP(\"tcp\", nil, secureSocket.RemoteAddr)\n\tif err != nil {\n\t\treturn nil, errors.New(fmt.Sprintf(\"连接到远程服务器 %s 失败:%s\", secureSocket.RemoteAddr, err))\n\t}\n\treturn remoteConn, nil\n}\n```\n这个 SecureSocket 用于 local 端和 server 端之间进行 TCP 通信，并且只使用 SecureSocket 通信时中间传输的数据会被加密，防火墙无法读到原数据。 \n\n#### 实现 local 端\n运行在本机的 local 端的职责是把本机程序发送给它的数据经过加密后转发给墙外的代理服务器，总体工作流程如下：\n\n1. 监听来自本机浏览器的代理请求；\n2. 转发前加密数据；\n3. 转发socket数据到墙外代理服务端；\n4. 把服务端返回的数据转发给用户的浏览器。\n\n实现以上功能的 local 端[代码如下](https://github.com/gwuhaolin/lightsocks/blob/master/local/local.go)：\n```go\npackage local\n\nimport (\n\t\"github.com/gwuhaolin/lightsocks/core\"\n\t\"log\"\n\t\"net\"\n)\n\ntype LsLocal struct {\n\t*core.SecureSocket\n}\n\n// 新建一个本地端\nfunc New(password *core.Password, listenAddr, remoteAddr *net.TCPAddr) *LsLocal {\n\treturn &LsLocal{\n\t\tSecureSocket: &core.SecureSocket{\n\t\t\tCipher:     core.NewCipher(password),\n\t\t\tListenAddr: listenAddr,\n\t\t\tRemoteAddr: remoteAddr,\n\t\t},\n\t}\n}\n\n// 本地端启动监听，接收来自本机浏览器的连接\nfunc (local *LsLocal) Listen(didListen func(listenAddr net.Addr)) error {\n\tlistener, err := net.ListenTCP(\"tcp\", local.ListenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer listener.Close()\n\n\tif didListen != nil {\n\t\tdidListen(listener.Addr())\n\t}\n\n\tfor {\n\t\tuserConn, err := listener.AcceptTCP()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\t// userConn被关闭时直接清除所有数据 不管没有发送的数据\n\t\tuserConn.SetLinger(0)\n\t\tgo local.handleConn(userConn)\n\t}\n\treturn nil\n}\n\nfunc (local *LsLocal) handleConn(userConn *net.TCPConn) {\n\tdefer userConn.Close()\n\n\tproxyServer, err := local.DialRemote()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\tdefer proxyServer.Close()\n\t// Conn被关闭时直接清除所有数据 不管没有发送的数据\n\tproxyServer.SetLinger(0)\n\n\t// 进行转发\n\t// 从 proxyServer 读取数据发送到 localUser\n\tgo func() {\n\t\terr := local.DecodeCopy(userConn, proxyServer)\n\t\tif err != nil {\n\t\t\t// 在 copy 的过程中可能会存在网络超时等 error 被 return，只要有一个发生了错误就退出本次工作\n\t\t\tuserConn.Close()\n\t\t\tproxyServer.Close()\n\t\t}\n\t}()\n\t// 从 localUser 发送数据发送到 proxyServer，这里因为处在翻墙阶段出现网络错误的概率更大\n\tlocal.EncodeCopy(proxyServer, userConn)\n}\n```\n\n#### 实现 server 端\n运行在墙外代理服务器的 server 端职责如下：\n\n1. 监听来自本地代理客户端的请求；\n2. 解密本地代理客户端请求的数据，解析 SOCKS5 协议，连接用户浏览器真正想要连接的远程服务器；\n3. 转发用户浏览器真正想要连接的远程服务器返回的数据的加密后的内容到本地代理客户端。\n\n实现以上功能的[代码如下](https://github.com/gwuhaolin/lightsocks/blob/master/server/server.go)：\n```go\npackage server\n\nimport (\n\t\"encoding/binary\"\n\t\"github.com/gwuhaolin/lightsocks/core\"\n\t\"log\"\n\t\"net\"\n)\n\ntype LsServer struct {\n\t*core.SecureSocket\n}\n\n// 新建一个服务端\nfunc New(password *core.Password, listenAddr *net.TCPAddr) *LsServer {\n\treturn &LsServer{\n\t\tSecureSocket: &core.SecureSocket{\n\t\t\tCipher:     core.NewCipher(password),\n\t\t\tListenAddr: listenAddr,\n\t\t},\n\t}\n}\n\n// 运行服务端并且监听来自本地代理客户端的请求\nfunc (lsServer *LsServer) Listen(didListen func(listenAddr net.Addr)) error {\n\tlistener, err := net.ListenTCP(\"tcp\", lsServer.ListenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer listener.Close()\n\n\tif didListen != nil {\n\t\tdidListen(listener.Addr())\n\t}\n\n\tfor {\n\t\tlocalConn, err := listener.AcceptTCP()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\t// localConn被关闭时直接清除所有数据 不管没有发送的数据\n\t\tlocalConn.SetLinger(0)\n\t\tgo lsServer.handleConn(localConn)\n\t}\n\treturn nil\n}\n\n// 解 SOCKS5 协议\n// https://www.ietf.org/rfc/rfc1928.txt\nfunc (lsServer *LsServer) handleConn(localConn *net.TCPConn) {\n\tdefer localConn.Close()\n\tbuf := make([]byte, 256)\n\n\t/**\n\t   The localConn connects to the dstServer, and sends a ver\n\t   identifier/method selection message:\n\t\t          +----+----------+----------+\n\t\t          |VER | NMETHODS | METHODS  |\n\t\t          +----+----------+----------+\n\t\t          | 1  |    1     | 1 to 255 |\n\t\t          +----+----------+----------+\n\t   The VER field is set to X'05' for this ver of the protocol.  The\n\t   NMETHODS field contains the number of method identifier octets that\n\t   appear in the METHODS field.\n\t*/\n\t// 第一个字段VER代表Socks的版本，Socks5默认为0x05，其固定长度为1个字节\n\t_, err := lsServer.DecodeRead(localConn, buf)\n\t// 只支持版本5\n\tif err != nil || buf[0] != 0x05 {\n\t\treturn\n\t}\n\n\t/**\n\t   The dstServer selects from one of the methods given in METHODS, and\n\t   sends a METHOD selection message:\n\n\t\t          +----+--------+\n\t\t          |VER | METHOD |\n\t\t          +----+--------+\n\t\t          | 1  |   1    |\n\t\t          +----+--------+\n\t*/\n\t// 不需要验证，直接验证通过\n\tlsServer.EncodeWrite(localConn, []byte{0x05, 0x00})\n\n\t/**\n\t\t          +----+-----+-------+------+----------+----------+\n\t\t          |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n\t\t          +----+-----+-------+------+----------+----------+\n\t\t          | 1  |  1  | X'00' |  1   | Variable |    2     |\n\t\t          +----+-----+-------+------+----------+----------+\n\t*/\n\n\t// 获取真正的远程服务的地址\n\tn, err := lsServer.DecodeRead(localConn, buf)\n\t// n 最短的长度为7 情况为 ATYP=3 DST.ADDR占用1字节 值为0x0\n\tif err != nil || n < 7 {\n\t\treturn\n\t}\n\n\t// CMD代表客户端请求的类型，值长度也是1个字节，有三种类型\n\t// CONNECT X'01'\n\tif buf[1] != 0x01 {\n\t\t// 目前只支持 CONNECT\n\t\treturn\n\t}\n\n\tvar dIP []byte\n\t// aType 代表请求的远程服务器地址类型，值长度1个字节，有三种类型\n\tswitch buf[3] {\n\tcase 0x01:\n\t\t//\tIP V4 address: X'01'\n\t\tdIP = buf[4 : 4+net.IPv4len]\n\tcase 0x03:\n\t\t//\tDOMAINNAME: X'03'\n\t\tipAddr, err := net.ResolveIPAddr(\"ip\", string(buf[5:n-2]))\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tdIP = ipAddr.IP\n\tcase 0x04:\n\t\t//\tIP V6 address: X'04'\n\t\tdIP = buf[4 : 4+net.IPv6len]\n\tdefault:\n\t\treturn\n\t}\n\tdPort := buf[n-2:]\n\tdstAddr := &net.TCPAddr{\n\t\tIP:   dIP,\n\t\tPort: int(binary.BigEndian.Uint16(dPort)),\n\t}\n\n\t// 连接真正的远程服务\n\tdstServer, err := net.DialTCP(\"tcp\", nil, dstAddr)\n\tif err != nil {\n\t\treturn\n\t} else {\n\t\tdefer dstServer.Close()\n\t\t// Conn被关闭时直接清除所有数据 不管没有发送的数据\n\t\tdstServer.SetLinger(0)\n\n\t\t// 响应客户端连接成功\n\t\t/**\n\t\t          +----+-----+-------+------+----------+----------+\n\t\t          |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |\n\t\t          +----+-----+-------+------+----------+----------+\n\t\t          | 1  |  1  | X'00' |  1   | Variable |    2     |\n\t\t          +----+-----+-------+------+----------+----------+\n\t\t*/\n\t\t// 响应客户端连接成功\n\t\tlsServer.EncodeWrite(localConn, []byte{0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})\n\t}\n\n\t// 进行转发\n\t// 从 localUser 读取数据发送到 dstServer\n\tgo func() {\n\t\terr := lsServer.DecodeCopy(dstServer, localConn)\n\t\tif err != nil {\n\t\t\t// 在 copy 的过程中可能会存在网络超时等 error 被 return，只要有一个发生了错误就退出本次工作\n\t\t\tlocalConn.Close()\n\t\t\tdstServer.Close()\n\t\t}\n\t}()\n\t// 从 dstServer 读取数据发送到 localUser，这里因为处在翻墙阶段出现网络错误的概率更大\n\tlsServer.EncodeCopy(localConn, dstServer)\n}\n```\n\n---\n\n以上就是实现一个轻量级 Shadowsocks 的核心代码。其它一些零碎的代码，例如启动入口、配置读写等，可以去 [lightsocks](https://github.com/gwuhaolin/lightsocks) 项目中阅读完整代码。\n\n[阅读原文](http://wuhaolin.cn/2017/11/03/%E4%BD%A0%E4%B9%9F%E8%83%BD%E5%86%99%E4%B8%AA%20Shadowsocks/)","slug":"你也能写个 Shadowsocks","published":1,"updated":"2018-11-14T04:39:28.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjogs0ke8000bg5tcuwu7z0rv","content":"<p>本文将教你从0写一个<a href=\"https://github.com/shadowsocks/shadowsocks-go\" target=\"_blank\" rel=\"noopener\">Shadowsocks</a>，无需任何基础，读完本文你就能完成一个轻量级、高性能的 Shadowsocks 代替品。</p>\n<p>我们暂且把最终完成的项目叫做 Lightsocks，如果你很急切地想看到结果，可以先体验本文最终完成的项目 <a href=\"https://github.com/gwuhaolin/lightsocks\" target=\"_blank\" rel=\"noopener\">Lightsocks</a> ，也可以下载阅读源码。</p>\n<h2 id=\"认识-Shadowsocks\"><a href=\"#认识-Shadowsocks\" class=\"headerlink\" title=\"认识 Shadowsocks\"></a>认识 Shadowsocks</h2><p>Shadowsocks 是一个能骗过防火墙的网络代理工具。它把要传输的原数据经过加密后再传输，网络中的防火墙由于得不出要传输的原内容是什么而只好放行，于是就完成了防火墙穿透，也即是所谓的“翻墙”。</p>\n<p>在自由的网络环境下，在本机上访问服务时是直接和远程服务建立连接传输数据，流程如图：<br><img src=\"https://user-images.githubusercontent.com/5773264/32371367-8c231024-c05e-11e7-87a8-f977577a6b89.png\" alt=\"自由网络环境下的传输流程\"></p>\n<p>但在受限的网络环境下会有防火墙，本机电脑和远程服务之间传输的数据都必须通过防火墙的检查，流程如图：<br><img src=\"https://user-images.githubusercontent.com/5773264/32371437-d8cb8852-c05e-11e7-9872-a6708bbe65ba.png\" alt=\"受限网络环境下的传输流程\"><br>如果防火墙发现你在传输受限的内容，就把拦截本次传输，就会导致在本机无法访问远程服务。</p>\n<p>而 Shadowsocks 所做的就是把传输的数据加密，防火墙得到的数据是加密后的数据，防火墙不知道传输的原内容是什么，于是防火墙就放行本次请求，于是在本机就访问到了远程服务，流程如图：<br><img src=\"https://user-images.githubusercontent.com/5773264/32371932-cdc55044-c060-11e7-9b0e-c1a7fec2b428.png\" alt=\"shadowsocks下的传输流程\"></p>\n<p>也就是说使用 Shadowsocks 的前提是：</p>\n<ul>\n<li>一台在防火墙之外的服务器；</li>\n<li>在本机需要安装 Shadowsocks 本地端，用于加密传输数据；</li>\n<li>服务器需要安装 Shadowsocks 服务端，用于解密加密后的传输数据，解密出原数据后发送到目标服务器。</li>\n</ul>\n<h2 id=\"Shadowsocks-原理\"><a href=\"#Shadowsocks-原理\" class=\"headerlink\" title=\"Shadowsocks 原理\"></a>Shadowsocks 原理</h2><p>Shadowsocks 由两部分组成，运行在本地的 ss-local 和运行在防火墙之外服务器上的 ss-server，下面来分别详细介绍它们的职责（以下对 Shadowsocks 原理的解析只是我的大概估计，可能会有细微的差别）。</p>\n<h4 id=\"ss-local\"><a href=\"#ss-local\" class=\"headerlink\" title=\"ss-local\"></a>ss-local</h4><p>ss-local 的职责是在本机启动和监听着一个服务，本地软件的网络请求都先发送到 ss-local，ss-local 收到来自本地软件的网络请求后，把要传输的原数据根据用户配置的加密方法和密码进行加密，再转发到墙外的服务器去。</p>\n<h4 id=\"ss-server\"><a href=\"#ss-server\" class=\"headerlink\" title=\"ss-server\"></a>ss-server</h4><p>ss-server 的职责是在墙外服务器启动和监听一个服务，该服务监听来自本机的 ss-local 的请求。在收到来自 ss-local 转发过来的数据时，会先根据用户配置的加密方法和密码对数据进行对称解密，以获得加密后的数据的原内容。同时还会解 SOCKS5 协议，读出本次请求真正的目标服务地址(例如 Google 服务器地址)，再把解密后得到的原数据转发到真正的目标服务。</p>\n<p>当真正的目标服务返回了数据时，ss-server 端会把返回的数据加密后转发给对应的 ss-local 端，ss-local 端收到数据再解密后，转发给本机的软件。这是一个对称相反的过程。</p>\n<p>由于 ss-local 和 ss-server 端都需要用对称加密算法对数据进行加密和解密，因此这两端的加密方法和密码必须配置为一样。Shadowsocks 提供了一系列标准可靠的对称算法可供用户选择，例如 rc4、aes、des、chacha20 等等。Shadowsocks 对数据加密后再传输的目的是为了混淆原数据，让途中的防火墙无法得出传输的原数据。但其实用这些安全性高计算量大的对称加密算法去实现混淆有点“杀鸡用牛刀”。</p>\n<h2 id=\"SOCKS5-协议介绍\"><a href=\"#SOCKS5-协议介绍\" class=\"headerlink\" title=\"SOCKS5 协议介绍\"></a>SOCKS5 协议介绍</h2><p>Shadowsocks 的数据传输是建立在 SOCKS5 协议之上的，SOCKS5 是 TCP/IP 层面的网络代理协议。<br>ss-server 端解密出来的数据就是采用 SOCKS5 协议封装的，通过 SOCKS5 协议 ss-server 端能读出本机软件想访问的服务的真正地址以及要传输的原数据，下面来详细介绍  SOCKS5 协议的通信细节。</p>\n<h4 id=\"建立连接\"><a href=\"#建立连接\" class=\"headerlink\" title=\"建立连接\"></a>建立连接</h4><p>客户端向服务端连接连接，客户端发送的数据包如下：</p>\n<table>\n<thead>\n<tr>\n<th>VER</th>\n<th>NMETHODS</th>\n<th>METHODS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>其中各个字段的含义如下：<br>-<code>VER</code>：代表 SOCKS 的版本，SOCKS5 默认为<code>0x05</code>，其固定长度为1个字节；<br>-<code>NMETHODS</code>：表示第三个字段METHODS的长度，它的长度也是1个字节；<br>-<code>METHODS</code>：表示客户端支持的验证方式，可以有多种，他的长度是1-255个字节。</p>\n<p>目前支持的验证方式共有：</p>\n<ul>\n<li><code>0x00</code>：NO AUTHENTICATION REQUIRED（不需要验证）</li>\n<li><code>0x01</code>：GSSAPI</li>\n<li><code>0x02</code>：USERNAME/PASSWORD（用户名密码）</li>\n<li><code>0x03</code>: to X’7F’ IANA ASSIGNED</li>\n<li><code>0x80</code>: to X’FE’ RESERVED FOR PRIVATE METHODS</li>\n<li><code>0xFF</code>: NO ACCEPTABLE METHODS（都不支持，没法连接了）</li>\n</ul>\n<h4 id=\"响应连接\"><a href=\"#响应连接\" class=\"headerlink\" title=\"响应连接\"></a>响应连接</h4><p>服务端收到客户端的验证信息之后，就要回应客户端，服务端需要客户端提供哪种验证方式的信息。服务端回应的包格式如下：</p>\n<table>\n<thead>\n<tr>\n<th>VER</th>\n<th>METHOD</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>其中各个字段的含义如下：</p>\n<ul>\n<li><code>VER</code>：代表 SOCKS 的版本，SOCKS5 默认为<code>0x05</code>，其固定长度为1个字节；</li>\n<li><code>METHOD</code>：代表服务端需要客户端按此验证方式提供的验证信息，其值长度为1个字节，可为上面六种验证方式之一。</li>\n</ul>\n<p>举例说明，比如服务端不需要验证的话，可以这么回应客户端：</p>\n<table>\n<thead>\n<tr>\n<th>VER</th>\n<th>METHOD</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>0x05</code></td>\n<td><code>0x00</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"和目标服务建立连接\"><a href=\"#和目标服务建立连接\" class=\"headerlink\" title=\"和目标服务建立连接\"></a>和目标服务建立连接</h4><p>客户端发起的连接由服务端验证通过后，客户端下一步应该告诉真正目标服务的地址给服务器，服务器得到地址后再去请求真正的目标服务。也就是说客户端需要把 Google 服务的地址<code>google.com:80</code>告诉服务端，服务端再去请求<code>google.com:80</code>。<br>目标服务地址的格式为 (IP或域名)+端口，客户端需要发送的包格式如下：</p>\n<table>\n<thead>\n<tr>\n<th>VER</th>\n<th>CMD</th>\n<th>RSV</th>\n<th>ATYP</th>\n<th>DST.ADDR</th>\n<th>DST.PORT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td><code>0x00</code></td>\n<td>1</td>\n<td>Variable</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>各个字段的含义如下：</p>\n<ul>\n<li><code>VER</code>：代表 SOCKS 协议的版本，SOCKS 默认为0x05，其值长度为1个字节；</li>\n<li><code>CMD</code>：代表客户端请求的类型，值长度也是1个字节，有三种类型；<ul>\n<li><code>CONNECT</code>： <code>0x01</code>；</li>\n<li><code>BIND</code>： <code>0x02</code>；</li>\n<li><code>UDP</code>： ASSOCIATE <code>0x03</code>；</li>\n</ul>\n</li>\n<li><code>RSV</code>：保留字，值长度为1个字节；</li>\n<li><code>ATYP</code>：代表请求的远程服务器地址类型，值长度1个字节，有三种类型；<ul>\n<li><code>IPV4</code>： address: <code>0x01</code>；</li>\n<li><code>DOMAINNAME</code>: <code>0x03</code>；</li>\n<li><code>IPV6</code>： address: <code>0x04</code>；</li>\n</ul>\n</li>\n<li><code>DST.ADDR</code>：代表远程服务器的地址，根据 <code>ATYP</code> 进行解析，值长度不定；</li>\n<li><code>DST.PORT</code>：代表远程服务器的端口，要访问哪个端口的意思，值长度2个字节。</li>\n</ul>\n<p>服务端在得到来自客户端告诉的目标服务地址后，便和目标服务进行连接，不管连接成功与否，服务器都应该把连接的结果告诉客户端。在连接成功的情况下，服务端返回的包格式如下：</p>\n<table>\n<thead>\n<tr>\n<th>VER</th>\n<th>REP</th>\n<th>RSV</th>\n<th>ATYP</th>\n<th>BND.ADDR</th>\n<th>BND.PORT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td><code>0x00</code></td>\n<td>1</td>\n<td>Variable</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>各个字段的含义如下：</p>\n<ul>\n<li><code>VER</code>：代表 SOCKS 协议的版本，SOCKS 默认为0x05，其值长度为1个字节；</li>\n<li>REP代表响应状态码，值长度也是1个字节，有以下几种类型<ul>\n<li><code>0x00</code> succeeded</li>\n<li><code>0x01</code> general SOCKS server failure</li>\n<li><code>0x02</code> connection not allowed by ruleset</li>\n<li><code>0x03</code> Network unreachable</li>\n<li><code>0x04</code> Host unreachable</li>\n<li><code>0x05</code> Connection refused</li>\n<li><code>0x06</code> TTL expired</li>\n<li><code>0x07</code> Command not supported</li>\n<li><code>0x08</code> Address type not supported</li>\n<li><code>0x09</code> to <code>0xFF</code> unassigned</li>\n</ul>\n</li>\n<li><code>RSV</code>：保留字，值长度为1个字节</li>\n<li><code>ATYP</code>：代表请求的远程服务器地址类型，值长度1个字节，有三种类型<ul>\n<li>IP V4 address： <code>0x01</code></li>\n<li>DOMAINNAME： <code>0x03</code></li>\n<li>IP V6 address： <code>0x04</code></li>\n</ul>\n</li>\n<li><code>BND.ADDR</code>：表示绑定地址，值长度不定。</li>\n<li><code>BND.PORT</code>： 表示绑定端口，值长度2个字节</li>\n</ul>\n<h4 id=\"数据转发\"><a href=\"#数据转发\" class=\"headerlink\" title=\"数据转发\"></a>数据转发</h4><p>客户端在收到来自服务器成功的响应后，就会开始发送数据了，服务端在收到来自客户端的数据后，会转发到目标服务。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>SOCKS5 协议的目的其实就是为了把来自原本应该在本机直接请求目标服务的流程，放到了服务端去代理客户端访问。<br>其运行流程总结如下：</p>\n<ol>\n<li>本机和代理服务端协商和建立连接；</li>\n<li>本机告诉代理服务端目标服务的地址；</li>\n<li>代理服务端去连接目标服务，成功后告诉本机；</li>\n<li>本机开始发送原本应发送到目标服务的数据给代理服务端，由代理服务端完成数据转发。</li>\n</ol>\n<p>以上内容来自 <a href=\"http://www.ietf.org/rfc/rfc1928.txt\" target=\"_blank\" rel=\"noopener\">SOCKS5 协议规范 rfc1928</a>。</p>\n<h2 id=\"Lightsocks-实现\"><a href=\"#Lightsocks-实现\" class=\"headerlink\" title=\"Lightsocks 实现\"></a><a href=\"https://github.com/gwuhaolin/lightsocks\" target=\"_blank\" rel=\"noopener\">Lightsocks</a> 实现</h2><p>要实现 Lightsocks 需要实现两部分：运行在本地的 lightsocks-local，和运行在墙外代理服务器上 lightsocks-server。<br>下面来分别教你如果使用 Golang 来实现它们，采用 Golang 语言的原因在于：性能好、跨平台、适合高并发、学习门槛低。对Golang感兴趣？请看<a href=\"http://go.wuhaolin.cn/\" target=\"_blank\" rel=\"noopener\">Golang 中文学习资料汇总</a></p>\n<h4 id=\"实现数据混淆\"><a href=\"#实现数据混淆\" class=\"headerlink\" title=\"实现数据混淆\"></a>实现数据混淆</h4><p>在 Shadowsocks 中是采用的标准的对称加密算法去实现数据混淆的，对称算法在加密和解密过程中需要大量计算。<br>为了简单起见，Lightsocks 将采用最简单高效的方法去实现数据混淆，具体原理如下。</p>\n<p>这个数据混淆算法和对称加密很相似，两端都需要有同样的密钥。<br>这个密钥有如下要求：</p>\n<ul>\n<li>由256个 byte 组成，也就是一个数组，在 Golang 中类型表示为 <code>[256]byte</code>；</li>\n<li>这个数组必须由 0～255 这256个数字组成，一个都不能差；</li>\n<li>这个数组中第<code>I</code>个的值不能等于<code>I</code>；</li>\n</ul>\n<p>例如以下为一个合法的密钥(上为索引，下为值)：</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n<th>11</th>\n<th>12</th>\n<th>13</th>\n<th>14</th>\n<th>15</th>\n<th>16</th>\n<th>17</th>\n<th>18</th>\n<th>19</th>\n<th>20</th>\n<th>21</th>\n<th>22</th>\n<th>23</th>\n<th>24</th>\n<th>25</th>\n<th>26</th>\n<th>27</th>\n<th>28</th>\n<th>29</th>\n<th>30</th>\n<th>31</th>\n<th>32</th>\n<th>33</th>\n<th>34</th>\n<th>35</th>\n<th>36</th>\n<th>37</th>\n<th>38</th>\n<th>39</th>\n<th>40</th>\n<th>41</th>\n<th>42</th>\n<th>43</th>\n<th>44</th>\n<th>45</th>\n<th>46</th>\n<th>47</th>\n<th>48</th>\n<th>49</th>\n<th>50</th>\n<th>51</th>\n<th>52</th>\n<th>53</th>\n<th>54</th>\n<th>55</th>\n<th>56</th>\n<th>57</th>\n<th>58</th>\n<th>59</th>\n<th>60</th>\n<th>61</th>\n<th>62</th>\n<th>63</th>\n<th>64</th>\n<th>65</th>\n<th>66</th>\n<th>67</th>\n<th>68</th>\n<th>69</th>\n<th>70</th>\n<th>71</th>\n<th>72</th>\n<th>73</th>\n<th>74</th>\n<th>75</th>\n<th>76</th>\n<th>77</th>\n<th>78</th>\n<th>79</th>\n<th>80</th>\n<th>81</th>\n<th>82</th>\n<th>83</th>\n<th>84</th>\n<th>85</th>\n<th>86</th>\n<th>87</th>\n<th>88</th>\n<th>89</th>\n<th>90</th>\n<th>91</th>\n<th>92</th>\n<th>93</th>\n<th>94</th>\n<th>95</th>\n<th>96</th>\n<th>97</th>\n<th>98</th>\n<th>99</th>\n<th>100</th>\n<th>101</th>\n<th>102</th>\n<th>103</th>\n<th>104</th>\n<th>105</th>\n<th>106</th>\n<th>107</th>\n<th>108</th>\n<th>109</th>\n<th>110</th>\n<th>111</th>\n<th>112</th>\n<th>113</th>\n<th>114</th>\n<th>115</th>\n<th>116</th>\n<th>117</th>\n<th>118</th>\n<th>119</th>\n<th>120</th>\n<th>121</th>\n<th>122</th>\n<th>123</th>\n<th>124</th>\n<th>125</th>\n<th>126</th>\n<th>127</th>\n<th>128</th>\n<th>129</th>\n<th>130</th>\n<th>131</th>\n<th>132</th>\n<th>133</th>\n<th>134</th>\n<th>135</th>\n<th>136</th>\n<th>137</th>\n<th>138</th>\n<th>139</th>\n<th>140</th>\n<th>141</th>\n<th>142</th>\n<th>143</th>\n<th>144</th>\n<th>145</th>\n<th>146</th>\n<th>147</th>\n<th>148</th>\n<th>149</th>\n<th>150</th>\n<th>151</th>\n<th>152</th>\n<th>153</th>\n<th>154</th>\n<th>155</th>\n<th>156</th>\n<th>157</th>\n<th>158</th>\n<th>159</th>\n<th>160</th>\n<th>161</th>\n<th>162</th>\n<th>163</th>\n<th>164</th>\n<th>165</th>\n<th>166</th>\n<th>167</th>\n<th>168</th>\n<th>169</th>\n<th>170</th>\n<th>171</th>\n<th>172</th>\n<th>173</th>\n<th>174</th>\n<th>175</th>\n<th>176</th>\n<th>177</th>\n<th>178</th>\n<th>179</th>\n<th>180</th>\n<th>181</th>\n<th>182</th>\n<th>183</th>\n<th>184</th>\n<th>185</th>\n<th>186</th>\n<th>187</th>\n<th>188</th>\n<th>189</th>\n<th>190</th>\n<th>191</th>\n<th>192</th>\n<th>193</th>\n<th>194</th>\n<th>195</th>\n<th>196</th>\n<th>197</th>\n<th>198</th>\n<th>199</th>\n<th>200</th>\n<th>201</th>\n<th>202</th>\n<th>203</th>\n<th>204</th>\n<th>205</th>\n<th>206</th>\n<th>207</th>\n<th>208</th>\n<th>209</th>\n<th>210</th>\n<th>211</th>\n<th>212</th>\n<th>213</th>\n<th>214</th>\n<th>215</th>\n<th>216</th>\n<th>217</th>\n<th>218</th>\n<th>219</th>\n<th>220</th>\n<th>221</th>\n<th>222</th>\n<th>223</th>\n<th>224</th>\n<th>225</th>\n<th>226</th>\n<th>227</th>\n<th>228</th>\n<th>229</th>\n<th>230</th>\n<th>231</th>\n<th>232</th>\n<th>233</th>\n<th>234</th>\n<th>235</th>\n<th>236</th>\n<th>237</th>\n<th>238</th>\n<th>239</th>\n<th>240</th>\n<th>241</th>\n<th>242</th>\n<th>243</th>\n<th>244</th>\n<th>245</th>\n<th>246</th>\n<th>247</th>\n<th>248</th>\n<th>249</th>\n<th>250</th>\n<th>251</th>\n<th>252</th>\n<th>253</th>\n<th>254</th>\n<th>255</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>186</td>\n<td>118</td>\n<td>82</td>\n<td>201</td>\n<td>235</td>\n<td>236</td>\n<td>180</td>\n<td>66</td>\n<td>228</td>\n<td>96</td>\n<td>43</td>\n<td>90</td>\n<td>203</td>\n<td>200</td>\n<td>34</td>\n<td>104</td>\n<td>41</td>\n<td>222</td>\n<td>165</td>\n<td>74</td>\n<td>240</td>\n<td>20</td>\n<td>244</td>\n<td>67</td>\n<td>114</td>\n<td>191</td>\n<td>220</td>\n<td>147</td>\n<td>196</td>\n<td>183</td>\n<td>229</td>\n<td>123</td>\n<td>208</td>\n<td>19</td>\n<td>127</td>\n<td>187</td>\n<td>84</td>\n<td>148</td>\n<td>56</td>\n<td>170</td>\n<td>133</td>\n<td>160</td>\n<td>202</td>\n<td>21</td>\n<td>53</td>\n<td>78</td>\n<td>59</td>\n<td>64</td>\n<td>120</td>\n<td>27</td>\n<td>167</td>\n<td>175</td>\n<td>39</td>\n<td>10</td>\n<td>4</td>\n<td>132</td>\n<td>89</td>\n<td>230</td>\n<td>152</td>\n<td>73</td>\n<td>221</td>\n<td>88</td>\n<td>141</td>\n<td>158</td>\n<td>251</td>\n<td>79</td>\n<td>225</td>\n<td>87</td>\n<td>14</td>\n<td>23</td>\n<td>68</td>\n<td>250</td>\n<td>199</td>\n<td>168</td>\n<td>218</td>\n<td>60</td>\n<td>40</td>\n<td>169</td>\n<td>75</td>\n<td>86</td>\n<td>153</td>\n<td>134</td>\n<td>83</td>\n<td>49</td>\n<td>128</td>\n<td>231</td>\n<td>217</td>\n<td>239</td>\n<td>226</td>\n<td>177</td>\n<td>57</td>\n<td>24</td>\n<td>234</td>\n<td>63</td>\n<td>7</td>\n<td>112</td>\n<td>166</td>\n<td>211</td>\n<td>254</td>\n<td>179</td>\n<td>157</td>\n<td>215</td>\n<td>227</td>\n<td>224</td>\n<td>233</td>\n<td>81</td>\n<td>172</td>\n<td>26</td>\n<td>122</td>\n<td>219</td>\n<td>48</td>\n<td>151</td>\n<td>232</td>\n<td>50</td>\n<td>108</td>\n<td>44</td>\n<td>0</td>\n<td>192</td>\n<td>65</td>\n<td>76</td>\n<td>109</td>\n<td>252</td>\n<td>248</td>\n<td>47</td>\n<td>154</td>\n<td>33</td>\n<td>209</td>\n<td>115</td>\n<td>31</td>\n<td>15</td>\n<td>45</td>\n<td>206</td>\n<td>247</td>\n<td>124</td>\n<td>77</td>\n<td>8</td>\n<td>182</td>\n<td>144</td>\n<td>1</td>\n<td>72</td>\n<td>131</td>\n<td>52</td>\n<td>245</td>\n<td>198</td>\n<td>238</td>\n<td>5</td>\n<td>188</td>\n<td>116</td>\n<td>55</td>\n<td>216</td>\n<td>155</td>\n<td>2</td>\n<td>178</td>\n<td>189</td>\n<td>162</td>\n<td>136</td>\n<td>243</td>\n<td>184</td>\n<td>58</td>\n<td>69</td>\n<td>70</td>\n<td>99</td>\n<td>36</td>\n<td>25</td>\n<td>35</td>\n<td>174</td>\n<td>195</td>\n<td>18</td>\n<td>205</td>\n<td>30</td>\n<td>190</td>\n<td>142</td>\n<td>210</td>\n<td>113</td>\n<td>145</td>\n<td>101</td>\n<td>97</td>\n<td>161</td>\n<td>100</td>\n<td>91</td>\n<td>242</td>\n<td>138</td>\n<td>93</td>\n<td>171</td>\n<td>98</td>\n<td>237</td>\n<td>212</td>\n<td>255</td>\n<td>80</td>\n<td>102</td>\n<td>119</td>\n<td>204</td>\n<td>107</td>\n<td>105</td>\n<td>111</td>\n<td>11</td>\n<td>29</td>\n<td>146</td>\n<td>129</td>\n<td>117</td>\n<td>135</td>\n<td>176</td>\n<td>163</td>\n<td>207</td>\n<td>103</td>\n<td>22</td>\n<td>246</td>\n<td>125</td>\n<td>150</td>\n<td>106</td>\n<td>126</td>\n<td>197</td>\n<td>249</td>\n<td>62</td>\n<td>51</td>\n<td>193</td>\n<td>32</td>\n<td>3</td>\n<td>110</td>\n<td>46</td>\n<td>85</td>\n<td>71</td>\n<td>159</td>\n<td>139</td>\n<td>12</td>\n<td>164</td>\n<td>95</td>\n<td>121</td>\n<td>140</td>\n<td>241</td>\n<td>253</td>\n<td>130</td>\n<td>173</td>\n<td>213</td>\n<td>54</td>\n<td>143</td>\n<td>16</td>\n<td>94</td>\n<td>9</td>\n<td>61</td>\n<td>156</td>\n<td>214</td>\n<td>28</td>\n<td>17</td>\n<td>37</td>\n<td>42</td>\n<td>181</td>\n<td>149</td>\n<td>185</td>\n<td>223</td>\n<td>92</td>\n<td>38</td>\n<td>13</td>\n<td>194</td>\n<td>6</td>\n<td>137</td>\n</tr>\n</tbody>\n</table>\n<p>如果原数据为 <code>[5,0,1,2,3]</code>，则采用以上密钥加密后变成 <code>[236,186,118,82,201]</code>。<br>如果加密后的数据为 <code>[186,118,82,201,235]</code>，则采用以上密钥解密得到的原数据为 <code>[0,1,2,3,4]</code></p>\n<p>聪明的你肯定看懂了其中的规律：把1～255 这256个数字确定一种一对一的映射关系，加密是从一个数字得到对应的一个数字，而解密则是反向的过程，而这个密钥的作用正是描述这个映射关系。<br>这其实就是中学学的<strong>反函数</strong>。</p>\n<p>为什么要这样设计数据混淆算法呢？在数据传输时，数据是以 byte 为最小单位流式传输的。一个 byte 的取值只可能是 0～255。该混淆算法可以直接对一个个 byte 进行加解密，而无需像标准的对称算法那样只能对一大块数据进行加密。<br>再加上本算法的加解密 N byte 数据的算法复杂度为 N（直接通过数组索引访问），非常适合流式加密。</p>\n<p>以上加密算法的安全性怎么样呢？符合以上要求的密钥匙有多少种组合呢？我们来算算：<br>这其实就是初中学的排列组合中的排列问题，形象点其实就是，把 0～255 个不同编号的人安排到 0～255 个不同编号的坑去，并且不能有编号一样的情况，有多少种排法。<br>也就是 <code>A(255,255)=255*254*253*...*1=255!</code>，但其中有一半为有重复的情况，<br>最终结果为 <code>255!/2</code>，<br>其值大概为 <code>10^500</code> 这个数量级。</p>\n<p>以上加密算法虽然破绽很多，但足以实现高效的数据混淆，骗过防火墙。</p>\n<p>目前采用对称加密算法实现数据混淆的 Shadowsocks 已经能被一些防火墙通过机器学习算法通过特征分析识别出传输的原内容适合合法，而 Lightsocks 的这套混淆算法目前还不能被轻易的识别出来。</p>\n<p>随机产生一个以上密钥匙的<a href=\"https://github.com/gwuhaolin/lightsocks/blob/master/core/password.go\" target=\"_blank\" rel=\"noopener\">代码如下</a>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> core</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"math/rand\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">const</span> PasswordLength = <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Password [PasswordLength]<span class=\"keyword\">byte</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 更新随机种子，防止生成一样的随机密码</span></span><br><span class=\"line\">\trand.Seed(time.Now().Unix())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 产生 256个byte随机组合的 密码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RandPassword</span><span class=\"params\">()</span> *<span class=\"title\">Password</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 随机生成一个由  0~255 组成的 byte 数组</span></span><br><span class=\"line\">\tintArr := rand.Perm(PasswordLength)</span><br><span class=\"line\">\tpassword := &amp;Password&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> intArr &#123;</span><br><span class=\"line\">\t\tpassword[i] = <span class=\"keyword\">byte</span>(v)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i == v &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 确保不会出现如何一个byte位出现重复</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> RandPassword()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> password</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对数据进行加密解密的<a href=\"https://github.com/gwuhaolin/lightsocks/blob/master/core/cipher.go\" target=\"_blank\" rel=\"noopener\">代码如下</a>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> core</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cipher <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 编码用的密码</span></span><br><span class=\"line\">\tencodePassword *Password</span><br><span class=\"line\">\t<span class=\"comment\">// 解码用的密码</span></span><br><span class=\"line\">\tdecodePassword *Password</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加密原数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cipher *Cipher)</span> <span class=\"title\">encode</span><span class=\"params\">(bs []<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> bs &#123;</span><br><span class=\"line\">\t\tbs[i] = cipher.encodePassword[v]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解码加密后的数据到原数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cipher *Cipher)</span> <span class=\"title\">decode</span><span class=\"params\">(bs []<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> bs &#123;</span><br><span class=\"line\">\t\tbs[i] = cipher.decodePassword[v]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新建一个编码解码器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewCipher</span><span class=\"params\">(encodePassword *Password)</span> *<span class=\"title\">Cipher</span></span> &#123;</span><br><span class=\"line\">\tdecodePassword := &amp;Password&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> encodePassword &#123;</span><br><span class=\"line\">\t\tencodePassword[i] = v</span><br><span class=\"line\">\t\tdecodePassword[v] = <span class=\"keyword\">byte</span>(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Cipher&#123;</span><br><span class=\"line\">\t\tencodePassword: encodePassword,</span><br><span class=\"line\">\t\tdecodePassword: decodePassword,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再使用以上的 Cipher 去封装一个加密传输的 SecureSocket，以方便直接加解密 TCP Socket 中的流式数据，<a href=\"https://github.com/gwuhaolin/lightsocks/blob/master/core/securesocket.go\" target=\"_blank\" rel=\"noopener\">代码如下</a>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> core</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"errors\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"io\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tBufSize = <span class=\"number\">1024</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加密传输的 TCP Socket</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> SecureSocket <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tCipher     *Cipher</span><br><span class=\"line\">\tListenAddr *net.TCPAddr</span><br><span class=\"line\">\tRemoteAddr *net.TCPAddr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从输入流里读取加密过的数据，解密后把原数据放到bs里</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(secureSocket *SecureSocket)</span> <span class=\"title\">DecodeRead</span><span class=\"params\">(conn *net.TCPConn, bs []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tn, err = conn.Read(bs)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsecureSocket.Cipher.decode(bs[:n])</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把放在bs里的数据加密后立即全部写入输出流</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(secureSocket *SecureSocket)</span> <span class=\"title\">EncodeWrite</span><span class=\"params\">(conn *net.TCPConn, bs []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tsecureSocket.Cipher.encode(bs)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> conn.Write(bs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从src中源源不断的读取原数据加密后写入到dst，直到src中没有数据可以再读取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(secureSocket *SecureSocket)</span> <span class=\"title\">EncodeCopy</span><span class=\"params\">(dst *net.TCPConn, src *net.TCPConn)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, BufSize)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\treadCount, errRead := src.Read(buf)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> errRead != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> errRead != io.EOF &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> errRead</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> readCount &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\twriteCount, errWrite := secureSocket.EncodeWrite(dst, buf[<span class=\"number\">0</span>:readCount])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> errWrite != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> errWrite</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> readCount != writeCount &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> io.ErrShortWrite</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从src中源源不断的读取加密后的数据解密后写入到dst，直到src中没有数据可以再读取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(secureSocket *SecureSocket)</span> <span class=\"title\">DecodeCopy</span><span class=\"params\">(dst *net.TCPConn, src *net.TCPConn)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, BufSize)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\treadCount, errRead := secureSocket.DecodeRead(src, buf)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> errRead != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> errRead != io.EOF &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> errRead</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> readCount &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\twriteCount, errWrite := dst.Write(buf[<span class=\"number\">0</span>:readCount])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> errWrite != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> errWrite</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> readCount != writeCount &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> io.ErrShortWrite</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 和远程的socket建立连接，他们之间的数据传输会加密</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(secureSocket *SecureSocket)</span> <span class=\"title\">DialRemote</span><span class=\"params\">()</span> <span class=\"params\">(*net.TCPConn, error)</span></span> &#123;</span><br><span class=\"line\">\tremoteConn, err := net.DialTCP(<span class=\"string\">\"tcp\"</span>, <span class=\"literal\">nil</span>, secureSocket.RemoteAddr)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, errors.New(fmt.Sprintf(<span class=\"string\">\"连接到远程服务器 %s 失败:%s\"</span>, secureSocket.RemoteAddr, err))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> remoteConn, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个 SecureSocket 用于 local 端和 server 端之间进行 TCP 通信，并且只使用 SecureSocket 通信时中间传输的数据会被加密，防火墙无法读到原数据。 </p>\n<h4 id=\"实现-local-端\"><a href=\"#实现-local-端\" class=\"headerlink\" title=\"实现 local 端\"></a>实现 local 端</h4><p>运行在本机的 local 端的职责是把本机程序发送给它的数据经过加密后转发给墙外的代理服务器，总体工作流程如下：</p>\n<ol>\n<li>监听来自本机浏览器的代理请求；</li>\n<li>转发前加密数据；</li>\n<li>转发socket数据到墙外代理服务端；</li>\n<li>把服务端返回的数据转发给用户的浏览器。</li>\n</ol>\n<p>实现以上功能的 local 端<a href=\"https://github.com/gwuhaolin/lightsocks/blob/master/local/local.go\" target=\"_blank\" rel=\"noopener\">代码如下</a>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> local</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"github.com/gwuhaolin/lightsocks/core\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LsLocal <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*core.SecureSocket</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新建一个本地端</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(password *core.Password, listenAddr, remoteAddr *net.TCPAddr)</span> *<span class=\"title\">LsLocal</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;LsLocal&#123;</span><br><span class=\"line\">\t\tSecureSocket: &amp;core.SecureSocket&#123;</span><br><span class=\"line\">\t\t\tCipher:     core.NewCipher(password),</span><br><span class=\"line\">\t\t\tListenAddr: listenAddr,</span><br><span class=\"line\">\t\t\tRemoteAddr: remoteAddr,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 本地端启动监听，接收来自本机浏览器的连接</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(local *LsLocal)</span> <span class=\"title\">Listen</span><span class=\"params\">(didListen <span class=\"keyword\">func</span>(listenAddr net.Addr)</span>) <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\tlistener, err := net.ListenTCP(<span class=\"string\">\"tcp\"</span>, local.ListenAddr)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> listener.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> didListen != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tdidListen(listener.Addr())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tuserConn, err := listener.AcceptTCP()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// userConn被关闭时直接清除所有数据 不管没有发送的数据</span></span><br><span class=\"line\">\t\tuserConn.SetLinger(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> local.handleConn(userConn)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(local *LsLocal)</span> <span class=\"title\">handleConn</span><span class=\"params\">(userConn *net.TCPConn)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> userConn.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tproxyServer, err := local.DialRemote()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Println(err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> proxyServer.Close()</span><br><span class=\"line\">\t<span class=\"comment\">// Conn被关闭时直接清除所有数据 不管没有发送的数据</span></span><br><span class=\"line\">\tproxyServer.SetLinger(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 进行转发</span></span><br><span class=\"line\">\t<span class=\"comment\">// 从 proxyServer 读取数据发送到 localUser</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\terr := local.DecodeCopy(userConn, proxyServer)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 在 copy 的过程中可能会存在网络超时等 error 被 return，只要有一个发生了错误就退出本次工作</span></span><br><span class=\"line\">\t\t\tuserConn.Close()</span><br><span class=\"line\">\t\t\tproxyServer.Close()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"comment\">// 从 localUser 发送数据发送到 proxyServer，这里因为处在翻墙阶段出现网络错误的概率更大</span></span><br><span class=\"line\">\tlocal.EncodeCopy(proxyServer, userConn)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"实现-server-端\"><a href=\"#实现-server-端\" class=\"headerlink\" title=\"实现 server 端\"></a>实现 server 端</h4><p>运行在墙外代理服务器的 server 端职责如下：</p>\n<ol>\n<li>监听来自本地代理客户端的请求；</li>\n<li>解密本地代理客户端请求的数据，解析 SOCKS5 协议，连接用户浏览器真正想要连接的远程服务器；</li>\n<li>转发用户浏览器真正想要连接的远程服务器返回的数据的加密后的内容到本地代理客户端。</li>\n</ol>\n<p>实现以上功能的<a href=\"https://github.com/gwuhaolin/lightsocks/blob/master/server/server.go\" target=\"_blank\" rel=\"noopener\">代码如下</a>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"encoding/binary\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/gwuhaolin/lightsocks/core\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LsServer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*core.SecureSocket</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新建一个服务端</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(password *core.Password, listenAddr *net.TCPAddr)</span> *<span class=\"title\">LsServer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;LsServer&#123;</span><br><span class=\"line\">\t\tSecureSocket: &amp;core.SecureSocket&#123;</span><br><span class=\"line\">\t\t\tCipher:     core.NewCipher(password),</span><br><span class=\"line\">\t\t\tListenAddr: listenAddr,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行服务端并且监听来自本地代理客户端的请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(lsServer *LsServer)</span> <span class=\"title\">Listen</span><span class=\"params\">(didListen <span class=\"keyword\">func</span>(listenAddr net.Addr)</span>) <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\tlistener, err := net.ListenTCP(<span class=\"string\">\"tcp\"</span>, lsServer.ListenAddr)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> listener.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> didListen != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tdidListen(listener.Addr())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tlocalConn, err := listener.AcceptTCP()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// localConn被关闭时直接清除所有数据 不管没有发送的数据</span></span><br><span class=\"line\">\t\tlocalConn.SetLinger(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> lsServer.handleConn(localConn)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解 SOCKS5 协议</span></span><br><span class=\"line\"><span class=\"comment\">// https://www.ietf.org/rfc/rfc1928.txt</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(lsServer *LsServer)</span> <span class=\"title\">handleConn</span><span class=\"params\">(localConn *net.TCPConn)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> localConn.Close()</span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">256</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t   The localConn connects to the dstServer, and sends a ver</span></span><br><span class=\"line\"><span class=\"comment\">\t   identifier/method selection message:</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          |VER | NMETHODS | METHODS  |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          | 1  |    1     | 1 to 255 |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t   The VER field is set to X'05' for this ver of the protocol.  The</span></span><br><span class=\"line\"><span class=\"comment\">\t   NMETHODS field contains the number of method identifier octets that</span></span><br><span class=\"line\"><span class=\"comment\">\t   appear in the METHODS field.</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"comment\">// 第一个字段VER代表Socks的版本，Socks5默认为0x05，其固定长度为1个字节</span></span><br><span class=\"line\">\t_, err := lsServer.DecodeRead(localConn, buf)</span><br><span class=\"line\">\t<span class=\"comment\">// 只支持版本5</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> || buf[<span class=\"number\">0</span>] != <span class=\"number\">0x05</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t   The dstServer selects from one of the methods given in METHODS, and</span></span><br><span class=\"line\"><span class=\"comment\">\t   sends a METHOD selection message:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+--------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          |VER | METHOD |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+--------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          | 1  |   1    |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+--------+</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"comment\">// 不需要验证，直接验证通过</span></span><br><span class=\"line\">\tlsServer.EncodeWrite(localConn, []<span class=\"keyword\">byte</span>&#123;<span class=\"number\">0x05</span>, <span class=\"number\">0x00</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+-----+-------+------+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+-----+-------+------+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          | 1  |  1  | X'00' |  1   | Variable |    2     |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+-----+-------+------+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 获取真正的远程服务的地址</span></span><br><span class=\"line\">\tn, err := lsServer.DecodeRead(localConn, buf)</span><br><span class=\"line\">\t<span class=\"comment\">// n 最短的长度为7 情况为 ATYP=3 DST.ADDR占用1字节 值为0x0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> || n &lt; <span class=\"number\">7</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// CMD代表客户端请求的类型，值长度也是1个字节，有三种类型</span></span><br><span class=\"line\">\t<span class=\"comment\">// CONNECT X'01'</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> buf[<span class=\"number\">1</span>] != <span class=\"number\">0x01</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 目前只支持 CONNECT</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> dIP []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"comment\">// aType 代表请求的远程服务器地址类型，值长度1个字节，有三种类型</span></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> buf[<span class=\"number\">3</span>] &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">0x01</span>:</span><br><span class=\"line\">\t\t<span class=\"comment\">//\tIP V4 address: X'01'</span></span><br><span class=\"line\">\t\tdIP = buf[<span class=\"number\">4</span> : <span class=\"number\">4</span>+net.IPv4len]</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">0x03</span>:</span><br><span class=\"line\">\t\t<span class=\"comment\">//\tDOMAINNAME: X'03'</span></span><br><span class=\"line\">\t\tipAddr, err := net.ResolveIPAddr(<span class=\"string\">\"ip\"</span>, <span class=\"keyword\">string</span>(buf[<span class=\"number\">5</span>:n<span class=\"number\">-2</span>]))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tdIP = ipAddr.IP</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">0x04</span>:</span><br><span class=\"line\">\t\t<span class=\"comment\">//\tIP V6 address: X'04'</span></span><br><span class=\"line\">\t\tdIP = buf[<span class=\"number\">4</span> : <span class=\"number\">4</span>+net.IPv6len]</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdPort := buf[n<span class=\"number\">-2</span>:]</span><br><span class=\"line\">\tdstAddr := &amp;net.TCPAddr&#123;</span><br><span class=\"line\">\t\tIP:   dIP,</span><br><span class=\"line\">\t\tPort: <span class=\"keyword\">int</span>(binary.BigEndian.Uint16(dPort)),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 连接真正的远程服务</span></span><br><span class=\"line\">\tdstServer, err := net.DialTCP(<span class=\"string\">\"tcp\"</span>, <span class=\"literal\">nil</span>, dstAddr)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> dstServer.Close()</span><br><span class=\"line\">\t\t<span class=\"comment\">// Conn被关闭时直接清除所有数据 不管没有发送的数据</span></span><br><span class=\"line\">\t\tdstServer.SetLinger(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 响应客户端连接成功</span></span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+-----+-------+------+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+-----+-------+------+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          | 1  |  1  | X'00' |  1   | Variable |    2     |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+-----+-------+------+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t*/</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 响应客户端连接成功</span></span><br><span class=\"line\">\t\tlsServer.EncodeWrite(localConn, []<span class=\"keyword\">byte</span>&#123;<span class=\"number\">0x05</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 进行转发</span></span><br><span class=\"line\">\t<span class=\"comment\">// 从 localUser 读取数据发送到 dstServer</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\terr := lsServer.DecodeCopy(dstServer, localConn)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 在 copy 的过程中可能会存在网络超时等 error 被 return，只要有一个发生了错误就退出本次工作</span></span><br><span class=\"line\">\t\t\tlocalConn.Close()</span><br><span class=\"line\">\t\t\tdstServer.Close()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"comment\">// 从 dstServer 读取数据发送到 localUser，这里因为处在翻墙阶段出现网络错误的概率更大</span></span><br><span class=\"line\">\tlsServer.EncodeCopy(localConn, dstServer)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>以上就是实现一个轻量级 Shadowsocks 的核心代码。其它一些零碎的代码，例如启动入口、配置读写等，可以去 <a href=\"https://github.com/gwuhaolin/lightsocks\" target=\"_blank\" rel=\"noopener\">lightsocks</a> 项目中阅读完整代码。</p>\n<p><a href=\"http://wuhaolin.cn/2017/11/03/%E4%BD%A0%E4%B9%9F%E8%83%BD%E5%86%99%E4%B8%AA%20Shadowsocks/\">阅读原文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文将教你从0写一个<a href=\"https://github.com/shadowsocks/shadowsocks-go\" target=\"_blank\" rel=\"noopener\">Shadowsocks</a>，无需任何基础，读完本文你就能完成一个轻量级、高性能的 Shadowsocks 代替品。</p>\n<p>我们暂且把最终完成的项目叫做 Lightsocks，如果你很急切地想看到结果，可以先体验本文最终完成的项目 <a href=\"https://github.com/gwuhaolin/lightsocks\" target=\"_blank\" rel=\"noopener\">Lightsocks</a> ，也可以下载阅读源码。</p>\n<h2 id=\"认识-Shadowsocks\"><a href=\"#认识-Shadowsocks\" class=\"headerlink\" title=\"认识 Shadowsocks\"></a>认识 Shadowsocks</h2><p>Shadowsocks 是一个能骗过防火墙的网络代理工具。它把要传输的原数据经过加密后再传输，网络中的防火墙由于得不出要传输的原内容是什么而只好放行，于是就完成了防火墙穿透，也即是所谓的“翻墙”。</p>\n<p>在自由的网络环境下，在本机上访问服务时是直接和远程服务建立连接传输数据，流程如图：<br><img src=\"https://user-images.githubusercontent.com/5773264/32371367-8c231024-c05e-11e7-87a8-f977577a6b89.png\" alt=\"自由网络环境下的传输流程\"></p>\n<p>但在受限的网络环境下会有防火墙，本机电脑和远程服务之间传输的数据都必须通过防火墙的检查，流程如图：<br><img src=\"https://user-images.githubusercontent.com/5773264/32371437-d8cb8852-c05e-11e7-9872-a6708bbe65ba.png\" alt=\"受限网络环境下的传输流程\"><br>如果防火墙发现你在传输受限的内容，就把拦截本次传输，就会导致在本机无法访问远程服务。</p>\n<p>而 Shadowsocks 所做的就是把传输的数据加密，防火墙得到的数据是加密后的数据，防火墙不知道传输的原内容是什么，于是防火墙就放行本次请求，于是在本机就访问到了远程服务，流程如图：<br><img src=\"https://user-images.githubusercontent.com/5773264/32371932-cdc55044-c060-11e7-9b0e-c1a7fec2b428.png\" alt=\"shadowsocks下的传输流程\"></p>\n<p>也就是说使用 Shadowsocks 的前提是：</p>\n<ul>\n<li>一台在防火墙之外的服务器；</li>\n<li>在本机需要安装 Shadowsocks 本地端，用于加密传输数据；</li>\n<li>服务器需要安装 Shadowsocks 服务端，用于解密加密后的传输数据，解密出原数据后发送到目标服务器。</li>\n</ul>\n<h2 id=\"Shadowsocks-原理\"><a href=\"#Shadowsocks-原理\" class=\"headerlink\" title=\"Shadowsocks 原理\"></a>Shadowsocks 原理</h2><p>Shadowsocks 由两部分组成，运行在本地的 ss-local 和运行在防火墙之外服务器上的 ss-server，下面来分别详细介绍它们的职责（以下对 Shadowsocks 原理的解析只是我的大概估计，可能会有细微的差别）。</p>\n<h4 id=\"ss-local\"><a href=\"#ss-local\" class=\"headerlink\" title=\"ss-local\"></a>ss-local</h4><p>ss-local 的职责是在本机启动和监听着一个服务，本地软件的网络请求都先发送到 ss-local，ss-local 收到来自本地软件的网络请求后，把要传输的原数据根据用户配置的加密方法和密码进行加密，再转发到墙外的服务器去。</p>\n<h4 id=\"ss-server\"><a href=\"#ss-server\" class=\"headerlink\" title=\"ss-server\"></a>ss-server</h4><p>ss-server 的职责是在墙外服务器启动和监听一个服务，该服务监听来自本机的 ss-local 的请求。在收到来自 ss-local 转发过来的数据时，会先根据用户配置的加密方法和密码对数据进行对称解密，以获得加密后的数据的原内容。同时还会解 SOCKS5 协议，读出本次请求真正的目标服务地址(例如 Google 服务器地址)，再把解密后得到的原数据转发到真正的目标服务。</p>\n<p>当真正的目标服务返回了数据时，ss-server 端会把返回的数据加密后转发给对应的 ss-local 端，ss-local 端收到数据再解密后，转发给本机的软件。这是一个对称相反的过程。</p>\n<p>由于 ss-local 和 ss-server 端都需要用对称加密算法对数据进行加密和解密，因此这两端的加密方法和密码必须配置为一样。Shadowsocks 提供了一系列标准可靠的对称算法可供用户选择，例如 rc4、aes、des、chacha20 等等。Shadowsocks 对数据加密后再传输的目的是为了混淆原数据，让途中的防火墙无法得出传输的原数据。但其实用这些安全性高计算量大的对称加密算法去实现混淆有点“杀鸡用牛刀”。</p>\n<h2 id=\"SOCKS5-协议介绍\"><a href=\"#SOCKS5-协议介绍\" class=\"headerlink\" title=\"SOCKS5 协议介绍\"></a>SOCKS5 协议介绍</h2><p>Shadowsocks 的数据传输是建立在 SOCKS5 协议之上的，SOCKS5 是 TCP/IP 层面的网络代理协议。<br>ss-server 端解密出来的数据就是采用 SOCKS5 协议封装的，通过 SOCKS5 协议 ss-server 端能读出本机软件想访问的服务的真正地址以及要传输的原数据，下面来详细介绍  SOCKS5 协议的通信细节。</p>\n<h4 id=\"建立连接\"><a href=\"#建立连接\" class=\"headerlink\" title=\"建立连接\"></a>建立连接</h4><p>客户端向服务端连接连接，客户端发送的数据包如下：</p>\n<table>\n<thead>\n<tr>\n<th>VER</th>\n<th>NMETHODS</th>\n<th>METHODS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>其中各个字段的含义如下：<br>-<code>VER</code>：代表 SOCKS 的版本，SOCKS5 默认为<code>0x05</code>，其固定长度为1个字节；<br>-<code>NMETHODS</code>：表示第三个字段METHODS的长度，它的长度也是1个字节；<br>-<code>METHODS</code>：表示客户端支持的验证方式，可以有多种，他的长度是1-255个字节。</p>\n<p>目前支持的验证方式共有：</p>\n<ul>\n<li><code>0x00</code>：NO AUTHENTICATION REQUIRED（不需要验证）</li>\n<li><code>0x01</code>：GSSAPI</li>\n<li><code>0x02</code>：USERNAME/PASSWORD（用户名密码）</li>\n<li><code>0x03</code>: to X’7F’ IANA ASSIGNED</li>\n<li><code>0x80</code>: to X’FE’ RESERVED FOR PRIVATE METHODS</li>\n<li><code>0xFF</code>: NO ACCEPTABLE METHODS（都不支持，没法连接了）</li>\n</ul>\n<h4 id=\"响应连接\"><a href=\"#响应连接\" class=\"headerlink\" title=\"响应连接\"></a>响应连接</h4><p>服务端收到客户端的验证信息之后，就要回应客户端，服务端需要客户端提供哪种验证方式的信息。服务端回应的包格式如下：</p>\n<table>\n<thead>\n<tr>\n<th>VER</th>\n<th>METHOD</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>其中各个字段的含义如下：</p>\n<ul>\n<li><code>VER</code>：代表 SOCKS 的版本，SOCKS5 默认为<code>0x05</code>，其固定长度为1个字节；</li>\n<li><code>METHOD</code>：代表服务端需要客户端按此验证方式提供的验证信息，其值长度为1个字节，可为上面六种验证方式之一。</li>\n</ul>\n<p>举例说明，比如服务端不需要验证的话，可以这么回应客户端：</p>\n<table>\n<thead>\n<tr>\n<th>VER</th>\n<th>METHOD</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>0x05</code></td>\n<td><code>0x00</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"和目标服务建立连接\"><a href=\"#和目标服务建立连接\" class=\"headerlink\" title=\"和目标服务建立连接\"></a>和目标服务建立连接</h4><p>客户端发起的连接由服务端验证通过后，客户端下一步应该告诉真正目标服务的地址给服务器，服务器得到地址后再去请求真正的目标服务。也就是说客户端需要把 Google 服务的地址<code>google.com:80</code>告诉服务端，服务端再去请求<code>google.com:80</code>。<br>目标服务地址的格式为 (IP或域名)+端口，客户端需要发送的包格式如下：</p>\n<table>\n<thead>\n<tr>\n<th>VER</th>\n<th>CMD</th>\n<th>RSV</th>\n<th>ATYP</th>\n<th>DST.ADDR</th>\n<th>DST.PORT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td><code>0x00</code></td>\n<td>1</td>\n<td>Variable</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>各个字段的含义如下：</p>\n<ul>\n<li><code>VER</code>：代表 SOCKS 协议的版本，SOCKS 默认为0x05，其值长度为1个字节；</li>\n<li><code>CMD</code>：代表客户端请求的类型，值长度也是1个字节，有三种类型；<ul>\n<li><code>CONNECT</code>： <code>0x01</code>；</li>\n<li><code>BIND</code>： <code>0x02</code>；</li>\n<li><code>UDP</code>： ASSOCIATE <code>0x03</code>；</li>\n</ul>\n</li>\n<li><code>RSV</code>：保留字，值长度为1个字节；</li>\n<li><code>ATYP</code>：代表请求的远程服务器地址类型，值长度1个字节，有三种类型；<ul>\n<li><code>IPV4</code>： address: <code>0x01</code>；</li>\n<li><code>DOMAINNAME</code>: <code>0x03</code>；</li>\n<li><code>IPV6</code>： address: <code>0x04</code>；</li>\n</ul>\n</li>\n<li><code>DST.ADDR</code>：代表远程服务器的地址，根据 <code>ATYP</code> 进行解析，值长度不定；</li>\n<li><code>DST.PORT</code>：代表远程服务器的端口，要访问哪个端口的意思，值长度2个字节。</li>\n</ul>\n<p>服务端在得到来自客户端告诉的目标服务地址后，便和目标服务进行连接，不管连接成功与否，服务器都应该把连接的结果告诉客户端。在连接成功的情况下，服务端返回的包格式如下：</p>\n<table>\n<thead>\n<tr>\n<th>VER</th>\n<th>REP</th>\n<th>RSV</th>\n<th>ATYP</th>\n<th>BND.ADDR</th>\n<th>BND.PORT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td><code>0x00</code></td>\n<td>1</td>\n<td>Variable</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>各个字段的含义如下：</p>\n<ul>\n<li><code>VER</code>：代表 SOCKS 协议的版本，SOCKS 默认为0x05，其值长度为1个字节；</li>\n<li>REP代表响应状态码，值长度也是1个字节，有以下几种类型<ul>\n<li><code>0x00</code> succeeded</li>\n<li><code>0x01</code> general SOCKS server failure</li>\n<li><code>0x02</code> connection not allowed by ruleset</li>\n<li><code>0x03</code> Network unreachable</li>\n<li><code>0x04</code> Host unreachable</li>\n<li><code>0x05</code> Connection refused</li>\n<li><code>0x06</code> TTL expired</li>\n<li><code>0x07</code> Command not supported</li>\n<li><code>0x08</code> Address type not supported</li>\n<li><code>0x09</code> to <code>0xFF</code> unassigned</li>\n</ul>\n</li>\n<li><code>RSV</code>：保留字，值长度为1个字节</li>\n<li><code>ATYP</code>：代表请求的远程服务器地址类型，值长度1个字节，有三种类型<ul>\n<li>IP V4 address： <code>0x01</code></li>\n<li>DOMAINNAME： <code>0x03</code></li>\n<li>IP V6 address： <code>0x04</code></li>\n</ul>\n</li>\n<li><code>BND.ADDR</code>：表示绑定地址，值长度不定。</li>\n<li><code>BND.PORT</code>： 表示绑定端口，值长度2个字节</li>\n</ul>\n<h4 id=\"数据转发\"><a href=\"#数据转发\" class=\"headerlink\" title=\"数据转发\"></a>数据转发</h4><p>客户端在收到来自服务器成功的响应后，就会开始发送数据了，服务端在收到来自客户端的数据后，会转发到目标服务。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>SOCKS5 协议的目的其实就是为了把来自原本应该在本机直接请求目标服务的流程，放到了服务端去代理客户端访问。<br>其运行流程总结如下：</p>\n<ol>\n<li>本机和代理服务端协商和建立连接；</li>\n<li>本机告诉代理服务端目标服务的地址；</li>\n<li>代理服务端去连接目标服务，成功后告诉本机；</li>\n<li>本机开始发送原本应发送到目标服务的数据给代理服务端，由代理服务端完成数据转发。</li>\n</ol>\n<p>以上内容来自 <a href=\"http://www.ietf.org/rfc/rfc1928.txt\" target=\"_blank\" rel=\"noopener\">SOCKS5 协议规范 rfc1928</a>。</p>\n<h2 id=\"Lightsocks-实现\"><a href=\"#Lightsocks-实现\" class=\"headerlink\" title=\"Lightsocks 实现\"></a><a href=\"https://github.com/gwuhaolin/lightsocks\" target=\"_blank\" rel=\"noopener\">Lightsocks</a> 实现</h2><p>要实现 Lightsocks 需要实现两部分：运行在本地的 lightsocks-local，和运行在墙外代理服务器上 lightsocks-server。<br>下面来分别教你如果使用 Golang 来实现它们，采用 Golang 语言的原因在于：性能好、跨平台、适合高并发、学习门槛低。对Golang感兴趣？请看<a href=\"http://go.wuhaolin.cn/\" target=\"_blank\" rel=\"noopener\">Golang 中文学习资料汇总</a></p>\n<h4 id=\"实现数据混淆\"><a href=\"#实现数据混淆\" class=\"headerlink\" title=\"实现数据混淆\"></a>实现数据混淆</h4><p>在 Shadowsocks 中是采用的标准的对称加密算法去实现数据混淆的，对称算法在加密和解密过程中需要大量计算。<br>为了简单起见，Lightsocks 将采用最简单高效的方法去实现数据混淆，具体原理如下。</p>\n<p>这个数据混淆算法和对称加密很相似，两端都需要有同样的密钥。<br>这个密钥有如下要求：</p>\n<ul>\n<li>由256个 byte 组成，也就是一个数组，在 Golang 中类型表示为 <code>[256]byte</code>；</li>\n<li>这个数组必须由 0～255 这256个数字组成，一个都不能差；</li>\n<li>这个数组中第<code>I</code>个的值不能等于<code>I</code>；</li>\n</ul>\n<p>例如以下为一个合法的密钥(上为索引，下为值)：</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n<th>11</th>\n<th>12</th>\n<th>13</th>\n<th>14</th>\n<th>15</th>\n<th>16</th>\n<th>17</th>\n<th>18</th>\n<th>19</th>\n<th>20</th>\n<th>21</th>\n<th>22</th>\n<th>23</th>\n<th>24</th>\n<th>25</th>\n<th>26</th>\n<th>27</th>\n<th>28</th>\n<th>29</th>\n<th>30</th>\n<th>31</th>\n<th>32</th>\n<th>33</th>\n<th>34</th>\n<th>35</th>\n<th>36</th>\n<th>37</th>\n<th>38</th>\n<th>39</th>\n<th>40</th>\n<th>41</th>\n<th>42</th>\n<th>43</th>\n<th>44</th>\n<th>45</th>\n<th>46</th>\n<th>47</th>\n<th>48</th>\n<th>49</th>\n<th>50</th>\n<th>51</th>\n<th>52</th>\n<th>53</th>\n<th>54</th>\n<th>55</th>\n<th>56</th>\n<th>57</th>\n<th>58</th>\n<th>59</th>\n<th>60</th>\n<th>61</th>\n<th>62</th>\n<th>63</th>\n<th>64</th>\n<th>65</th>\n<th>66</th>\n<th>67</th>\n<th>68</th>\n<th>69</th>\n<th>70</th>\n<th>71</th>\n<th>72</th>\n<th>73</th>\n<th>74</th>\n<th>75</th>\n<th>76</th>\n<th>77</th>\n<th>78</th>\n<th>79</th>\n<th>80</th>\n<th>81</th>\n<th>82</th>\n<th>83</th>\n<th>84</th>\n<th>85</th>\n<th>86</th>\n<th>87</th>\n<th>88</th>\n<th>89</th>\n<th>90</th>\n<th>91</th>\n<th>92</th>\n<th>93</th>\n<th>94</th>\n<th>95</th>\n<th>96</th>\n<th>97</th>\n<th>98</th>\n<th>99</th>\n<th>100</th>\n<th>101</th>\n<th>102</th>\n<th>103</th>\n<th>104</th>\n<th>105</th>\n<th>106</th>\n<th>107</th>\n<th>108</th>\n<th>109</th>\n<th>110</th>\n<th>111</th>\n<th>112</th>\n<th>113</th>\n<th>114</th>\n<th>115</th>\n<th>116</th>\n<th>117</th>\n<th>118</th>\n<th>119</th>\n<th>120</th>\n<th>121</th>\n<th>122</th>\n<th>123</th>\n<th>124</th>\n<th>125</th>\n<th>126</th>\n<th>127</th>\n<th>128</th>\n<th>129</th>\n<th>130</th>\n<th>131</th>\n<th>132</th>\n<th>133</th>\n<th>134</th>\n<th>135</th>\n<th>136</th>\n<th>137</th>\n<th>138</th>\n<th>139</th>\n<th>140</th>\n<th>141</th>\n<th>142</th>\n<th>143</th>\n<th>144</th>\n<th>145</th>\n<th>146</th>\n<th>147</th>\n<th>148</th>\n<th>149</th>\n<th>150</th>\n<th>151</th>\n<th>152</th>\n<th>153</th>\n<th>154</th>\n<th>155</th>\n<th>156</th>\n<th>157</th>\n<th>158</th>\n<th>159</th>\n<th>160</th>\n<th>161</th>\n<th>162</th>\n<th>163</th>\n<th>164</th>\n<th>165</th>\n<th>166</th>\n<th>167</th>\n<th>168</th>\n<th>169</th>\n<th>170</th>\n<th>171</th>\n<th>172</th>\n<th>173</th>\n<th>174</th>\n<th>175</th>\n<th>176</th>\n<th>177</th>\n<th>178</th>\n<th>179</th>\n<th>180</th>\n<th>181</th>\n<th>182</th>\n<th>183</th>\n<th>184</th>\n<th>185</th>\n<th>186</th>\n<th>187</th>\n<th>188</th>\n<th>189</th>\n<th>190</th>\n<th>191</th>\n<th>192</th>\n<th>193</th>\n<th>194</th>\n<th>195</th>\n<th>196</th>\n<th>197</th>\n<th>198</th>\n<th>199</th>\n<th>200</th>\n<th>201</th>\n<th>202</th>\n<th>203</th>\n<th>204</th>\n<th>205</th>\n<th>206</th>\n<th>207</th>\n<th>208</th>\n<th>209</th>\n<th>210</th>\n<th>211</th>\n<th>212</th>\n<th>213</th>\n<th>214</th>\n<th>215</th>\n<th>216</th>\n<th>217</th>\n<th>218</th>\n<th>219</th>\n<th>220</th>\n<th>221</th>\n<th>222</th>\n<th>223</th>\n<th>224</th>\n<th>225</th>\n<th>226</th>\n<th>227</th>\n<th>228</th>\n<th>229</th>\n<th>230</th>\n<th>231</th>\n<th>232</th>\n<th>233</th>\n<th>234</th>\n<th>235</th>\n<th>236</th>\n<th>237</th>\n<th>238</th>\n<th>239</th>\n<th>240</th>\n<th>241</th>\n<th>242</th>\n<th>243</th>\n<th>244</th>\n<th>245</th>\n<th>246</th>\n<th>247</th>\n<th>248</th>\n<th>249</th>\n<th>250</th>\n<th>251</th>\n<th>252</th>\n<th>253</th>\n<th>254</th>\n<th>255</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>186</td>\n<td>118</td>\n<td>82</td>\n<td>201</td>\n<td>235</td>\n<td>236</td>\n<td>180</td>\n<td>66</td>\n<td>228</td>\n<td>96</td>\n<td>43</td>\n<td>90</td>\n<td>203</td>\n<td>200</td>\n<td>34</td>\n<td>104</td>\n<td>41</td>\n<td>222</td>\n<td>165</td>\n<td>74</td>\n<td>240</td>\n<td>20</td>\n<td>244</td>\n<td>67</td>\n<td>114</td>\n<td>191</td>\n<td>220</td>\n<td>147</td>\n<td>196</td>\n<td>183</td>\n<td>229</td>\n<td>123</td>\n<td>208</td>\n<td>19</td>\n<td>127</td>\n<td>187</td>\n<td>84</td>\n<td>148</td>\n<td>56</td>\n<td>170</td>\n<td>133</td>\n<td>160</td>\n<td>202</td>\n<td>21</td>\n<td>53</td>\n<td>78</td>\n<td>59</td>\n<td>64</td>\n<td>120</td>\n<td>27</td>\n<td>167</td>\n<td>175</td>\n<td>39</td>\n<td>10</td>\n<td>4</td>\n<td>132</td>\n<td>89</td>\n<td>230</td>\n<td>152</td>\n<td>73</td>\n<td>221</td>\n<td>88</td>\n<td>141</td>\n<td>158</td>\n<td>251</td>\n<td>79</td>\n<td>225</td>\n<td>87</td>\n<td>14</td>\n<td>23</td>\n<td>68</td>\n<td>250</td>\n<td>199</td>\n<td>168</td>\n<td>218</td>\n<td>60</td>\n<td>40</td>\n<td>169</td>\n<td>75</td>\n<td>86</td>\n<td>153</td>\n<td>134</td>\n<td>83</td>\n<td>49</td>\n<td>128</td>\n<td>231</td>\n<td>217</td>\n<td>239</td>\n<td>226</td>\n<td>177</td>\n<td>57</td>\n<td>24</td>\n<td>234</td>\n<td>63</td>\n<td>7</td>\n<td>112</td>\n<td>166</td>\n<td>211</td>\n<td>254</td>\n<td>179</td>\n<td>157</td>\n<td>215</td>\n<td>227</td>\n<td>224</td>\n<td>233</td>\n<td>81</td>\n<td>172</td>\n<td>26</td>\n<td>122</td>\n<td>219</td>\n<td>48</td>\n<td>151</td>\n<td>232</td>\n<td>50</td>\n<td>108</td>\n<td>44</td>\n<td>0</td>\n<td>192</td>\n<td>65</td>\n<td>76</td>\n<td>109</td>\n<td>252</td>\n<td>248</td>\n<td>47</td>\n<td>154</td>\n<td>33</td>\n<td>209</td>\n<td>115</td>\n<td>31</td>\n<td>15</td>\n<td>45</td>\n<td>206</td>\n<td>247</td>\n<td>124</td>\n<td>77</td>\n<td>8</td>\n<td>182</td>\n<td>144</td>\n<td>1</td>\n<td>72</td>\n<td>131</td>\n<td>52</td>\n<td>245</td>\n<td>198</td>\n<td>238</td>\n<td>5</td>\n<td>188</td>\n<td>116</td>\n<td>55</td>\n<td>216</td>\n<td>155</td>\n<td>2</td>\n<td>178</td>\n<td>189</td>\n<td>162</td>\n<td>136</td>\n<td>243</td>\n<td>184</td>\n<td>58</td>\n<td>69</td>\n<td>70</td>\n<td>99</td>\n<td>36</td>\n<td>25</td>\n<td>35</td>\n<td>174</td>\n<td>195</td>\n<td>18</td>\n<td>205</td>\n<td>30</td>\n<td>190</td>\n<td>142</td>\n<td>210</td>\n<td>113</td>\n<td>145</td>\n<td>101</td>\n<td>97</td>\n<td>161</td>\n<td>100</td>\n<td>91</td>\n<td>242</td>\n<td>138</td>\n<td>93</td>\n<td>171</td>\n<td>98</td>\n<td>237</td>\n<td>212</td>\n<td>255</td>\n<td>80</td>\n<td>102</td>\n<td>119</td>\n<td>204</td>\n<td>107</td>\n<td>105</td>\n<td>111</td>\n<td>11</td>\n<td>29</td>\n<td>146</td>\n<td>129</td>\n<td>117</td>\n<td>135</td>\n<td>176</td>\n<td>163</td>\n<td>207</td>\n<td>103</td>\n<td>22</td>\n<td>246</td>\n<td>125</td>\n<td>150</td>\n<td>106</td>\n<td>126</td>\n<td>197</td>\n<td>249</td>\n<td>62</td>\n<td>51</td>\n<td>193</td>\n<td>32</td>\n<td>3</td>\n<td>110</td>\n<td>46</td>\n<td>85</td>\n<td>71</td>\n<td>159</td>\n<td>139</td>\n<td>12</td>\n<td>164</td>\n<td>95</td>\n<td>121</td>\n<td>140</td>\n<td>241</td>\n<td>253</td>\n<td>130</td>\n<td>173</td>\n<td>213</td>\n<td>54</td>\n<td>143</td>\n<td>16</td>\n<td>94</td>\n<td>9</td>\n<td>61</td>\n<td>156</td>\n<td>214</td>\n<td>28</td>\n<td>17</td>\n<td>37</td>\n<td>42</td>\n<td>181</td>\n<td>149</td>\n<td>185</td>\n<td>223</td>\n<td>92</td>\n<td>38</td>\n<td>13</td>\n<td>194</td>\n<td>6</td>\n<td>137</td>\n</tr>\n</tbody>\n</table>\n<p>如果原数据为 <code>[5,0,1,2,3]</code>，则采用以上密钥加密后变成 <code>[236,186,118,82,201]</code>。<br>如果加密后的数据为 <code>[186,118,82,201,235]</code>，则采用以上密钥解密得到的原数据为 <code>[0,1,2,3,4]</code></p>\n<p>聪明的你肯定看懂了其中的规律：把1～255 这256个数字确定一种一对一的映射关系，加密是从一个数字得到对应的一个数字，而解密则是反向的过程，而这个密钥的作用正是描述这个映射关系。<br>这其实就是中学学的<strong>反函数</strong>。</p>\n<p>为什么要这样设计数据混淆算法呢？在数据传输时，数据是以 byte 为最小单位流式传输的。一个 byte 的取值只可能是 0～255。该混淆算法可以直接对一个个 byte 进行加解密，而无需像标准的对称算法那样只能对一大块数据进行加密。<br>再加上本算法的加解密 N byte 数据的算法复杂度为 N（直接通过数组索引访问），非常适合流式加密。</p>\n<p>以上加密算法的安全性怎么样呢？符合以上要求的密钥匙有多少种组合呢？我们来算算：<br>这其实就是初中学的排列组合中的排列问题，形象点其实就是，把 0～255 个不同编号的人安排到 0～255 个不同编号的坑去，并且不能有编号一样的情况，有多少种排法。<br>也就是 <code>A(255,255)=255*254*253*...*1=255!</code>，但其中有一半为有重复的情况，<br>最终结果为 <code>255!/2</code>，<br>其值大概为 <code>10^500</code> 这个数量级。</p>\n<p>以上加密算法虽然破绽很多，但足以实现高效的数据混淆，骗过防火墙。</p>\n<p>目前采用对称加密算法实现数据混淆的 Shadowsocks 已经能被一些防火墙通过机器学习算法通过特征分析识别出传输的原内容适合合法，而 Lightsocks 的这套混淆算法目前还不能被轻易的识别出来。</p>\n<p>随机产生一个以上密钥匙的<a href=\"https://github.com/gwuhaolin/lightsocks/blob/master/core/password.go\" target=\"_blank\" rel=\"noopener\">代码如下</a>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> core</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"math/rand\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">const</span> PasswordLength = <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Password [PasswordLength]<span class=\"keyword\">byte</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 更新随机种子，防止生成一样的随机密码</span></span><br><span class=\"line\">\trand.Seed(time.Now().Unix())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 产生 256个byte随机组合的 密码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RandPassword</span><span class=\"params\">()</span> *<span class=\"title\">Password</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 随机生成一个由  0~255 组成的 byte 数组</span></span><br><span class=\"line\">\tintArr := rand.Perm(PasswordLength)</span><br><span class=\"line\">\tpassword := &amp;Password&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> intArr &#123;</span><br><span class=\"line\">\t\tpassword[i] = <span class=\"keyword\">byte</span>(v)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i == v &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 确保不会出现如何一个byte位出现重复</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> RandPassword()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> password</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对数据进行加密解密的<a href=\"https://github.com/gwuhaolin/lightsocks/blob/master/core/cipher.go\" target=\"_blank\" rel=\"noopener\">代码如下</a>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> core</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cipher <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 编码用的密码</span></span><br><span class=\"line\">\tencodePassword *Password</span><br><span class=\"line\">\t<span class=\"comment\">// 解码用的密码</span></span><br><span class=\"line\">\tdecodePassword *Password</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加密原数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cipher *Cipher)</span> <span class=\"title\">encode</span><span class=\"params\">(bs []<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> bs &#123;</span><br><span class=\"line\">\t\tbs[i] = cipher.encodePassword[v]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解码加密后的数据到原数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cipher *Cipher)</span> <span class=\"title\">decode</span><span class=\"params\">(bs []<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> bs &#123;</span><br><span class=\"line\">\t\tbs[i] = cipher.decodePassword[v]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新建一个编码解码器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewCipher</span><span class=\"params\">(encodePassword *Password)</span> *<span class=\"title\">Cipher</span></span> &#123;</span><br><span class=\"line\">\tdecodePassword := &amp;Password&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> encodePassword &#123;</span><br><span class=\"line\">\t\tencodePassword[i] = v</span><br><span class=\"line\">\t\tdecodePassword[v] = <span class=\"keyword\">byte</span>(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Cipher&#123;</span><br><span class=\"line\">\t\tencodePassword: encodePassword,</span><br><span class=\"line\">\t\tdecodePassword: decodePassword,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再使用以上的 Cipher 去封装一个加密传输的 SecureSocket，以方便直接加解密 TCP Socket 中的流式数据，<a href=\"https://github.com/gwuhaolin/lightsocks/blob/master/core/securesocket.go\" target=\"_blank\" rel=\"noopener\">代码如下</a>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> core</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"errors\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"io\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tBufSize = <span class=\"number\">1024</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加密传输的 TCP Socket</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> SecureSocket <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tCipher     *Cipher</span><br><span class=\"line\">\tListenAddr *net.TCPAddr</span><br><span class=\"line\">\tRemoteAddr *net.TCPAddr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从输入流里读取加密过的数据，解密后把原数据放到bs里</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(secureSocket *SecureSocket)</span> <span class=\"title\">DecodeRead</span><span class=\"params\">(conn *net.TCPConn, bs []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tn, err = conn.Read(bs)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsecureSocket.Cipher.decode(bs[:n])</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把放在bs里的数据加密后立即全部写入输出流</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(secureSocket *SecureSocket)</span> <span class=\"title\">EncodeWrite</span><span class=\"params\">(conn *net.TCPConn, bs []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tsecureSocket.Cipher.encode(bs)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> conn.Write(bs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从src中源源不断的读取原数据加密后写入到dst，直到src中没有数据可以再读取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(secureSocket *SecureSocket)</span> <span class=\"title\">EncodeCopy</span><span class=\"params\">(dst *net.TCPConn, src *net.TCPConn)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, BufSize)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\treadCount, errRead := src.Read(buf)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> errRead != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> errRead != io.EOF &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> errRead</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> readCount &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\twriteCount, errWrite := secureSocket.EncodeWrite(dst, buf[<span class=\"number\">0</span>:readCount])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> errWrite != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> errWrite</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> readCount != writeCount &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> io.ErrShortWrite</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从src中源源不断的读取加密后的数据解密后写入到dst，直到src中没有数据可以再读取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(secureSocket *SecureSocket)</span> <span class=\"title\">DecodeCopy</span><span class=\"params\">(dst *net.TCPConn, src *net.TCPConn)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, BufSize)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\treadCount, errRead := secureSocket.DecodeRead(src, buf)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> errRead != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> errRead != io.EOF &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> errRead</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> readCount &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\twriteCount, errWrite := dst.Write(buf[<span class=\"number\">0</span>:readCount])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> errWrite != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> errWrite</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> readCount != writeCount &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> io.ErrShortWrite</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 和远程的socket建立连接，他们之间的数据传输会加密</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(secureSocket *SecureSocket)</span> <span class=\"title\">DialRemote</span><span class=\"params\">()</span> <span class=\"params\">(*net.TCPConn, error)</span></span> &#123;</span><br><span class=\"line\">\tremoteConn, err := net.DialTCP(<span class=\"string\">\"tcp\"</span>, <span class=\"literal\">nil</span>, secureSocket.RemoteAddr)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, errors.New(fmt.Sprintf(<span class=\"string\">\"连接到远程服务器 %s 失败:%s\"</span>, secureSocket.RemoteAddr, err))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> remoteConn, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个 SecureSocket 用于 local 端和 server 端之间进行 TCP 通信，并且只使用 SecureSocket 通信时中间传输的数据会被加密，防火墙无法读到原数据。 </p>\n<h4 id=\"实现-local-端\"><a href=\"#实现-local-端\" class=\"headerlink\" title=\"实现 local 端\"></a>实现 local 端</h4><p>运行在本机的 local 端的职责是把本机程序发送给它的数据经过加密后转发给墙外的代理服务器，总体工作流程如下：</p>\n<ol>\n<li>监听来自本机浏览器的代理请求；</li>\n<li>转发前加密数据；</li>\n<li>转发socket数据到墙外代理服务端；</li>\n<li>把服务端返回的数据转发给用户的浏览器。</li>\n</ol>\n<p>实现以上功能的 local 端<a href=\"https://github.com/gwuhaolin/lightsocks/blob/master/local/local.go\" target=\"_blank\" rel=\"noopener\">代码如下</a>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> local</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"github.com/gwuhaolin/lightsocks/core\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LsLocal <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*core.SecureSocket</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新建一个本地端</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(password *core.Password, listenAddr, remoteAddr *net.TCPAddr)</span> *<span class=\"title\">LsLocal</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;LsLocal&#123;</span><br><span class=\"line\">\t\tSecureSocket: &amp;core.SecureSocket&#123;</span><br><span class=\"line\">\t\t\tCipher:     core.NewCipher(password),</span><br><span class=\"line\">\t\t\tListenAddr: listenAddr,</span><br><span class=\"line\">\t\t\tRemoteAddr: remoteAddr,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 本地端启动监听，接收来自本机浏览器的连接</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(local *LsLocal)</span> <span class=\"title\">Listen</span><span class=\"params\">(didListen <span class=\"keyword\">func</span>(listenAddr net.Addr)</span>) <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\tlistener, err := net.ListenTCP(<span class=\"string\">\"tcp\"</span>, local.ListenAddr)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> listener.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> didListen != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tdidListen(listener.Addr())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tuserConn, err := listener.AcceptTCP()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// userConn被关闭时直接清除所有数据 不管没有发送的数据</span></span><br><span class=\"line\">\t\tuserConn.SetLinger(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> local.handleConn(userConn)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(local *LsLocal)</span> <span class=\"title\">handleConn</span><span class=\"params\">(userConn *net.TCPConn)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> userConn.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tproxyServer, err := local.DialRemote()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Println(err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> proxyServer.Close()</span><br><span class=\"line\">\t<span class=\"comment\">// Conn被关闭时直接清除所有数据 不管没有发送的数据</span></span><br><span class=\"line\">\tproxyServer.SetLinger(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 进行转发</span></span><br><span class=\"line\">\t<span class=\"comment\">// 从 proxyServer 读取数据发送到 localUser</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\terr := local.DecodeCopy(userConn, proxyServer)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 在 copy 的过程中可能会存在网络超时等 error 被 return，只要有一个发生了错误就退出本次工作</span></span><br><span class=\"line\">\t\t\tuserConn.Close()</span><br><span class=\"line\">\t\t\tproxyServer.Close()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"comment\">// 从 localUser 发送数据发送到 proxyServer，这里因为处在翻墙阶段出现网络错误的概率更大</span></span><br><span class=\"line\">\tlocal.EncodeCopy(proxyServer, userConn)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"实现-server-端\"><a href=\"#实现-server-端\" class=\"headerlink\" title=\"实现 server 端\"></a>实现 server 端</h4><p>运行在墙外代理服务器的 server 端职责如下：</p>\n<ol>\n<li>监听来自本地代理客户端的请求；</li>\n<li>解密本地代理客户端请求的数据，解析 SOCKS5 协议，连接用户浏览器真正想要连接的远程服务器；</li>\n<li>转发用户浏览器真正想要连接的远程服务器返回的数据的加密后的内容到本地代理客户端。</li>\n</ol>\n<p>实现以上功能的<a href=\"https://github.com/gwuhaolin/lightsocks/blob/master/server/server.go\" target=\"_blank\" rel=\"noopener\">代码如下</a>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"encoding/binary\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/gwuhaolin/lightsocks/core\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LsServer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*core.SecureSocket</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新建一个服务端</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(password *core.Password, listenAddr *net.TCPAddr)</span> *<span class=\"title\">LsServer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;LsServer&#123;</span><br><span class=\"line\">\t\tSecureSocket: &amp;core.SecureSocket&#123;</span><br><span class=\"line\">\t\t\tCipher:     core.NewCipher(password),</span><br><span class=\"line\">\t\t\tListenAddr: listenAddr,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行服务端并且监听来自本地代理客户端的请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(lsServer *LsServer)</span> <span class=\"title\">Listen</span><span class=\"params\">(didListen <span class=\"keyword\">func</span>(listenAddr net.Addr)</span>) <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\tlistener, err := net.ListenTCP(<span class=\"string\">\"tcp\"</span>, lsServer.ListenAddr)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> listener.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> didListen != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tdidListen(listener.Addr())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tlocalConn, err := listener.AcceptTCP()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// localConn被关闭时直接清除所有数据 不管没有发送的数据</span></span><br><span class=\"line\">\t\tlocalConn.SetLinger(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> lsServer.handleConn(localConn)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解 SOCKS5 协议</span></span><br><span class=\"line\"><span class=\"comment\">// https://www.ietf.org/rfc/rfc1928.txt</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(lsServer *LsServer)</span> <span class=\"title\">handleConn</span><span class=\"params\">(localConn *net.TCPConn)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> localConn.Close()</span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">256</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t   The localConn connects to the dstServer, and sends a ver</span></span><br><span class=\"line\"><span class=\"comment\">\t   identifier/method selection message:</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          |VER | NMETHODS | METHODS  |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          | 1  |    1     | 1 to 255 |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t   The VER field is set to X'05' for this ver of the protocol.  The</span></span><br><span class=\"line\"><span class=\"comment\">\t   NMETHODS field contains the number of method identifier octets that</span></span><br><span class=\"line\"><span class=\"comment\">\t   appear in the METHODS field.</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"comment\">// 第一个字段VER代表Socks的版本，Socks5默认为0x05，其固定长度为1个字节</span></span><br><span class=\"line\">\t_, err := lsServer.DecodeRead(localConn, buf)</span><br><span class=\"line\">\t<span class=\"comment\">// 只支持版本5</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> || buf[<span class=\"number\">0</span>] != <span class=\"number\">0x05</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t   The dstServer selects from one of the methods given in METHODS, and</span></span><br><span class=\"line\"><span class=\"comment\">\t   sends a METHOD selection message:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+--------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          |VER | METHOD |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+--------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          | 1  |   1    |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+--------+</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"comment\">// 不需要验证，直接验证通过</span></span><br><span class=\"line\">\tlsServer.EncodeWrite(localConn, []<span class=\"keyword\">byte</span>&#123;<span class=\"number\">0x05</span>, <span class=\"number\">0x00</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+-----+-------+------+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+-----+-------+------+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          | 1  |  1  | X'00' |  1   | Variable |    2     |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+-----+-------+------+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 获取真正的远程服务的地址</span></span><br><span class=\"line\">\tn, err := lsServer.DecodeRead(localConn, buf)</span><br><span class=\"line\">\t<span class=\"comment\">// n 最短的长度为7 情况为 ATYP=3 DST.ADDR占用1字节 值为0x0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> || n &lt; <span class=\"number\">7</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// CMD代表客户端请求的类型，值长度也是1个字节，有三种类型</span></span><br><span class=\"line\">\t<span class=\"comment\">// CONNECT X'01'</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> buf[<span class=\"number\">1</span>] != <span class=\"number\">0x01</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 目前只支持 CONNECT</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> dIP []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"comment\">// aType 代表请求的远程服务器地址类型，值长度1个字节，有三种类型</span></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> buf[<span class=\"number\">3</span>] &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">0x01</span>:</span><br><span class=\"line\">\t\t<span class=\"comment\">//\tIP V4 address: X'01'</span></span><br><span class=\"line\">\t\tdIP = buf[<span class=\"number\">4</span> : <span class=\"number\">4</span>+net.IPv4len]</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">0x03</span>:</span><br><span class=\"line\">\t\t<span class=\"comment\">//\tDOMAINNAME: X'03'</span></span><br><span class=\"line\">\t\tipAddr, err := net.ResolveIPAddr(<span class=\"string\">\"ip\"</span>, <span class=\"keyword\">string</span>(buf[<span class=\"number\">5</span>:n<span class=\"number\">-2</span>]))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tdIP = ipAddr.IP</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">0x04</span>:</span><br><span class=\"line\">\t\t<span class=\"comment\">//\tIP V6 address: X'04'</span></span><br><span class=\"line\">\t\tdIP = buf[<span class=\"number\">4</span> : <span class=\"number\">4</span>+net.IPv6len]</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdPort := buf[n<span class=\"number\">-2</span>:]</span><br><span class=\"line\">\tdstAddr := &amp;net.TCPAddr&#123;</span><br><span class=\"line\">\t\tIP:   dIP,</span><br><span class=\"line\">\t\tPort: <span class=\"keyword\">int</span>(binary.BigEndian.Uint16(dPort)),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 连接真正的远程服务</span></span><br><span class=\"line\">\tdstServer, err := net.DialTCP(<span class=\"string\">\"tcp\"</span>, <span class=\"literal\">nil</span>, dstAddr)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> dstServer.Close()</span><br><span class=\"line\">\t\t<span class=\"comment\">// Conn被关闭时直接清除所有数据 不管没有发送的数据</span></span><br><span class=\"line\">\t\tdstServer.SetLinger(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 响应客户端连接成功</span></span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+-----+-------+------+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+-----+-------+------+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          | 1  |  1  | X'00' |  1   | Variable |    2     |</span></span><br><span class=\"line\"><span class=\"comment\">\t\t          +----+-----+-------+------+----------+----------+</span></span><br><span class=\"line\"><span class=\"comment\">\t\t*/</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 响应客户端连接成功</span></span><br><span class=\"line\">\t\tlsServer.EncodeWrite(localConn, []<span class=\"keyword\">byte</span>&#123;<span class=\"number\">0x05</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 进行转发</span></span><br><span class=\"line\">\t<span class=\"comment\">// 从 localUser 读取数据发送到 dstServer</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\terr := lsServer.DecodeCopy(dstServer, localConn)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 在 copy 的过程中可能会存在网络超时等 error 被 return，只要有一个发生了错误就退出本次工作</span></span><br><span class=\"line\">\t\t\tlocalConn.Close()</span><br><span class=\"line\">\t\t\tdstServer.Close()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"comment\">// 从 dstServer 读取数据发送到 localUser，这里因为处在翻墙阶段出现网络错误的概率更大</span></span><br><span class=\"line\">\tlsServer.EncodeCopy(localConn, dstServer)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>以上就是实现一个轻量级 Shadowsocks 的核心代码。其它一些零碎的代码，例如启动入口、配置读写等，可以去 <a href=\"https://github.com/gwuhaolin/lightsocks\" target=\"_blank\" rel=\"noopener\">lightsocks</a> 项目中阅读完整代码。</p>\n<p><a href=\"http://wuhaolin.cn/2017/11/03/%E4%BD%A0%E4%B9%9F%E8%83%BD%E5%86%99%E4%B8%AA%20Shadowsocks/\">阅读原文</a></p>\n"},{"title":"快速优雅的为React组件生成文档","date":"2017-04-30T01:41:44.000Z","url":"https://github.com/gwuhaolin/blog/issues/1","_content":"\n在开发React组件时我们通常需要处理2个问题：\n1. 实例化这个组件以便调试\n2. 为这个组件编写使用文档以便更好的让别人知道怎么使用这个组件\n\n最原始的方法莫过于开发时建一个页面用于调试，开发完后再为其手写文档。然而一个详细的React组件文档应该包括：\n1. 为各种使用场景编写demo以及对应的说明，同时附上demo的源码\n2. 有demo可以当场体验而不是使用者要自己写代码后才能体验这个组件\n3. 它的属性列表(`propTypes`)\n4. 它的实例方法列表\n\n如果你想做到以上估计得花上你一天的功夫，我希望能把精力放在开发更好的组件上剩下的能毫不费劲的优雅完成，于是我做了本文的主角[Redemo](https://github.com/gwuhaolin/redemo)。\nRedemo是用来简单优雅的完成以上问题让你专注于开发自己的组件，剩下的一切它都为你做好了。先看下Redemo为组件生成文档的效果图或直接体验部分实践中的项目[redemo文档](https://gwuhaolin.github.io/redemo/)、[imuix](http://imweb.github.io/imuix/)：\n![redemo效果图](https://github.com/gwuhaolin/redemo/raw/master/src/doc/redemo.png)\n结构如下：\n- 最上面是可立即体验的组件demo，同时可以用在开发过程中调试组件\n- 组件实例下是这个demo的说明，支持markdown\n- 接下来是组件的属性列表(`propTypes`)，支持markdown\n- 最后是这个demo的源码\n\n\n为你的组件生成这个你几乎不用写超过10行简单的代码更不用单独为组件写文档。假设你编写了一个Button组件，让我们来为Button组件编写一个demo：\n1. 通过`npm i redemo` 安装 `redemo` \n2. 写下这些简单的代码\n```js\nimport Redemo from 'redemo';\nimport Demo from './demo';//为一个使用场景实例化Button组件的demo源码\n// 使用docgen 从 Button 组件源码里分析出 propTypes\nconst docgen = require('!!docgen-loader!../button');\n// 读取为Button组件编写的demo的源码\nconst code = require('!!raw-loader!../demo');\nconst doc = `为这个demo做一些说明，支持*markdown*`\nrender(\n<Redemo\n  docgen={docgen}\n  doc={doc}\n  code={code}\n>\n  <Demo/>\n</Redemo>\n)\n```\n\n聪明的你大概会问以上代码并没有为Button属性编写文档，属性列表里的说明是哪来的？其实是通过[react-docgen](https://github.com/reactjs/react-docgen)从Button组件源码里提取出来的。大家都知道为代码写注释是个好习惯方便维护和理解，而这些注释正好也可以放在文档里一举两得。所以你在编写Button组件时需要为`propTypes`写注释，就像这样：\n```js\nclass Button extends Component {\n  static propTypes = {\n    /**\n     * call after button is clicked，支持*markdown*\n     */\n    onClick: PropTypes.func,\n  }\n  ...\n}\n```\n\n想更深的了解redemo请看[这里](https://github.com/gwuhaolin/redemo)\n希望redemo可以提升你的效率，觉得有用可告诉你的朋友。\n\n[阅读原文](http://wuhaolin.cn/2017/04/30/%E5%BF%AB%E9%80%9F%E4%BC%98%E9%9B%85%E7%9A%84%E4%B8%BAReact%E7%BB%84%E4%BB%B6%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3/)","source":"_posts/快速优雅的为React组件生成文档.md","raw":"---\ntitle: 快速优雅的为React组件生成文档\ndate: 2017-04-30T09:41:44Z\nurl: https://github.com/gwuhaolin/blog/issues/1\ntags:\n    - react\n---\n\n在开发React组件时我们通常需要处理2个问题：\n1. 实例化这个组件以便调试\n2. 为这个组件编写使用文档以便更好的让别人知道怎么使用这个组件\n\n最原始的方法莫过于开发时建一个页面用于调试，开发完后再为其手写文档。然而一个详细的React组件文档应该包括：\n1. 为各种使用场景编写demo以及对应的说明，同时附上demo的源码\n2. 有demo可以当场体验而不是使用者要自己写代码后才能体验这个组件\n3. 它的属性列表(`propTypes`)\n4. 它的实例方法列表\n\n如果你想做到以上估计得花上你一天的功夫，我希望能把精力放在开发更好的组件上剩下的能毫不费劲的优雅完成，于是我做了本文的主角[Redemo](https://github.com/gwuhaolin/redemo)。\nRedemo是用来简单优雅的完成以上问题让你专注于开发自己的组件，剩下的一切它都为你做好了。先看下Redemo为组件生成文档的效果图或直接体验部分实践中的项目[redemo文档](https://gwuhaolin.github.io/redemo/)、[imuix](http://imweb.github.io/imuix/)：\n![redemo效果图](https://github.com/gwuhaolin/redemo/raw/master/src/doc/redemo.png)\n结构如下：\n- 最上面是可立即体验的组件demo，同时可以用在开发过程中调试组件\n- 组件实例下是这个demo的说明，支持markdown\n- 接下来是组件的属性列表(`propTypes`)，支持markdown\n- 最后是这个demo的源码\n\n\n为你的组件生成这个你几乎不用写超过10行简单的代码更不用单独为组件写文档。假设你编写了一个Button组件，让我们来为Button组件编写一个demo：\n1. 通过`npm i redemo` 安装 `redemo` \n2. 写下这些简单的代码\n```js\nimport Redemo from 'redemo';\nimport Demo from './demo';//为一个使用场景实例化Button组件的demo源码\n// 使用docgen 从 Button 组件源码里分析出 propTypes\nconst docgen = require('!!docgen-loader!../button');\n// 读取为Button组件编写的demo的源码\nconst code = require('!!raw-loader!../demo');\nconst doc = `为这个demo做一些说明，支持*markdown*`\nrender(\n<Redemo\n  docgen={docgen}\n  doc={doc}\n  code={code}\n>\n  <Demo/>\n</Redemo>\n)\n```\n\n聪明的你大概会问以上代码并没有为Button属性编写文档，属性列表里的说明是哪来的？其实是通过[react-docgen](https://github.com/reactjs/react-docgen)从Button组件源码里提取出来的。大家都知道为代码写注释是个好习惯方便维护和理解，而这些注释正好也可以放在文档里一举两得。所以你在编写Button组件时需要为`propTypes`写注释，就像这样：\n```js\nclass Button extends Component {\n  static propTypes = {\n    /**\n     * call after button is clicked，支持*markdown*\n     */\n    onClick: PropTypes.func,\n  }\n  ...\n}\n```\n\n想更深的了解redemo请看[这里](https://github.com/gwuhaolin/redemo)\n希望redemo可以提升你的效率，觉得有用可告诉你的朋友。\n\n[阅读原文](http://wuhaolin.cn/2017/04/30/%E5%BF%AB%E9%80%9F%E4%BC%98%E9%9B%85%E7%9A%84%E4%B8%BAReact%E7%BB%84%E4%BB%B6%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3/)","slug":"快速优雅的为React组件生成文档","published":1,"updated":"2018-11-14T04:39:28.648Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjogs0kea000dg5tcms20r3pp","content":"<p>在开发React组件时我们通常需要处理2个问题：</p>\n<ol>\n<li>实例化这个组件以便调试</li>\n<li>为这个组件编写使用文档以便更好的让别人知道怎么使用这个组件</li>\n</ol>\n<p>最原始的方法莫过于开发时建一个页面用于调试，开发完后再为其手写文档。然而一个详细的React组件文档应该包括：</p>\n<ol>\n<li>为各种使用场景编写demo以及对应的说明，同时附上demo的源码</li>\n<li>有demo可以当场体验而不是使用者要自己写代码后才能体验这个组件</li>\n<li>它的属性列表(<code>propTypes</code>)</li>\n<li>它的实例方法列表</li>\n</ol>\n<p>如果你想做到以上估计得花上你一天的功夫，我希望能把精力放在开发更好的组件上剩下的能毫不费劲的优雅完成，于是我做了本文的主角<a href=\"https://github.com/gwuhaolin/redemo\" target=\"_blank\" rel=\"noopener\">Redemo</a>。<br>Redemo是用来简单优雅的完成以上问题让你专注于开发自己的组件，剩下的一切它都为你做好了。先看下Redemo为组件生成文档的效果图或直接体验部分实践中的项目<a href=\"https://gwuhaolin.github.io/redemo/\" target=\"_blank\" rel=\"noopener\">redemo文档</a>、<a href=\"http://imweb.github.io/imuix/\" target=\"_blank\" rel=\"noopener\">imuix</a>：<br><img src=\"https://github.com/gwuhaolin/redemo/raw/master/src/doc/redemo.png\" alt=\"redemo效果图\"><br>结构如下：</p>\n<ul>\n<li>最上面是可立即体验的组件demo，同时可以用在开发过程中调试组件</li>\n<li>组件实例下是这个demo的说明，支持markdown</li>\n<li>接下来是组件的属性列表(<code>propTypes</code>)，支持markdown</li>\n<li>最后是这个demo的源码</li>\n</ul>\n<p>为你的组件生成这个你几乎不用写超过10行简单的代码更不用单独为组件写文档。假设你编写了一个Button组件，让我们来为Button组件编写一个demo：</p>\n<ol>\n<li>通过<code>npm i redemo</code> 安装 <code>redemo</code> </li>\n<li>写下这些简单的代码<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Redemo <span class=\"keyword\">from</span> <span class=\"string\">'redemo'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Demo <span class=\"keyword\">from</span> <span class=\"string\">'./demo'</span>;<span class=\"comment\">//为一个使用场景实例化Button组件的demo源码</span></span><br><span class=\"line\"><span class=\"comment\">// 使用docgen 从 Button 组件源码里分析出 propTypes</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> docgen = <span class=\"built_in\">require</span>(<span class=\"string\">'!!docgen-loader!../button'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 读取为Button组件编写的demo的源码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> code = <span class=\"built_in\">require</span>(<span class=\"string\">'!!raw-loader!../demo'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> doc = <span class=\"string\">`为这个demo做一些说明，支持*markdown*`</span></span><br><span class=\"line\">render(</span><br><span class=\"line\">&lt;Redemo</span><br><span class=\"line\">  docgen=&#123;docgen&#125;</span><br><span class=\"line\">  doc=&#123;doc&#125;</span><br><span class=\"line\">  code=&#123;code&#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">  &lt;Demo/&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Redemo&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>聪明的你大概会问以上代码并没有为Button属性编写文档，属性列表里的说明是哪来的？其实是通过<a href=\"https://github.com/reactjs/react-docgen\" target=\"_blank\" rel=\"noopener\">react-docgen</a>从Button组件源码里提取出来的。大家都知道为代码写注释是个好习惯方便维护和理解，而这些注释正好也可以放在文档里一举两得。所以你在编写Button组件时需要为<code>propTypes</code>写注释，就像这样：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Button</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> propTypes = &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * call after button is clicked，支持*markdown*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    onClick: PropTypes.func,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>想更深的了解redemo请看<a href=\"https://github.com/gwuhaolin/redemo\" target=\"_blank\" rel=\"noopener\">这里</a><br>希望redemo可以提升你的效率，觉得有用可告诉你的朋友。</p>\n<p><a href=\"http://wuhaolin.cn/2017/04/30/%E5%BF%AB%E9%80%9F%E4%BC%98%E9%9B%85%E7%9A%84%E4%B8%BAReact%E7%BB%84%E4%BB%B6%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3/\">阅读原文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在开发React组件时我们通常需要处理2个问题：</p>\n<ol>\n<li>实例化这个组件以便调试</li>\n<li>为这个组件编写使用文档以便更好的让别人知道怎么使用这个组件</li>\n</ol>\n<p>最原始的方法莫过于开发时建一个页面用于调试，开发完后再为其手写文档。然而一个详细的React组件文档应该包括：</p>\n<ol>\n<li>为各种使用场景编写demo以及对应的说明，同时附上demo的源码</li>\n<li>有demo可以当场体验而不是使用者要自己写代码后才能体验这个组件</li>\n<li>它的属性列表(<code>propTypes</code>)</li>\n<li>它的实例方法列表</li>\n</ol>\n<p>如果你想做到以上估计得花上你一天的功夫，我希望能把精力放在开发更好的组件上剩下的能毫不费劲的优雅完成，于是我做了本文的主角<a href=\"https://github.com/gwuhaolin/redemo\" target=\"_blank\" rel=\"noopener\">Redemo</a>。<br>Redemo是用来简单优雅的完成以上问题让你专注于开发自己的组件，剩下的一切它都为你做好了。先看下Redemo为组件生成文档的效果图或直接体验部分实践中的项目<a href=\"https://gwuhaolin.github.io/redemo/\" target=\"_blank\" rel=\"noopener\">redemo文档</a>、<a href=\"http://imweb.github.io/imuix/\" target=\"_blank\" rel=\"noopener\">imuix</a>：<br><img src=\"https://github.com/gwuhaolin/redemo/raw/master/src/doc/redemo.png\" alt=\"redemo效果图\"><br>结构如下：</p>\n<ul>\n<li>最上面是可立即体验的组件demo，同时可以用在开发过程中调试组件</li>\n<li>组件实例下是这个demo的说明，支持markdown</li>\n<li>接下来是组件的属性列表(<code>propTypes</code>)，支持markdown</li>\n<li>最后是这个demo的源码</li>\n</ul>\n<p>为你的组件生成这个你几乎不用写超过10行简单的代码更不用单独为组件写文档。假设你编写了一个Button组件，让我们来为Button组件编写一个demo：</p>\n<ol>\n<li>通过<code>npm i redemo</code> 安装 <code>redemo</code> </li>\n<li>写下这些简单的代码<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Redemo <span class=\"keyword\">from</span> <span class=\"string\">'redemo'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Demo <span class=\"keyword\">from</span> <span class=\"string\">'./demo'</span>;<span class=\"comment\">//为一个使用场景实例化Button组件的demo源码</span></span><br><span class=\"line\"><span class=\"comment\">// 使用docgen 从 Button 组件源码里分析出 propTypes</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> docgen = <span class=\"built_in\">require</span>(<span class=\"string\">'!!docgen-loader!../button'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 读取为Button组件编写的demo的源码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> code = <span class=\"built_in\">require</span>(<span class=\"string\">'!!raw-loader!../demo'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> doc = <span class=\"string\">`为这个demo做一些说明，支持*markdown*`</span></span><br><span class=\"line\">render(</span><br><span class=\"line\">&lt;Redemo</span><br><span class=\"line\">  docgen=&#123;docgen&#125;</span><br><span class=\"line\">  doc=&#123;doc&#125;</span><br><span class=\"line\">  code=&#123;code&#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">  &lt;Demo/&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Redemo&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>聪明的你大概会问以上代码并没有为Button属性编写文档，属性列表里的说明是哪来的？其实是通过<a href=\"https://github.com/reactjs/react-docgen\" target=\"_blank\" rel=\"noopener\">react-docgen</a>从Button组件源码里提取出来的。大家都知道为代码写注释是个好习惯方便维护和理解，而这些注释正好也可以放在文档里一举两得。所以你在编写Button组件时需要为<code>propTypes</code>写注释，就像这样：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Button</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> propTypes = &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * call after button is clicked，支持*markdown*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    onClick: PropTypes.func,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>想更深的了解redemo请看<a href=\"https://github.com/gwuhaolin/redemo\" target=\"_blank\" rel=\"noopener\">这里</a><br>希望redemo可以提升你的效率，觉得有用可告诉你的朋友。</p>\n<p><a href=\"http://wuhaolin.cn/2017/04/30/%E5%BF%AB%E9%80%9F%E4%BC%98%E9%9B%85%E7%9A%84%E4%B8%BAReact%E7%BB%84%E4%BB%B6%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3/\">阅读原文</a></p>\n"},{"title":"音视频技术参考资料","date":"2017-06-02T23:57:32.000Z","url":"https://github.com/gwuhaolin/blog/issues/5","_content":"\n## 入门与概念\n- [[总结]视音频编解码技术零基础学习方法](http://blog.csdn.net/leixiaohua1020/article/details/18893769)\n- [入门启发：音视频的简单理解](http://www.ruoxu.me/yin-shi-pin-qi-fa)\n- [视频编码基础--帧的类型](https://wuyuans.com/2012/01/video_encode_frame)\n\n## 容器格式\n- [视音频编解码学习工程：FLV封装格式分析器](http://blog.csdn.net/leixiaohua1020/article/details/17934487)\n\n## 传输协议\n- [RTMP协议规范](https://chenlichao.gitbooks.io/rtmp-zh_cn/content/1-introduction.html)\n- [带你吃透RTMP](http://mingyangshang.github.io/2016/03/06/RTMP协议/)\n- [RTMP服务器的延迟，多级边缘不影响延迟，gop为最大因素](http://blog.csdn.net/win_lin/article/details/12615591)\n\n## 编解码\n","source":"_posts/音视频技术参考资料.md","raw":"---\ntitle: 音视频技术参考资料\ndate: 2017-06-03T07:57:32Z\nurl: https://github.com/gwuhaolin/blog/issues/5\ntags:\n    - 音视频\n---\n\n## 入门与概念\n- [[总结]视音频编解码技术零基础学习方法](http://blog.csdn.net/leixiaohua1020/article/details/18893769)\n- [入门启发：音视频的简单理解](http://www.ruoxu.me/yin-shi-pin-qi-fa)\n- [视频编码基础--帧的类型](https://wuyuans.com/2012/01/video_encode_frame)\n\n## 容器格式\n- [视音频编解码学习工程：FLV封装格式分析器](http://blog.csdn.net/leixiaohua1020/article/details/17934487)\n\n## 传输协议\n- [RTMP协议规范](https://chenlichao.gitbooks.io/rtmp-zh_cn/content/1-introduction.html)\n- [带你吃透RTMP](http://mingyangshang.github.io/2016/03/06/RTMP协议/)\n- [RTMP服务器的延迟，多级边缘不影响延迟，gop为最大因素](http://blog.csdn.net/win_lin/article/details/12615591)\n\n## 编解码\n","slug":"音视频技术参考资料","published":1,"updated":"2018-11-14T04:39:28.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjogs0keb000fg5tc4oi0l301","content":"<h2 id=\"入门与概念\"><a href=\"#入门与概念\" class=\"headerlink\" title=\"入门与概念\"></a>入门与概念</h2><ul>\n<li><a href=\"http://blog.csdn.net/leixiaohua1020/article/details/18893769\" target=\"_blank\" rel=\"noopener\">[总结]视音频编解码技术零基础学习方法</a></li>\n<li><a href=\"http://www.ruoxu.me/yin-shi-pin-qi-fa\" target=\"_blank\" rel=\"noopener\">入门启发：音视频的简单理解</a></li>\n<li><a href=\"https://wuyuans.com/2012/01/video_encode_frame\" target=\"_blank\" rel=\"noopener\">视频编码基础–帧的类型</a></li>\n</ul>\n<h2 id=\"容器格式\"><a href=\"#容器格式\" class=\"headerlink\" title=\"容器格式\"></a>容器格式</h2><ul>\n<li><a href=\"http://blog.csdn.net/leixiaohua1020/article/details/17934487\" target=\"_blank\" rel=\"noopener\">视音频编解码学习工程：FLV封装格式分析器</a></li>\n</ul>\n<h2 id=\"传输协议\"><a href=\"#传输协议\" class=\"headerlink\" title=\"传输协议\"></a>传输协议</h2><ul>\n<li><a href=\"https://chenlichao.gitbooks.io/rtmp-zh_cn/content/1-introduction.html\" target=\"_blank\" rel=\"noopener\">RTMP协议规范</a></li>\n<li><a href=\"http://mingyangshang.github.io/2016/03/06/RTMP协议/\" target=\"_blank\" rel=\"noopener\">带你吃透RTMP</a></li>\n<li><a href=\"http://blog.csdn.net/win_lin/article/details/12615591\" target=\"_blank\" rel=\"noopener\">RTMP服务器的延迟，多级边缘不影响延迟，gop为最大因素</a></li>\n</ul>\n<h2 id=\"编解码\"><a href=\"#编解码\" class=\"headerlink\" title=\"编解码\"></a>编解码</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"入门与概念\"><a href=\"#入门与概念\" class=\"headerlink\" title=\"入门与概念\"></a>入门与概念</h2><ul>\n<li><a href=\"http://blog.csdn.net/leixiaohua1020/article/details/18893769\" target=\"_blank\" rel=\"noopener\">[总结]视音频编解码技术零基础学习方法</a></li>\n<li><a href=\"http://www.ruoxu.me/yin-shi-pin-qi-fa\" target=\"_blank\" rel=\"noopener\">入门启发：音视频的简单理解</a></li>\n<li><a href=\"https://wuyuans.com/2012/01/video_encode_frame\" target=\"_blank\" rel=\"noopener\">视频编码基础–帧的类型</a></li>\n</ul>\n<h2 id=\"容器格式\"><a href=\"#容器格式\" class=\"headerlink\" title=\"容器格式\"></a>容器格式</h2><ul>\n<li><a href=\"http://blog.csdn.net/leixiaohua1020/article/details/17934487\" target=\"_blank\" rel=\"noopener\">视音频编解码学习工程：FLV封装格式分析器</a></li>\n</ul>\n<h2 id=\"传输协议\"><a href=\"#传输协议\" class=\"headerlink\" title=\"传输协议\"></a>传输协议</h2><ul>\n<li><a href=\"https://chenlichao.gitbooks.io/rtmp-zh_cn/content/1-introduction.html\" target=\"_blank\" rel=\"noopener\">RTMP协议规范</a></li>\n<li><a href=\"http://mingyangshang.github.io/2016/03/06/RTMP协议/\" target=\"_blank\" rel=\"noopener\">带你吃透RTMP</a></li>\n<li><a href=\"http://blog.csdn.net/win_lin/article/details/12615591\" target=\"_blank\" rel=\"noopener\">RTMP服务器的延迟，多级边缘不影响延迟，gop为最大因素</a></li>\n</ul>\n<h2 id=\"编解码\"><a href=\"#编解码\" class=\"headerlink\" title=\"编解码\"></a>编解码</h2>"},{"title":"使用flv.js做直播","date":"2017-05-17T00:16:24.000Z","url":"https://github.com/gwuhaolin/blog/issues/3","_content":"\n为什么要在这个时候探索flv.js做直播呢？原因在于各大浏览器厂商已经默认禁用Flash，之前常见的Flash直播方案需要用户同意使用Flash后才可以正常使用直播功能，这样的用户体验很致命。\n\n在介绍flv.js之前先介绍下常见的直播协议以及给出我对它们的延迟与性能所做的测试得出的数据。\n如果你看的很吃力可以先了解下音视频技术的一些[基础概念](https://github.com/gwuhaolin/blog/issues/5)。\n\n\n## 常见直播协议\n- **RTMP**: 底层基于`TCP`，在浏览器端依赖Flash。\n- **HTTP-FLV**: 基于`HTTP`流式IO传输FLV，依赖浏览器支持播放FLV。\n- **WebSocket-FLV**: 基于`WebSocket`传输FLV，依赖浏览器支持播放FLV。`WebSocket`建立在`HTTP`之上，建立`WebSocket`连接前还要先建立`HTTP`连接。\n- **HLS**: Http Live Streaming，苹果提出基于`HTTP`的流媒体传输协议。`HTML5`可以直接打开播放。\n- **RTP**: 基于`UDP`，延迟1秒，浏览器不支持。\n\n#### 常见直播协议延迟与性能数据<sub><sup>以下数据只做对比参考</sup></sub>\n| 传输协议 | 播放器 | 延迟 | 内存 | CPU  |\n|----------|--------|------|------|------|\n| RTMP     | Flash  | 1s    | 430M | 11%  |\n| HTTP-FLV | Video  | 1s    | 310M | 4.4% |\n| HLS      | Video  | 20s   | 205M | 3%   | \n\n在支持浏览器的协议里，延迟排序是： \n**RTMP = HTTP-FLV = WebSocket-FLV  < HLS**\n而性能排序恰好相反： \n**RTMP > HTTP-FLV = WebSocket-FLV  > HLS**\n也就是说延迟小的性能不好。\n\n可以看出在浏览器里做直播，使用HTTP-FLV协议是不错的，性能优于RTMP+Flash，延迟可以做到和RTMP+Flash一样甚至更好。\n\n## flv.js 简介\nflv.js是来自Bilibli的开源项目。它解析FLV文件喂给原生HTML5 Video标签播放音视频数据，使浏览器在不借助Flash的情况下播放FLV成为可能。\n\n## flv.js 优势\n- 由于浏览器对原生Video标签采用了硬件加速，性能很好，支持高清。\n- 同时支持录播和直播\n- 去掉对Flash的依赖\n\n## flv.js 限制\n- FLV里所包含的视频编码必须是`H.264`，音频编码必须是`AAC`或`MP3`， IE11和Edge浏览器不支持MP3音频编码，所以FLV里采用的编码最好是H.264+AAC，这个让音视频服务兼容不是问题。\n- 对于录播，依赖 `原生HTML5 Video标签` 和 [Media Source Extensions](https://w3c.github.io/media-source/) API\n- 对于直播，依赖录播所需要的播放技术，同时依赖 `HTTP FLV` 或者 `WebSocket` 中的一种协议来传输FLV。其中`HTTP FLV`需通过流式IO去拉取数据，支持流式IO的有[fetch](https://fetch.spec.whatwg.org)或者[stream](https://streams.spec.whatwg.org)\n- ` flv.min.js` 文件大小 164Kb，gzip后 35.5Kb，flash播放器gzip后差不多也是这么大。\n- 由于依赖`Media Source Extensions`，目前所有iOS和Android4.4.4以下里的浏览器都不支持，也就是说目前对于移动端flv.js基本是不能用的。\n\n####  flv.js依赖的浏览器特性兼容列表\n- [HTML5 Video](http://caniuse.com/#feat=webm)\n- [Media Source Extensions](http://caniuse.com/#feat=mediasource)\n- [WebSocket](http://caniuse.com/#feat=websockets)\n- HTTP FLV: [fetch](http://caniuse.com/#feat=fetch) 或 [stream](http://caniuse.com/#feat=http-live-streaming)\n## flv.js 原理\nflv.js只做了一件事，在获取到FLV格式的音视频数据后通过原生的JS去解码FLV数据，再通过[Media Source Extensions](https://w3c.github.io/media-source/) API 喂给原生HTML5 Video标签。(HTML5 原生仅支持播放 mp4/webm 格式，不支持 FLV)\n\nflv.js 为什么要绕一圈，从服务器获取FLV再解码转换后再喂给Video标签呢？原因如下：\n1. 兼容目前的直播方案：目前大多数直播方案的音视频服务都是采用FLV容器格式传输音视频数据。\n2. FLV容器格式相比于MP4格式更加简单，解析起来更快更方便。\n\n## flv.js兼容方案\n由于目前flv.js兼容性还不是很好，要用在产品中必要要兼顾到不支持flv.js的浏览器。兼容方案如下：\n#### PC端\n1. 优先使用 HTTP-FLV，因为它延迟小，性能也不差1080P都很流畅。\n2. 不支持 flv.js 就使用 Flash播放器播 RTMP 流。Flash兼容性很好，但是性能差默认被很多浏览器禁用。\n3. 不想用Flash兼容也可以用HLS，但是PC端只有Safari支持HLS\n#### 移动端\n1. 优先使用 HTTP-FLV，因为它延迟小，支持HTTP-FLV的设备性能运行 flv.js 足够了。\n2. 不支持 flv.js 就使用 HLS，但是 HLS延迟非常大。\n3. HLS 也不支持就没法直播了，因为移动端都不支持Flash。\n\n## flv.js实战\n说了这么多介绍与原理，接下来教大家如何用flv.js搭建一个完整的直播系统。\n我已经搭建好了[一个demo](http://rawgit.com/gwuhaolin/reflv/gh-pages/live.html)可以供大家体验。\n\n#### 搭建音视频服务\n主播推流到音视频服务，音视频服务再转发给所有连接的客户端。为了让你快速搭建服务推荐我用go语言实现的[livego](https://github.com/gwuhaolin/livego)，因为它可以运行在任何操作系统上，对Golang感兴趣？请看[Golang 中文学习资料汇总](http://go.wuhaolin.cn/)。\n1. [下载livego](https://github.com/gwuhaolin/livego/releases)，注意选对你的操作系统和位数。\n2. 解压，执行`livego`，服务就启动好了。它会启动RTMP(1935端口)服务用于主播推流，以及HTTP-FLV(7001端口)服务用于播放。\n#### 实现播放页\n在react体系里使用react flv.js 组件[reflv](https://github.com/gwuhaolin/reflv) 快速实现。\n先安装`npm i reflv`，再写代码：\n```js\nimport React, { PureComponent } from 'react';\nimport Reflv from 'reflv';\n\nexport class HttpFlv extends PureComponent {\n  render() {\n    return (\n      <Reflv\n        url={`http://localhost:7001/live/test.flv`}\n        type=\"flv\"\n        isLive\n        cors\n      />\n    )\n  }\n}\n```\n让以上代码在浏览器里运行。这是你还看不到直播，是因为还没有主播推流。\n- 你可以使用[OBS](https://obsproject.com)来推流，注意要配置好OBS：\n<img width=\"961\" alt=\"screen shot 2017-06-07 at 5 41 32 pm\" src=\"https://user-images.githubusercontent.com/5773264/26872300-9c1c5bb4-4ba8-11e7-98eb-98e6d6ba751f.png\">\n\n- 也可以使用[ffmpeg](https://ffmpeg.org)来推流，推流命令`ffmpeg -f avfoundation -i \"0\" -vcodec h264 -acodec aac -f flv rtmp://localhost/live/test`\n\n## flv.js延迟优化\n按照上面的教程运行起来的直播延迟大概有3秒，经过优化可以到1秒。在教你怎么优化前先要介绍下直播运行流程：\n1. 主播端在采集到一段时间的音视频原数据后，因为音视频原数据庞大需要先压缩数据：\n    - 通过H264视频编码压缩数据数据\n    - 通过PCM音频编码压缩音频AAC数据\n\n2. 压缩完后再通过FLV容器格式封装压缩后的数据，封装成一个FLV TAG\n3. 再把FLV TAG通过RTMP协议推流到音视频服务器，音视频服务器再从RTMP协议里解析出FLV TAG。\n4. 音视频服务器再通过HTTP协议通过和浏览器建立的长链接流式把FLV TAG传给浏览器。\n5. flv.js 获取FLV TAG后解析出压缩后的音视频数据喂给Video播放。\n\n知道流程后我们就知道从哪入手优化了：\n- 主播端采集时收集了一段时间的音视频原数据，它专业的叫法是[GOP](http://blog.csdn.net/zqj6893/article/details/50262189)。缩短这个收集时间(也就是减少GOP长度)可以优化延迟，但这样做的坏处是导致视频压缩率不高，传输效率低。\n- 关闭音视频服务器的I桢缓存可以优化延迟，坏处是用户看到直播首屏的时间变大。\n- 减少音视频服务器的buffer可以优化延迟，坏处是音视频服务器处理效率降低。\n- 减少浏览器端flv.js的buffer可以优化延迟，坏处是浏览器端处理效率降低。\n- 浏览器端开启flv.js的Worker，多线程运行flv.js提升解析速度可以优化延迟，这样做的flv.js配置代码是：\n```js\n{\n          enableWorker: true,\n          enableStashBuffer: false,\n          stashInitialSize: 128,// 减少首桢显示等待时长\n}\n```\n这里是[优化后的完整代码](https://github.com/gwuhaolin/reflv/blob/master/doc/live/http-flv.js)\n\n\n[阅读原文](http://wuhaolin.cn/2017/05/17/%E4%BD%BF%E7%94%A8flv.js%E5%81%9A%E7%9B%B4%E6%92%AD/)","source":"_posts/使用flv.js做直播.md","raw":"---\ntitle: 使用flv.js做直播\ndate: 2017-05-17T08:16:24Z\nurl: https://github.com/gwuhaolin/blog/issues/3\ntags:\n    - 音视频\n---\n\n为什么要在这个时候探索flv.js做直播呢？原因在于各大浏览器厂商已经默认禁用Flash，之前常见的Flash直播方案需要用户同意使用Flash后才可以正常使用直播功能，这样的用户体验很致命。\n\n在介绍flv.js之前先介绍下常见的直播协议以及给出我对它们的延迟与性能所做的测试得出的数据。\n如果你看的很吃力可以先了解下音视频技术的一些[基础概念](https://github.com/gwuhaolin/blog/issues/5)。\n\n\n## 常见直播协议\n- **RTMP**: 底层基于`TCP`，在浏览器端依赖Flash。\n- **HTTP-FLV**: 基于`HTTP`流式IO传输FLV，依赖浏览器支持播放FLV。\n- **WebSocket-FLV**: 基于`WebSocket`传输FLV，依赖浏览器支持播放FLV。`WebSocket`建立在`HTTP`之上，建立`WebSocket`连接前还要先建立`HTTP`连接。\n- **HLS**: Http Live Streaming，苹果提出基于`HTTP`的流媒体传输协议。`HTML5`可以直接打开播放。\n- **RTP**: 基于`UDP`，延迟1秒，浏览器不支持。\n\n#### 常见直播协议延迟与性能数据<sub><sup>以下数据只做对比参考</sup></sub>\n| 传输协议 | 播放器 | 延迟 | 内存 | CPU  |\n|----------|--------|------|------|------|\n| RTMP     | Flash  | 1s    | 430M | 11%  |\n| HTTP-FLV | Video  | 1s    | 310M | 4.4% |\n| HLS      | Video  | 20s   | 205M | 3%   | \n\n在支持浏览器的协议里，延迟排序是： \n**RTMP = HTTP-FLV = WebSocket-FLV  < HLS**\n而性能排序恰好相反： \n**RTMP > HTTP-FLV = WebSocket-FLV  > HLS**\n也就是说延迟小的性能不好。\n\n可以看出在浏览器里做直播，使用HTTP-FLV协议是不错的，性能优于RTMP+Flash，延迟可以做到和RTMP+Flash一样甚至更好。\n\n## flv.js 简介\nflv.js是来自Bilibli的开源项目。它解析FLV文件喂给原生HTML5 Video标签播放音视频数据，使浏览器在不借助Flash的情况下播放FLV成为可能。\n\n## flv.js 优势\n- 由于浏览器对原生Video标签采用了硬件加速，性能很好，支持高清。\n- 同时支持录播和直播\n- 去掉对Flash的依赖\n\n## flv.js 限制\n- FLV里所包含的视频编码必须是`H.264`，音频编码必须是`AAC`或`MP3`， IE11和Edge浏览器不支持MP3音频编码，所以FLV里采用的编码最好是H.264+AAC，这个让音视频服务兼容不是问题。\n- 对于录播，依赖 `原生HTML5 Video标签` 和 [Media Source Extensions](https://w3c.github.io/media-source/) API\n- 对于直播，依赖录播所需要的播放技术，同时依赖 `HTTP FLV` 或者 `WebSocket` 中的一种协议来传输FLV。其中`HTTP FLV`需通过流式IO去拉取数据，支持流式IO的有[fetch](https://fetch.spec.whatwg.org)或者[stream](https://streams.spec.whatwg.org)\n- ` flv.min.js` 文件大小 164Kb，gzip后 35.5Kb，flash播放器gzip后差不多也是这么大。\n- 由于依赖`Media Source Extensions`，目前所有iOS和Android4.4.4以下里的浏览器都不支持，也就是说目前对于移动端flv.js基本是不能用的。\n\n####  flv.js依赖的浏览器特性兼容列表\n- [HTML5 Video](http://caniuse.com/#feat=webm)\n- [Media Source Extensions](http://caniuse.com/#feat=mediasource)\n- [WebSocket](http://caniuse.com/#feat=websockets)\n- HTTP FLV: [fetch](http://caniuse.com/#feat=fetch) 或 [stream](http://caniuse.com/#feat=http-live-streaming)\n## flv.js 原理\nflv.js只做了一件事，在获取到FLV格式的音视频数据后通过原生的JS去解码FLV数据，再通过[Media Source Extensions](https://w3c.github.io/media-source/) API 喂给原生HTML5 Video标签。(HTML5 原生仅支持播放 mp4/webm 格式，不支持 FLV)\n\nflv.js 为什么要绕一圈，从服务器获取FLV再解码转换后再喂给Video标签呢？原因如下：\n1. 兼容目前的直播方案：目前大多数直播方案的音视频服务都是采用FLV容器格式传输音视频数据。\n2. FLV容器格式相比于MP4格式更加简单，解析起来更快更方便。\n\n## flv.js兼容方案\n由于目前flv.js兼容性还不是很好，要用在产品中必要要兼顾到不支持flv.js的浏览器。兼容方案如下：\n#### PC端\n1. 优先使用 HTTP-FLV，因为它延迟小，性能也不差1080P都很流畅。\n2. 不支持 flv.js 就使用 Flash播放器播 RTMP 流。Flash兼容性很好，但是性能差默认被很多浏览器禁用。\n3. 不想用Flash兼容也可以用HLS，但是PC端只有Safari支持HLS\n#### 移动端\n1. 优先使用 HTTP-FLV，因为它延迟小，支持HTTP-FLV的设备性能运行 flv.js 足够了。\n2. 不支持 flv.js 就使用 HLS，但是 HLS延迟非常大。\n3. HLS 也不支持就没法直播了，因为移动端都不支持Flash。\n\n## flv.js实战\n说了这么多介绍与原理，接下来教大家如何用flv.js搭建一个完整的直播系统。\n我已经搭建好了[一个demo](http://rawgit.com/gwuhaolin/reflv/gh-pages/live.html)可以供大家体验。\n\n#### 搭建音视频服务\n主播推流到音视频服务，音视频服务再转发给所有连接的客户端。为了让你快速搭建服务推荐我用go语言实现的[livego](https://github.com/gwuhaolin/livego)，因为它可以运行在任何操作系统上，对Golang感兴趣？请看[Golang 中文学习资料汇总](http://go.wuhaolin.cn/)。\n1. [下载livego](https://github.com/gwuhaolin/livego/releases)，注意选对你的操作系统和位数。\n2. 解压，执行`livego`，服务就启动好了。它会启动RTMP(1935端口)服务用于主播推流，以及HTTP-FLV(7001端口)服务用于播放。\n#### 实现播放页\n在react体系里使用react flv.js 组件[reflv](https://github.com/gwuhaolin/reflv) 快速实现。\n先安装`npm i reflv`，再写代码：\n```js\nimport React, { PureComponent } from 'react';\nimport Reflv from 'reflv';\n\nexport class HttpFlv extends PureComponent {\n  render() {\n    return (\n      <Reflv\n        url={`http://localhost:7001/live/test.flv`}\n        type=\"flv\"\n        isLive\n        cors\n      />\n    )\n  }\n}\n```\n让以上代码在浏览器里运行。这是你还看不到直播，是因为还没有主播推流。\n- 你可以使用[OBS](https://obsproject.com)来推流，注意要配置好OBS：\n<img width=\"961\" alt=\"screen shot 2017-06-07 at 5 41 32 pm\" src=\"https://user-images.githubusercontent.com/5773264/26872300-9c1c5bb4-4ba8-11e7-98eb-98e6d6ba751f.png\">\n\n- 也可以使用[ffmpeg](https://ffmpeg.org)来推流，推流命令`ffmpeg -f avfoundation -i \"0\" -vcodec h264 -acodec aac -f flv rtmp://localhost/live/test`\n\n## flv.js延迟优化\n按照上面的教程运行起来的直播延迟大概有3秒，经过优化可以到1秒。在教你怎么优化前先要介绍下直播运行流程：\n1. 主播端在采集到一段时间的音视频原数据后，因为音视频原数据庞大需要先压缩数据：\n    - 通过H264视频编码压缩数据数据\n    - 通过PCM音频编码压缩音频AAC数据\n\n2. 压缩完后再通过FLV容器格式封装压缩后的数据，封装成一个FLV TAG\n3. 再把FLV TAG通过RTMP协议推流到音视频服务器，音视频服务器再从RTMP协议里解析出FLV TAG。\n4. 音视频服务器再通过HTTP协议通过和浏览器建立的长链接流式把FLV TAG传给浏览器。\n5. flv.js 获取FLV TAG后解析出压缩后的音视频数据喂给Video播放。\n\n知道流程后我们就知道从哪入手优化了：\n- 主播端采集时收集了一段时间的音视频原数据，它专业的叫法是[GOP](http://blog.csdn.net/zqj6893/article/details/50262189)。缩短这个收集时间(也就是减少GOP长度)可以优化延迟，但这样做的坏处是导致视频压缩率不高，传输效率低。\n- 关闭音视频服务器的I桢缓存可以优化延迟，坏处是用户看到直播首屏的时间变大。\n- 减少音视频服务器的buffer可以优化延迟，坏处是音视频服务器处理效率降低。\n- 减少浏览器端flv.js的buffer可以优化延迟，坏处是浏览器端处理效率降低。\n- 浏览器端开启flv.js的Worker，多线程运行flv.js提升解析速度可以优化延迟，这样做的flv.js配置代码是：\n```js\n{\n          enableWorker: true,\n          enableStashBuffer: false,\n          stashInitialSize: 128,// 减少首桢显示等待时长\n}\n```\n这里是[优化后的完整代码](https://github.com/gwuhaolin/reflv/blob/master/doc/live/http-flv.js)\n\n\n[阅读原文](http://wuhaolin.cn/2017/05/17/%E4%BD%BF%E7%94%A8flv.js%E5%81%9A%E7%9B%B4%E6%92%AD/)","slug":"使用flv.js做直播","published":1,"updated":"2018-11-14T04:39:28.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjogs0kee000ig5tc8l66u6w1","content":"<p>为什么要在这个时候探索flv.js做直播呢？原因在于各大浏览器厂商已经默认禁用Flash，之前常见的Flash直播方案需要用户同意使用Flash后才可以正常使用直播功能，这样的用户体验很致命。</p>\n<p>在介绍flv.js之前先介绍下常见的直播协议以及给出我对它们的延迟与性能所做的测试得出的数据。<br>如果你看的很吃力可以先了解下音视频技术的一些<a href=\"https://github.com/gwuhaolin/blog/issues/5\" target=\"_blank\" rel=\"noopener\">基础概念</a>。</p>\n<h2 id=\"常见直播协议\"><a href=\"#常见直播协议\" class=\"headerlink\" title=\"常见直播协议\"></a>常见直播协议</h2><ul>\n<li><strong>RTMP</strong>: 底层基于<code>TCP</code>，在浏览器端依赖Flash。</li>\n<li><strong>HTTP-FLV</strong>: 基于<code>HTTP</code>流式IO传输FLV，依赖浏览器支持播放FLV。</li>\n<li><strong>WebSocket-FLV</strong>: 基于<code>WebSocket</code>传输FLV，依赖浏览器支持播放FLV。<code>WebSocket</code>建立在<code>HTTP</code>之上，建立<code>WebSocket</code>连接前还要先建立<code>HTTP</code>连接。</li>\n<li><strong>HLS</strong>: Http Live Streaming，苹果提出基于<code>HTTP</code>的流媒体传输协议。<code>HTML5</code>可以直接打开播放。</li>\n<li><strong>RTP</strong>: 基于<code>UDP</code>，延迟1秒，浏览器不支持。</li>\n</ul>\n<h4 id=\"常见直播协议延迟与性能数据以下数据只做对比参考\"><a href=\"#常见直播协议延迟与性能数据以下数据只做对比参考\" class=\"headerlink\" title=\"常见直播协议延迟与性能数据以下数据只做对比参考\"></a>常见直播协议延迟与性能数据<sub><sup>以下数据只做对比参考</sup></sub></h4><table>\n<thead>\n<tr>\n<th>传输协议</th>\n<th>播放器</th>\n<th>延迟</th>\n<th>内存</th>\n<th>CPU</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RTMP</td>\n<td>Flash</td>\n<td>1s</td>\n<td>430M</td>\n<td>11%</td>\n</tr>\n<tr>\n<td>HTTP-FLV</td>\n<td>Video</td>\n<td>1s</td>\n<td>310M</td>\n<td>4.4%</td>\n</tr>\n<tr>\n<td>HLS</td>\n<td>Video</td>\n<td>20s</td>\n<td>205M</td>\n<td>3%</td>\n</tr>\n</tbody>\n</table>\n<p>在支持浏览器的协议里，延迟排序是：<br><strong>RTMP = HTTP-FLV = WebSocket-FLV  &lt; HLS</strong><br>而性能排序恰好相反：<br><strong>RTMP &gt; HTTP-FLV = WebSocket-FLV  &gt; HLS</strong><br>也就是说延迟小的性能不好。</p>\n<p>可以看出在浏览器里做直播，使用HTTP-FLV协议是不错的，性能优于RTMP+Flash，延迟可以做到和RTMP+Flash一样甚至更好。</p>\n<h2 id=\"flv-js-简介\"><a href=\"#flv-js-简介\" class=\"headerlink\" title=\"flv.js 简介\"></a>flv.js 简介</h2><p>flv.js是来自Bilibli的开源项目。它解析FLV文件喂给原生HTML5 Video标签播放音视频数据，使浏览器在不借助Flash的情况下播放FLV成为可能。</p>\n<h2 id=\"flv-js-优势\"><a href=\"#flv-js-优势\" class=\"headerlink\" title=\"flv.js 优势\"></a>flv.js 优势</h2><ul>\n<li>由于浏览器对原生Video标签采用了硬件加速，性能很好，支持高清。</li>\n<li>同时支持录播和直播</li>\n<li>去掉对Flash的依赖</li>\n</ul>\n<h2 id=\"flv-js-限制\"><a href=\"#flv-js-限制\" class=\"headerlink\" title=\"flv.js 限制\"></a>flv.js 限制</h2><ul>\n<li>FLV里所包含的视频编码必须是<code>H.264</code>，音频编码必须是<code>AAC</code>或<code>MP3</code>， IE11和Edge浏览器不支持MP3音频编码，所以FLV里采用的编码最好是H.264+AAC，这个让音视频服务兼容不是问题。</li>\n<li>对于录播，依赖 <code>原生HTML5 Video标签</code> 和 <a href=\"https://w3c.github.io/media-source/\" target=\"_blank\" rel=\"noopener\">Media Source Extensions</a> API</li>\n<li>对于直播，依赖录播所需要的播放技术，同时依赖 <code>HTTP FLV</code> 或者 <code>WebSocket</code> 中的一种协议来传输FLV。其中<code>HTTP FLV</code>需通过流式IO去拉取数据，支持流式IO的有<a href=\"https://fetch.spec.whatwg.org\" target=\"_blank\" rel=\"noopener\">fetch</a>或者<a href=\"https://streams.spec.whatwg.org\" target=\"_blank\" rel=\"noopener\">stream</a></li>\n<li><code>flv.min.js</code> 文件大小 164Kb，gzip后 35.5Kb，flash播放器gzip后差不多也是这么大。</li>\n<li>由于依赖<code>Media Source Extensions</code>，目前所有iOS和Android4.4.4以下里的浏览器都不支持，也就是说目前对于移动端flv.js基本是不能用的。</li>\n</ul>\n<h4 id=\"flv-js依赖的浏览器特性兼容列表\"><a href=\"#flv-js依赖的浏览器特性兼容列表\" class=\"headerlink\" title=\"flv.js依赖的浏览器特性兼容列表\"></a>flv.js依赖的浏览器特性兼容列表</h4><ul>\n<li><a href=\"http://caniuse.com/#feat=webm\" target=\"_blank\" rel=\"noopener\">HTML5 Video</a></li>\n<li><a href=\"http://caniuse.com/#feat=mediasource\" target=\"_blank\" rel=\"noopener\">Media Source Extensions</a></li>\n<li><a href=\"http://caniuse.com/#feat=websockets\" target=\"_blank\" rel=\"noopener\">WebSocket</a></li>\n<li>HTTP FLV: <a href=\"http://caniuse.com/#feat=fetch\" target=\"_blank\" rel=\"noopener\">fetch</a> 或 <a href=\"http://caniuse.com/#feat=http-live-streaming\" target=\"_blank\" rel=\"noopener\">stream</a><h2 id=\"flv-js-原理\"><a href=\"#flv-js-原理\" class=\"headerlink\" title=\"flv.js 原理\"></a>flv.js 原理</h2>flv.js只做了一件事，在获取到FLV格式的音视频数据后通过原生的JS去解码FLV数据，再通过<a href=\"https://w3c.github.io/media-source/\" target=\"_blank\" rel=\"noopener\">Media Source Extensions</a> API 喂给原生HTML5 Video标签。(HTML5 原生仅支持播放 mp4/webm 格式，不支持 FLV)</li>\n</ul>\n<p>flv.js 为什么要绕一圈，从服务器获取FLV再解码转换后再喂给Video标签呢？原因如下：</p>\n<ol>\n<li>兼容目前的直播方案：目前大多数直播方案的音视频服务都是采用FLV容器格式传输音视频数据。</li>\n<li>FLV容器格式相比于MP4格式更加简单，解析起来更快更方便。</li>\n</ol>\n<h2 id=\"flv-js兼容方案\"><a href=\"#flv-js兼容方案\" class=\"headerlink\" title=\"flv.js兼容方案\"></a>flv.js兼容方案</h2><p>由于目前flv.js兼容性还不是很好，要用在产品中必要要兼顾到不支持flv.js的浏览器。兼容方案如下：</p>\n<h4 id=\"PC端\"><a href=\"#PC端\" class=\"headerlink\" title=\"PC端\"></a>PC端</h4><ol>\n<li>优先使用 HTTP-FLV，因为它延迟小，性能也不差1080P都很流畅。</li>\n<li>不支持 flv.js 就使用 Flash播放器播 RTMP 流。Flash兼容性很好，但是性能差默认被很多浏览器禁用。</li>\n<li>不想用Flash兼容也可以用HLS，但是PC端只有Safari支持HLS<h4 id=\"移动端\"><a href=\"#移动端\" class=\"headerlink\" title=\"移动端\"></a>移动端</h4></li>\n<li>优先使用 HTTP-FLV，因为它延迟小，支持HTTP-FLV的设备性能运行 flv.js 足够了。</li>\n<li>不支持 flv.js 就使用 HLS，但是 HLS延迟非常大。</li>\n<li>HLS 也不支持就没法直播了，因为移动端都不支持Flash。</li>\n</ol>\n<h2 id=\"flv-js实战\"><a href=\"#flv-js实战\" class=\"headerlink\" title=\"flv.js实战\"></a>flv.js实战</h2><p>说了这么多介绍与原理，接下来教大家如何用flv.js搭建一个完整的直播系统。<br>我已经搭建好了<a href=\"http://rawgit.com/gwuhaolin/reflv/gh-pages/live.html\" target=\"_blank\" rel=\"noopener\">一个demo</a>可以供大家体验。</p>\n<h4 id=\"搭建音视频服务\"><a href=\"#搭建音视频服务\" class=\"headerlink\" title=\"搭建音视频服务\"></a>搭建音视频服务</h4><p>主播推流到音视频服务，音视频服务再转发给所有连接的客户端。为了让你快速搭建服务推荐我用go语言实现的<a href=\"https://github.com/gwuhaolin/livego\" target=\"_blank\" rel=\"noopener\">livego</a>，因为它可以运行在任何操作系统上，对Golang感兴趣？请看<a href=\"http://go.wuhaolin.cn/\" target=\"_blank\" rel=\"noopener\">Golang 中文学习资料汇总</a>。</p>\n<ol>\n<li><a href=\"https://github.com/gwuhaolin/livego/releases\" target=\"_blank\" rel=\"noopener\">下载livego</a>，注意选对你的操作系统和位数。</li>\n<li>解压，执行<code>livego</code>，服务就启动好了。它会启动RTMP(1935端口)服务用于主播推流，以及HTTP-FLV(7001端口)服务用于播放。<h4 id=\"实现播放页\"><a href=\"#实现播放页\" class=\"headerlink\" title=\"实现播放页\"></a>实现播放页</h4>在react体系里使用react flv.js 组件<a href=\"https://github.com/gwuhaolin/reflv\" target=\"_blank\" rel=\"noopener\">reflv</a> 快速实现。<br>先安装<code>npm i reflv</code>，再写代码：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; PureComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Reflv <span class=\"keyword\">from</span> <span class=\"string\">'reflv'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpFlv</span> <span class=\"keyword\">extends</span> <span class=\"title\">PureComponent</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Reflv</span><br><span class=\"line\">        url=&#123;<span class=\"string\">`http://localhost:7001/live/test.flv`</span>&#125;</span><br><span class=\"line\">        type=<span class=\"string\">\"flv\"</span></span><br><span class=\"line\">        isLive</span><br><span class=\"line\">        cors</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>让以上代码在浏览器里运行。这是你还看不到直播，是因为还没有主播推流。</p>\n<ul>\n<li><p>你可以使用<a href=\"https://obsproject.com\" target=\"_blank\" rel=\"noopener\">OBS</a>来推流，注意要配置好OBS：<br><img width=\"961\" alt=\"screen shot 2017-06-07 at 5 41 32 pm\" src=\"https://user-images.githubusercontent.com/5773264/26872300-9c1c5bb4-4ba8-11e7-98eb-98e6d6ba751f.png\"></p>\n</li>\n<li><p>也可以使用<a href=\"https://ffmpeg.org\" target=\"_blank\" rel=\"noopener\">ffmpeg</a>来推流，推流命令<code>ffmpeg -f avfoundation -i &quot;0&quot; -vcodec h264 -acodec aac -f flv rtmp://localhost/live/test</code></p>\n</li>\n</ul>\n<h2 id=\"flv-js延迟优化\"><a href=\"#flv-js延迟优化\" class=\"headerlink\" title=\"flv.js延迟优化\"></a>flv.js延迟优化</h2><p>按照上面的教程运行起来的直播延迟大概有3秒，经过优化可以到1秒。在教你怎么优化前先要介绍下直播运行流程：</p>\n<ol>\n<li><p>主播端在采集到一段时间的音视频原数据后，因为音视频原数据庞大需要先压缩数据：</p>\n<ul>\n<li>通过H264视频编码压缩数据数据</li>\n<li>通过PCM音频编码压缩音频AAC数据</li>\n</ul>\n</li>\n<li><p>压缩完后再通过FLV容器格式封装压缩后的数据，封装成一个FLV TAG</p>\n</li>\n<li>再把FLV TAG通过RTMP协议推流到音视频服务器，音视频服务器再从RTMP协议里解析出FLV TAG。</li>\n<li>音视频服务器再通过HTTP协议通过和浏览器建立的长链接流式把FLV TAG传给浏览器。</li>\n<li>flv.js 获取FLV TAG后解析出压缩后的音视频数据喂给Video播放。</li>\n</ol>\n<p>知道流程后我们就知道从哪入手优化了：</p>\n<ul>\n<li>主播端采集时收集了一段时间的音视频原数据，它专业的叫法是<a href=\"http://blog.csdn.net/zqj6893/article/details/50262189\" target=\"_blank\" rel=\"noopener\">GOP</a>。缩短这个收集时间(也就是减少GOP长度)可以优化延迟，但这样做的坏处是导致视频压缩率不高，传输效率低。</li>\n<li>关闭音视频服务器的I桢缓存可以优化延迟，坏处是用户看到直播首屏的时间变大。</li>\n<li>减少音视频服务器的buffer可以优化延迟，坏处是音视频服务器处理效率降低。</li>\n<li>减少浏览器端flv.js的buffer可以优化延迟，坏处是浏览器端处理效率降低。</li>\n<li>浏览器端开启flv.js的Worker，多线程运行flv.js提升解析速度可以优化延迟，这样做的flv.js配置代码是：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">          enableWorker: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          enableStashBuffer: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          stashInitialSize: <span class=\"number\">128</span>,<span class=\"comment\">// 减少首桢显示等待时长</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里是<a href=\"https://github.com/gwuhaolin/reflv/blob/master/doc/live/http-flv.js\" target=\"_blank\" rel=\"noopener\">优化后的完整代码</a></p>\n<p><a href=\"http://wuhaolin.cn/2017/05/17/%E4%BD%BF%E7%94%A8flv.js%E5%81%9A%E7%9B%B4%E6%92%AD/\">阅读原文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>为什么要在这个时候探索flv.js做直播呢？原因在于各大浏览器厂商已经默认禁用Flash，之前常见的Flash直播方案需要用户同意使用Flash后才可以正常使用直播功能，这样的用户体验很致命。</p>\n<p>在介绍flv.js之前先介绍下常见的直播协议以及给出我对它们的延迟与性能所做的测试得出的数据。<br>如果你看的很吃力可以先了解下音视频技术的一些<a href=\"https://github.com/gwuhaolin/blog/issues/5\" target=\"_blank\" rel=\"noopener\">基础概念</a>。</p>\n<h2 id=\"常见直播协议\"><a href=\"#常见直播协议\" class=\"headerlink\" title=\"常见直播协议\"></a>常见直播协议</h2><ul>\n<li><strong>RTMP</strong>: 底层基于<code>TCP</code>，在浏览器端依赖Flash。</li>\n<li><strong>HTTP-FLV</strong>: 基于<code>HTTP</code>流式IO传输FLV，依赖浏览器支持播放FLV。</li>\n<li><strong>WebSocket-FLV</strong>: 基于<code>WebSocket</code>传输FLV，依赖浏览器支持播放FLV。<code>WebSocket</code>建立在<code>HTTP</code>之上，建立<code>WebSocket</code>连接前还要先建立<code>HTTP</code>连接。</li>\n<li><strong>HLS</strong>: Http Live Streaming，苹果提出基于<code>HTTP</code>的流媒体传输协议。<code>HTML5</code>可以直接打开播放。</li>\n<li><strong>RTP</strong>: 基于<code>UDP</code>，延迟1秒，浏览器不支持。</li>\n</ul>\n<h4 id=\"常见直播协议延迟与性能数据以下数据只做对比参考\"><a href=\"#常见直播协议延迟与性能数据以下数据只做对比参考\" class=\"headerlink\" title=\"常见直播协议延迟与性能数据以下数据只做对比参考\"></a>常见直播协议延迟与性能数据<sub><sup>以下数据只做对比参考</sup></sub></h4><table>\n<thead>\n<tr>\n<th>传输协议</th>\n<th>播放器</th>\n<th>延迟</th>\n<th>内存</th>\n<th>CPU</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RTMP</td>\n<td>Flash</td>\n<td>1s</td>\n<td>430M</td>\n<td>11%</td>\n</tr>\n<tr>\n<td>HTTP-FLV</td>\n<td>Video</td>\n<td>1s</td>\n<td>310M</td>\n<td>4.4%</td>\n</tr>\n<tr>\n<td>HLS</td>\n<td>Video</td>\n<td>20s</td>\n<td>205M</td>\n<td>3%</td>\n</tr>\n</tbody>\n</table>\n<p>在支持浏览器的协议里，延迟排序是：<br><strong>RTMP = HTTP-FLV = WebSocket-FLV  &lt; HLS</strong><br>而性能排序恰好相反：<br><strong>RTMP &gt; HTTP-FLV = WebSocket-FLV  &gt; HLS</strong><br>也就是说延迟小的性能不好。</p>\n<p>可以看出在浏览器里做直播，使用HTTP-FLV协议是不错的，性能优于RTMP+Flash，延迟可以做到和RTMP+Flash一样甚至更好。</p>\n<h2 id=\"flv-js-简介\"><a href=\"#flv-js-简介\" class=\"headerlink\" title=\"flv.js 简介\"></a>flv.js 简介</h2><p>flv.js是来自Bilibli的开源项目。它解析FLV文件喂给原生HTML5 Video标签播放音视频数据，使浏览器在不借助Flash的情况下播放FLV成为可能。</p>\n<h2 id=\"flv-js-优势\"><a href=\"#flv-js-优势\" class=\"headerlink\" title=\"flv.js 优势\"></a>flv.js 优势</h2><ul>\n<li>由于浏览器对原生Video标签采用了硬件加速，性能很好，支持高清。</li>\n<li>同时支持录播和直播</li>\n<li>去掉对Flash的依赖</li>\n</ul>\n<h2 id=\"flv-js-限制\"><a href=\"#flv-js-限制\" class=\"headerlink\" title=\"flv.js 限制\"></a>flv.js 限制</h2><ul>\n<li>FLV里所包含的视频编码必须是<code>H.264</code>，音频编码必须是<code>AAC</code>或<code>MP3</code>， IE11和Edge浏览器不支持MP3音频编码，所以FLV里采用的编码最好是H.264+AAC，这个让音视频服务兼容不是问题。</li>\n<li>对于录播，依赖 <code>原生HTML5 Video标签</code> 和 <a href=\"https://w3c.github.io/media-source/\" target=\"_blank\" rel=\"noopener\">Media Source Extensions</a> API</li>\n<li>对于直播，依赖录播所需要的播放技术，同时依赖 <code>HTTP FLV</code> 或者 <code>WebSocket</code> 中的一种协议来传输FLV。其中<code>HTTP FLV</code>需通过流式IO去拉取数据，支持流式IO的有<a href=\"https://fetch.spec.whatwg.org\" target=\"_blank\" rel=\"noopener\">fetch</a>或者<a href=\"https://streams.spec.whatwg.org\" target=\"_blank\" rel=\"noopener\">stream</a></li>\n<li><code>flv.min.js</code> 文件大小 164Kb，gzip后 35.5Kb，flash播放器gzip后差不多也是这么大。</li>\n<li>由于依赖<code>Media Source Extensions</code>，目前所有iOS和Android4.4.4以下里的浏览器都不支持，也就是说目前对于移动端flv.js基本是不能用的。</li>\n</ul>\n<h4 id=\"flv-js依赖的浏览器特性兼容列表\"><a href=\"#flv-js依赖的浏览器特性兼容列表\" class=\"headerlink\" title=\"flv.js依赖的浏览器特性兼容列表\"></a>flv.js依赖的浏览器特性兼容列表</h4><ul>\n<li><a href=\"http://caniuse.com/#feat=webm\" target=\"_blank\" rel=\"noopener\">HTML5 Video</a></li>\n<li><a href=\"http://caniuse.com/#feat=mediasource\" target=\"_blank\" rel=\"noopener\">Media Source Extensions</a></li>\n<li><a href=\"http://caniuse.com/#feat=websockets\" target=\"_blank\" rel=\"noopener\">WebSocket</a></li>\n<li>HTTP FLV: <a href=\"http://caniuse.com/#feat=fetch\" target=\"_blank\" rel=\"noopener\">fetch</a> 或 <a href=\"http://caniuse.com/#feat=http-live-streaming\" target=\"_blank\" rel=\"noopener\">stream</a><h2 id=\"flv-js-原理\"><a href=\"#flv-js-原理\" class=\"headerlink\" title=\"flv.js 原理\"></a>flv.js 原理</h2>flv.js只做了一件事，在获取到FLV格式的音视频数据后通过原生的JS去解码FLV数据，再通过<a href=\"https://w3c.github.io/media-source/\" target=\"_blank\" rel=\"noopener\">Media Source Extensions</a> API 喂给原生HTML5 Video标签。(HTML5 原生仅支持播放 mp4/webm 格式，不支持 FLV)</li>\n</ul>\n<p>flv.js 为什么要绕一圈，从服务器获取FLV再解码转换后再喂给Video标签呢？原因如下：</p>\n<ol>\n<li>兼容目前的直播方案：目前大多数直播方案的音视频服务都是采用FLV容器格式传输音视频数据。</li>\n<li>FLV容器格式相比于MP4格式更加简单，解析起来更快更方便。</li>\n</ol>\n<h2 id=\"flv-js兼容方案\"><a href=\"#flv-js兼容方案\" class=\"headerlink\" title=\"flv.js兼容方案\"></a>flv.js兼容方案</h2><p>由于目前flv.js兼容性还不是很好，要用在产品中必要要兼顾到不支持flv.js的浏览器。兼容方案如下：</p>\n<h4 id=\"PC端\"><a href=\"#PC端\" class=\"headerlink\" title=\"PC端\"></a>PC端</h4><ol>\n<li>优先使用 HTTP-FLV，因为它延迟小，性能也不差1080P都很流畅。</li>\n<li>不支持 flv.js 就使用 Flash播放器播 RTMP 流。Flash兼容性很好，但是性能差默认被很多浏览器禁用。</li>\n<li>不想用Flash兼容也可以用HLS，但是PC端只有Safari支持HLS<h4 id=\"移动端\"><a href=\"#移动端\" class=\"headerlink\" title=\"移动端\"></a>移动端</h4></li>\n<li>优先使用 HTTP-FLV，因为它延迟小，支持HTTP-FLV的设备性能运行 flv.js 足够了。</li>\n<li>不支持 flv.js 就使用 HLS，但是 HLS延迟非常大。</li>\n<li>HLS 也不支持就没法直播了，因为移动端都不支持Flash。</li>\n</ol>\n<h2 id=\"flv-js实战\"><a href=\"#flv-js实战\" class=\"headerlink\" title=\"flv.js实战\"></a>flv.js实战</h2><p>说了这么多介绍与原理，接下来教大家如何用flv.js搭建一个完整的直播系统。<br>我已经搭建好了<a href=\"http://rawgit.com/gwuhaolin/reflv/gh-pages/live.html\" target=\"_blank\" rel=\"noopener\">一个demo</a>可以供大家体验。</p>\n<h4 id=\"搭建音视频服务\"><a href=\"#搭建音视频服务\" class=\"headerlink\" title=\"搭建音视频服务\"></a>搭建音视频服务</h4><p>主播推流到音视频服务，音视频服务再转发给所有连接的客户端。为了让你快速搭建服务推荐我用go语言实现的<a href=\"https://github.com/gwuhaolin/livego\" target=\"_blank\" rel=\"noopener\">livego</a>，因为它可以运行在任何操作系统上，对Golang感兴趣？请看<a href=\"http://go.wuhaolin.cn/\" target=\"_blank\" rel=\"noopener\">Golang 中文学习资料汇总</a>。</p>\n<ol>\n<li><a href=\"https://github.com/gwuhaolin/livego/releases\" target=\"_blank\" rel=\"noopener\">下载livego</a>，注意选对你的操作系统和位数。</li>\n<li>解压，执行<code>livego</code>，服务就启动好了。它会启动RTMP(1935端口)服务用于主播推流，以及HTTP-FLV(7001端口)服务用于播放。<h4 id=\"实现播放页\"><a href=\"#实现播放页\" class=\"headerlink\" title=\"实现播放页\"></a>实现播放页</h4>在react体系里使用react flv.js 组件<a href=\"https://github.com/gwuhaolin/reflv\" target=\"_blank\" rel=\"noopener\">reflv</a> 快速实现。<br>先安装<code>npm i reflv</code>，再写代码：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; PureComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Reflv <span class=\"keyword\">from</span> <span class=\"string\">'reflv'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpFlv</span> <span class=\"keyword\">extends</span> <span class=\"title\">PureComponent</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Reflv</span><br><span class=\"line\">        url=&#123;<span class=\"string\">`http://localhost:7001/live/test.flv`</span>&#125;</span><br><span class=\"line\">        type=<span class=\"string\">\"flv\"</span></span><br><span class=\"line\">        isLive</span><br><span class=\"line\">        cors</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>让以上代码在浏览器里运行。这是你还看不到直播，是因为还没有主播推流。</p>\n<ul>\n<li><p>你可以使用<a href=\"https://obsproject.com\" target=\"_blank\" rel=\"noopener\">OBS</a>来推流，注意要配置好OBS：<br><img width=\"961\" alt=\"screen shot 2017-06-07 at 5 41 32 pm\" src=\"https://user-images.githubusercontent.com/5773264/26872300-9c1c5bb4-4ba8-11e7-98eb-98e6d6ba751f.png\"></p>\n</li>\n<li><p>也可以使用<a href=\"https://ffmpeg.org\" target=\"_blank\" rel=\"noopener\">ffmpeg</a>来推流，推流命令<code>ffmpeg -f avfoundation -i &quot;0&quot; -vcodec h264 -acodec aac -f flv rtmp://localhost/live/test</code></p>\n</li>\n</ul>\n<h2 id=\"flv-js延迟优化\"><a href=\"#flv-js延迟优化\" class=\"headerlink\" title=\"flv.js延迟优化\"></a>flv.js延迟优化</h2><p>按照上面的教程运行起来的直播延迟大概有3秒，经过优化可以到1秒。在教你怎么优化前先要介绍下直播运行流程：</p>\n<ol>\n<li><p>主播端在采集到一段时间的音视频原数据后，因为音视频原数据庞大需要先压缩数据：</p>\n<ul>\n<li>通过H264视频编码压缩数据数据</li>\n<li>通过PCM音频编码压缩音频AAC数据</li>\n</ul>\n</li>\n<li><p>压缩完后再通过FLV容器格式封装压缩后的数据，封装成一个FLV TAG</p>\n</li>\n<li>再把FLV TAG通过RTMP协议推流到音视频服务器，音视频服务器再从RTMP协议里解析出FLV TAG。</li>\n<li>音视频服务器再通过HTTP协议通过和浏览器建立的长链接流式把FLV TAG传给浏览器。</li>\n<li>flv.js 获取FLV TAG后解析出压缩后的音视频数据喂给Video播放。</li>\n</ol>\n<p>知道流程后我们就知道从哪入手优化了：</p>\n<ul>\n<li>主播端采集时收集了一段时间的音视频原数据，它专业的叫法是<a href=\"http://blog.csdn.net/zqj6893/article/details/50262189\" target=\"_blank\" rel=\"noopener\">GOP</a>。缩短这个收集时间(也就是减少GOP长度)可以优化延迟，但这样做的坏处是导致视频压缩率不高，传输效率低。</li>\n<li>关闭音视频服务器的I桢缓存可以优化延迟，坏处是用户看到直播首屏的时间变大。</li>\n<li>减少音视频服务器的buffer可以优化延迟，坏处是音视频服务器处理效率降低。</li>\n<li>减少浏览器端flv.js的buffer可以优化延迟，坏处是浏览器端处理效率降低。</li>\n<li>浏览器端开启flv.js的Worker，多线程运行flv.js提升解析速度可以优化延迟，这样做的flv.js配置代码是：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">          enableWorker: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          enableStashBuffer: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          stashInitialSize: <span class=\"number\">128</span>,<span class=\"comment\">// 减少首桢显示等待时长</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里是<a href=\"https://github.com/gwuhaolin/reflv/blob/master/doc/live/http-flv.js\" target=\"_blank\" rel=\"noopener\">优化后的完整代码</a></p>\n<p><a href=\"http://wuhaolin.cn/2017/05/17/%E4%BD%BF%E7%94%A8flv.js%E5%81%9A%E7%9B%B4%E6%92%AD/\">阅读原文</a></p>\n"},{"title":"加速 Webpack","date":"2018-08-10T17:25:33.000Z","url":"https://github.com/gwuhaolin/blog/issues/16","_content":"\n> 本文首发于[IBM Dev社区](https://www.ibm.com/developerworks/cn/web/wa-lo-expedite-webpack/index.html)\n\nWeb 应用日益复杂，相关开发技术也百花齐放，这对前端构建工具提出了更高的要求。 Webpack 从众多构建工具中脱颖而出成为目前最流行的构建工具，几乎成为目前前端开发里的必备工具之一。 大多数人在使用 Webpack 的过程中都会遇到构建速度慢的问题，在项目大时显得尤为突出，这极大的影响了我们的开发体验，降低了我们的开发效率。\n\n本文将传授你一些加速 Webpack 构建的技巧，下面来一一介绍。\n\n\n\n# 通过多进程并行处理\n\n由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。 运行在 Node.js 之上的 Webpack 是单线程模型的，也就是说 Webpack 需要处理的任务需要一件件挨着做，不能多个事情一起做。\n\n文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？\n\n### 使用 HappyPack\n\nHappyPack 就能让 Webpack 做到上面抛出的问题，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。\n\n接入 HappyPack 的相关代码如下：\n\n```js\nconst path = require('path');\n    const  ExtractTextPlugin =  require('extract-text-webpack-plugin');\n    const  HappyPack = require('happypack');\n    module.exports = { \n        module: { \n            rules: [ \n                {    test: /\\.js$/, \n                    // 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例 \n                    use:['happypack/loader?id=babel'], \n                    // 排除 node_modules 目录下的文件，node_modules目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换 \n                    exclude: path.resolve(__dirname, 'node_modules'),\n                 }, \n                { \n                    // 把对 .css 文件的处理转交给 id 为 css 的 HappyPack 实例\n                     test: /\\.css$/, \n                     use:ExtractTextPlugin.extract({ \n                        use: ['happypack/loader?id=css'],\n             }), \n        }, \n] },\n    plugins: [ \n        new HappyPack({ \n            // 用唯一的标识符 id 来代表当前的HappyPack 是用来处理一类特定的文件 \n        id: 'babel', \n            // 如何处理 .js 文件，用法和 Loader配置中一样 \n        loaders: ['babel-loader?cacheDirectory'],\n     }),\n        new HappyPack({ \n                id: 'css', \n                    // 如何处理 .css 文件，用法和Loader 配置中一样 \n                loaders: ['css-loader'], }), \n                new ExtractTextPlugin({ \n                    filename: `[name].css`, \n            }), \n        ],\n    };\n```\n\n以上代码有两点重要的修改：\n\n- 在 Loader 配置中，所有文件的处理都交给了 happypack/loader 去处理，使用紧跟其后的 querystring ?id=babel 去告诉 happypack/loader 去选择哪个 HappyPack 实例去处理文件。\n- 在 Plugin 配置中，新增了两个 HappyPack 实例分别用于告诉 happypack/loader 去如何处理 .js 和 .css 文件。选项中的 id 属性的值和上面 querystring 中的 ?id=babel 相对应，选项中的 loaders 属性和 Loader 配置中一样。\n\n接入 HappyPack 后，你需要给项目安装新的依赖：\n\n```js\nnpm i -D happypack\n```\n\n安装成功后重新执行构建，你就会看到以下由 HappyPack 输出的日志：\n\n```\nHappy[babel]: Version: 4.0.0-beta.5. Threads: 3\nHappy[babel]: All set; signaling webpack to proceed.Happy[css]: Version: 4.0.0-beta.5. Threads: 3Happy[css]: All set; signaling webpack to proceed.\n```\n\n说明你的 HappyPack 配置生效了，并且可以得知 HappyPack 分别启动了3个子进程去并行的处理任务。\n\n在整个 Webpack 构建流程中，最耗时的流程可能就是 Loader 对文件的转换操作了，因为要转换的文件数据巨多，而且这些转换操作都只能一个个挨着处理。 HappyPack 的核心原理就是把这部分任务分解到多个进程去并行处理，从而减少了总的构建时间。\n\n从前面的使用中可以看出所有需要通过 Loader 处理的文件都先交给了 happypack/loader 去处理，收集到了这些文件的处理权后 HappyPack 就好统一分配了。\n\n每通过 new HappyPack() 实例化一个 HappyPack 其实就是告诉 HappyPack 核心调度器如何通过一系列 Loader 去转换一类文件，并且可以指定如何给这类转换操作分配子进程。\n\n核心调度器的逻辑代码在主进程中，也就是运行着 Webpack 的进程中，核心调度器会把一个个任务分配给当前空闲的子进程，子进程处理完毕后把结果发送给核心调度器，它们之间的数据交换是通过进程间通信 API 实现的。\n\n核心调度器收到来自子进程处理完毕的结果后会通知 Webpack 该文件处理完毕。\n\n### 使用 ParallelUglifyPlugin\n\n在使用 Webpack 构建出用于发布到线上的代码时，都会有压缩代码这一流程。 最常见的 JavaScript 代码压缩工具是 UglifyJS，并且 Webpack 也内置了它。\n\n用过 UglifyJS 的你一定会发现在构建用于开发环境的代码时很快就能完成，但在构建用于线上的代码时构建一直卡在一个时间点迟迟没有反应，其实卡住的这个时候就是在进行代码压缩。\n\n由于压缩 JavaScript 代码需要先把代码解析成用 Object 抽象表示的 AST 语法树，再去应用各种规则分析和处理 AST，导致这个过程计算量巨大，耗时非常多。\n\n为什么不把多进程并行处理的思想也引入到代码压缩中呢？\n\nParallelUglifyPlugin 就做了这个事情。 当 Webpack 有多个 JavaScript 文件需要输出和压缩时，原本会使用 UglifyJS 去一个个挨着压缩再输出， 但是 ParallelUglifyPlugin 则会开启多个子进程，把对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行。 所以 ParallelUglifyPlugin 能更快的完成对多个文件的压缩工作。\n\n使用 ParallelUglifyPlugin 也非常简单，把原来 Webpack 配置文件中内置的 UglifyJsPlugin 去掉后，再替换成 ParallelUglifyPlugin，相关代码如下：\n\n```js\nconst path = require('path');\nconst  ParallelUglifyPlugin =  require('webpack-parallel-uglify-plugin');\nmodule.exports = { \n        plugins: [ \n            // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码\n            new ParallelUglifyPlugin({ \n                // 传递给 UglifyJS 的参数\n                uglifyJS: {\n                 }, \n            }), \n        ],\n    };\n```\n\n接入 ParallelUglifyPlugin 后，项目需要安装新的依赖：\n\n```bash\nnpm i -D webpack-parallel-uglify-plugin\n```\n\n安装成功后，重新执行构建你会发现速度变快了许多。如果设置 cacheDir 开启了缓存，在之后的构建中会变的更快。\n\n### 缩小文件搜索范围\n\nWebpack 启动后会从配置的 Entry 出发，解析出文件中的导入语句，再递归的解析。 在遇到导入语句时 Webpack 会做两件事情：\n\n1. 根据导入语句去寻找对应的要导入的文件。例如 require('react') 导入语句对应的文件是 ./node_modules/react/react.js，而require('./util')导入语句 对应的文件是 ./util.js。\n2. 根据找到的要导入文件的后缀，使用配置中的 Loader 去处理文件。例如使用 ES6 开发的 JavaScript 文件需要使用 babel-loader 去处理。\n\n以上两件事情虽然对于处理一个文件非常快，但是当项目大了以后文件量会变的非常多，这时候构建速度慢的问题就会暴露出来。 虽然以上两件事情无法避免，但需要尽量减少以上两件事情的发生，以提高速度。\n\n接下来一一介绍可以优化它们的途径。\n\n##### 缩小 resolve.modules 的范围\n\nWebpack的resolve.modules 用于配置 Webpack 去哪些目录下寻找第三方模块。\n\nresolve.modules 的默认值是 ['node_modules']，含义是先去当前目录下的 ./node_modules 目录下去找想找的模块，如果没找到就去上一级目录 ../node_modules 中找，再没有就去 ../../node_modules 中找，以此类推，这和 Node.js 的模块寻找机制很相似。\n\n当安装的第三方模块都放在项目根目录下的 ./node_modules 目录下时，没有必要按照默认的方式去一层层的寻找，可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：\n\n```js\nmodule.exports = {\n            resolve: {\n                // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤\n                // 其中 __dirname 表示当前工作目录，也就是项目根目录\n                modules: [path.resolve(__dirname, 'node_modules')]\n         },\n};\n```\n\n##### 缩小 Loader 的命中范围\n\n除此之外在使用 Loader 时可以通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件。 为了尽可能少的让文件被 Loader 处理，可以通过 include 去命中只有哪些文件需要被处理。\n\n以采用 ES6 的项目为例，在配置 babel-loader 时，可以这样：\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能\n        test: /\\.js$/,\n        // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启\n        use: ['babel-loader?cacheDirectory'],\n        // 只对项目根目录下的 src 目录中的文件采用 babel-loader\n        include: path.resolve(__dirname, 'src'),\n      },\n    ]\n  },\n};\n```\n\n你可以适当的调整项目的目录结构，以方便在配置 Loader 时通过 include 去缩小命中范围。\n\n\n\n##### 缩小 resolve.extensions 的数量\n\n在导入语句没带文件后缀时，Webpack 会自动带上后缀后去尝试询问文件是否存在。 Webpack 配置中的 resolve.extensions 用于配置在尝试过程中用到的后缀列表，默认是：\n\n```js\nextensions: ['.js', '.json']\n```\n\n也就是说当遇到 require('./data') 这样的导入语句时，Webpack 会先去寻找 ./data.js 文件，如果该文件不存在就去寻找 ./data.json 文件，如果还是找不到就报错。\n\n如果这个列表越长，或者正确的后缀在越后面，就会造成尝试的次数越多，所以 resolve.extensions 的配置也会影响到构建的性能。 在配置 resolve.extensions 时你需要遵守以下几点，以做到尽可能的优化构建性能：\n\n- 后缀尝试列表要尽可能的小，不要把项目中不可能存在的情况写到后缀尝试列表中。\n- 频率出现最高的文件后缀要优先放在最前面，以做到尽快的退出寻找过程。\n- 在源码中写导入语句时，要尽可能的带上后缀，从而可以避免寻找过程。例如在你确定的情况下把 require('./data') 写成 require('./data.json')。\n\n相关 Webpack 配置如下：\n\n```js\nmodule.exports = {\n  resolve: {\n    // 尽可能的减少后缀尝试的可能性\n    extensions: ['js'],\n  },\n};\n```\n\n##### 缩小 resolve.mainFields 的数量\n\nWebpack 配置中的 resolve.mainFields 用于配置第三方模块使用哪个入口文件。\n\n安装的第三方模块中都会有一个 package.json 文件用于描述这个模块的属性，其中有些字段用于描述入口文件在哪里，resolve.mainFields 用于配置采用哪个字段作为入口文件的描述。\n\n可以存在多个字段描述入口文件的原因是因为有些模块可以同时用在多个环境中，针对不同的运行环境需要使用不同的代码。 以 isomorphic-fetchfetch API 为例，它是 的一个实现，但可同时用于浏览器和 Node.js 环境。\n\n为了减少搜索步骤，在你明确第三方模块的入口文件描述字段时，你可以把它设置的尽量少。 由于大多数第三方模块都采用 main 字段去描述入口文件的位置，可以这样配置 Webpack：\n\n```js\nmodule.exports = {\n  resolve: {\n    // 只采用 main 字段作为入口文件描述字段，以减少搜索步骤\n    mainFields: ['main'],\n  },\n};\n```\n\n使用本方法优化时，你需要考虑到所有运行时依赖的第三方模块的入口文件描述字段，就算有一个模块搞错了都可能会造成构建出的代码无法正常运行。\n\n# 善用现存的文件\n\n### 通过 module.noParse 忽略文件\n\nWebpack 配置中的 module.noParse 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能。 原因是一些库，例如 jQuery 、ChartJS， 它们庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义。\n\n在上面的 *优化 resolve.alias 配置* 中讲到单独完整的 react.min.js 文件就没有采用模块化，让我们来通过配置 module.noParse 忽略对 react.min.js 文件的递归解析处理， 相关 Webpack 配置如下：\n\n```js\nmodule.exports = {\n  module: {\n    // 独完整的 `react.min.js` 文件就没有采用模块化，忽略对 `react.min.js` 文件的递归解析处理\n    noParse: [/react\\.min\\.js$/],\n  },\n};\n```\n\n注意被忽略掉的文件里不应该包含 import 、 require 、 define 等模块化语句，不然会导致构建出的代码中包含无法在浏览器环境下执行的模块化语句。\n\n### 通过 resolve.alias 映射文件\n\nWebpack 配置中的 resolve.alias 配置项通过别名来把原导入路径映射成一个新的导入路径。\n\n在实战项目中经常会依赖一些庞大的第三方模块，以 React 库为例，库中包含两套代码：\n\n- 一套是采用 CommonJS 规范的模块化代码，这些文件都放在 lib 目录下，以 package.json 中指定的入口文件 react.js 为模块的入口。\n- 一套是把 React 所有相关的代码打包好的完整代码放到一个单独的文件中，这些代码没有采用模块化可以直接执行。其中 dist/react.js 是用于开发环境，里面包含检查和警告的代码。dist/react.min.js 是用于线上环境，被最小化了。\n\n默认情况下 Webpack 会从入口文件 ./node_modules/react/react.js 开始递归的解析和处理依赖的几十个文件，这会时一个耗时的操作。 通过配置 resolve.alias 可以让 Webpack 在处理 React 库时，直接使用单独完整的 react.min.js 文件，从而跳过耗时的递归解析操作。\n\n相关 Webpack 配置如下：\n\n```js\nmodule.exports = {\n  resolve: {\n    // 使用 alias 把导入 react 的语句换成直接使用单独完整的 react.min.js 文件，\n    // 减少耗时的递归解析操作\n    alias: {\n      'react': path.resolve(__dirname, './node_modules/react/dist/react.min.js'),\n    }\n  },\n};\n```\n\n除了 React 库外，大多数库发布到 Npm 仓库中时都会包含打包好的完整文件，对于这些库你也可以对它们配置 alias。\n\n但是对于有些库使用本优化方法后会影响到后面要讲的使用 Tree-Shaking 去除无效代码的优化，因为打包好的完整文件中有部分代码你的项目可能永远用不上。 一般对整体性比较强的库采用本方法优化，因为完整文件中的代码是一个整体，每一行都是不可或缺的。 但是对于一些工具类的库，例如 [lodash](file:///h)，你的项目可能只用到了其中几个工具函数，你就不能使用本方法去优化，因为这会导致你的输出代码中包含很多永远不会执行的代码。\n\n# 使用 DllPlugin\n\n在介绍 DllPlugin 前先给大家介绍下 DLL。 用过 Windows 系统的人应该会经常看到以 .dll 为后缀的文件，这些文件称为**动态链接库**，在一个动态链接库中可以包含给其他模块调用的函数和数据。\n\n要给 Web 项目构建接入动态链接库的思想，需要完成以下事情：\n\n- 把网页依赖的基础模块抽离出来，打包到一个个单独的动态链接库中去。一个动态链接库中可以包含多个模块。\n- 当需要导入的模块存在于某个动态链接库中时，这个模块不能再次被打包，而是去动态链接库中获取。\n- 页面依赖的所有动态链接库需要被加载。\n\n为什么给 Web 项目构建接入动态链接库的思想后，会大大提升构建速度呢？ 原因在于包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码。 由于动态链接库中大多数包含的是常用的第三方模块，例如 react、react-dom，只要不升级这些模块的版本，动态链接库就不用重新编译。\n\n### 接入 Webpack\n\nWebpack 已经内置了对动态链接库的支持，需要通过2个内置的插件接入，它们分别是：\n\n- DllPlugin 插件：用于打包出一个个单独的动态链接库文件。\n- DllReferencePlugin 插件：用于在主要配置文件中去引入 DllPlugin 插件打包好的动态链接库文件。\n\n下面以基本的 React 项目为例，为其接入 DllPlugin，在开始前先来看下最终构建出的目录结构：\n\n```\n├── main.js\n├── polyfill.dll.js\n├── polyfill.manifest.json\n├── react.dll.js\n└── react.manifest.json\n```\n\n其中包含两个动态链接库文件，分别是：\n\n- polyfill.dll.js 里面包含项目所有依赖的 polyfill，例如 Promise、fetch 等 API。\n- react.dll.js 里面包含 React 的基础运行环境，也就是 react 和 react-dom 模块。\n\n以 react.dll.js 文件为例，其文件内容大致如下：\n\n```js\nvar _dll_react = (function(modules) {\n  // ... 此处省略 webpackBootstrap 函数代码\n}([\n  function(module, exports, __webpack_require__) {\n    // 模块 ID 为 0 的模块对应的代码\n  }\n  // ... 此处省略剩下的模块对应的代码 \n]));\n```\n\n可见一个动态链接库文件中包含了大量模块的代码，这些模块存放在一个数组里，用数组的索引号作为 ID。 并且还通过 _dll_react 变量把自己暴露在了全局中，也就是可以通过 window._dll_react 可以访问到它里面包含的模块。\n\n其中 polyfill.manifest.json 和 react.manifest.json 文件也是由 DllPlugin 生成，用于描述动态链接库文件中包含哪些模块， 以 react.manifest.json 文件为例，其文件内容大致如下：\n\n```js\n{\n  // 描述该动态链接库文件暴露在全局的变量名称\n  \"name\": \"_dll_react\",\n  \"content\": {\n    \"./node_modules/process/browser.js\": {\n      \"id\": 0,\n      \"meta\": {}\n    },\n    // ... 此处省略部分模块\n  }\n}\n```\n\n可见 manifest.json 文件清楚地描述了与其对应的 dll.js 文件中包含了哪些模块，以及每个模块的路径和 ID。\n\nmain.js 文件是编译出来的执行入口文件，当遇到其依赖的模块在 dll.js 文件中时，会直接通过 dll.js 文件暴露出的全局变量去获取打包在 dll.js 文件的模块。 所以在 index.html 文件中需要把依赖的两个 dll.js 文件给加载进去，index.html 内容如下：\n\n```html\n<!--导入依赖的动态链接库文件-->\n<script src=\"./dist/polyfill.dll.js\"></script>\n<script src=\"./dist/react.dll.js\"></script>\n<!--导入执行入口文件-->\n<script src=\"./dist/main.js\"></script>\n```\n\n以上就是所有接入 DllPlugin 后最终编译出来的代码，接下来教你如何实现。\n\n\n\n### 构建出动态链接库文件\n\n构建输出的以下这四个文件\n\n```\n├── polyfill.dll.js\n├── polyfill.manifest.json\n├── react.dll.js\n└── react.manifest.json\n```\n\n和以下这一个文件\n\n```\n├── main.js\n```\n\n是由两份不同的构建分别输出的。\n\n与动态链接库相关的文件需要由一个独立的构建输出，用于给主构建使用。新建一个 Webpack 配置文件 webpack_dll.config.js 专门用于构建它们，文件内容如下：\n\n```js\nconst path = require('path');\nconst DllPlugin = require('webpack/lib/DllPlugin');\n \nmodule.exports = {\n  // JS 执行入口文件\n  entry: {\n    // 把 React 相关模块的放到一个单独的动态链接库\n    react: ['react', 'react-dom'],\n    // 把项目需要所有的 polyfill 放到一个单独的动态链接库\n    polyfill: ['core-js/fn/object/assign', 'core-js/fn/promise', 'whatwg-fetch'],\n  },\n  output: {\n    // 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称，\n    // 也就是 entry 中配置的 react 和 polyfill\n    filename: '[name].dll.js',\n    // 输出的文件都放到 dist 目录下\n    path: path.resolve(__dirname, 'dist'),\n    // 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react\n    // 之所以在前面加上 _dll_ 是为了防止全局变量冲突\n    library: '_dll_[name]',\n  },\n  plugins: [\n    // 接入 DllPlugin\n    new DllPlugin({\n      // 动态链接库的全局变量名称，需要和 output.library 中保持一致\n      // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值\n      // 例如 react.manifest.json 中就有 \"name\": \"_dll_react\"\n      name: '_dll_[name]',\n      // 描述动态链接库的 manifest.json 文件输出时的文件名称\n      path: path.join(__dirname, 'dist', '[name].manifest.json'),\n    }),\n  ],\n};\n```\n\n### 使用动态链接库文件\n\n构建出的动态链接库文件用于在其它地方使用，在这里也就是给执行入口使用。\n\n用于输出 main.js 的主 Webpack 配置文件内容如下：\n\n```js\nconst DllReferencePlugin = require('webpack/lib/DllReferencePlugin');\n \nmodule.exports = {\n  plugins: [\n    // 告诉 Webpack 使用了哪些动态链接库\n    new DllReferencePlugin({\n      // 描述 react 动态链接库的文件内容\n      manifest: require('./dist/react.manifest.json'),\n    }),\n    new DllReferencePlugin({\n      // 描述 polyfill 动态链接库的文件内容\n      manifest: require('./dist/polyfill.manifest.json'),\n    }),\n  ],\n  devtool: 'source-map'\n};\n```\n\n> 注意：在 webpack_dll.config.js 文件中，DllPlugin 中的 name 参数必须和 output.library 中保持一致。 原因在于 DllPlugin 中的 name 参数会影响输出的 manifest.json 文件中 name 字段的值， 而在 webpack.config.js 文件中 DllReferencePlugin 会去 manifest.json 文件读取 name 字段的值， 把值的内容作为在从全局变量中获取动态链接库中内容时的全局变量名。\n\n### 执行构建\n\n在修改好以上两个 Webpack 配置文件后，需要重新执行构建。 重新执行构建时要注意的是需要先把动态链接库相关的文件编译出来，因为主 Webpack 配置文件中定义的 DllReferencePlugin 依赖这些文件。\n\n\n\n执行构建时流程如下：\n\n1. 如果动态链接库相关的文件还没有编译出来，就需要先把它们编译出来。方法是执行 webpack --config webpack_dll.config.js 命令。\n2. 在确保动态链接库存在的前提下，才能正常的编译出入口执行文件。方法是执行 webpack 命令。这时你会发现构建速度有了非常大的提升。\n\n相信给你的项目加上以上优化方法后，构建速度会大大提高，赶快去试试把！\n\n\n\n# 参考资源\n\n- [Web 开发中的利器 - Webpack](https://www.ibm.com/developerworks/cn/web/wa-lo-web-develop-edge-tool/index.html)\n- 查看[Webpack 迁移的研究](http://www.jianshu.com/p/e92ecf788c4f)，了解 Webpack 的具体配置方式","source":"_posts/加速 Webpack.md","raw":"---\ntitle: 加速 Webpack\ndate: 2018-08-11T01:25:33Z\nurl: https://github.com/gwuhaolin/blog/issues/16\ntags:\n    - webpack\n---\n\n> 本文首发于[IBM Dev社区](https://www.ibm.com/developerworks/cn/web/wa-lo-expedite-webpack/index.html)\n\nWeb 应用日益复杂，相关开发技术也百花齐放，这对前端构建工具提出了更高的要求。 Webpack 从众多构建工具中脱颖而出成为目前最流行的构建工具，几乎成为目前前端开发里的必备工具之一。 大多数人在使用 Webpack 的过程中都会遇到构建速度慢的问题，在项目大时显得尤为突出，这极大的影响了我们的开发体验，降低了我们的开发效率。\n\n本文将传授你一些加速 Webpack 构建的技巧，下面来一一介绍。\n\n\n\n# 通过多进程并行处理\n\n由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。 运行在 Node.js 之上的 Webpack 是单线程模型的，也就是说 Webpack 需要处理的任务需要一件件挨着做，不能多个事情一起做。\n\n文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？\n\n### 使用 HappyPack\n\nHappyPack 就能让 Webpack 做到上面抛出的问题，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。\n\n接入 HappyPack 的相关代码如下：\n\n```js\nconst path = require('path');\n    const  ExtractTextPlugin =  require('extract-text-webpack-plugin');\n    const  HappyPack = require('happypack');\n    module.exports = { \n        module: { \n            rules: [ \n                {    test: /\\.js$/, \n                    // 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例 \n                    use:['happypack/loader?id=babel'], \n                    // 排除 node_modules 目录下的文件，node_modules目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换 \n                    exclude: path.resolve(__dirname, 'node_modules'),\n                 }, \n                { \n                    // 把对 .css 文件的处理转交给 id 为 css 的 HappyPack 实例\n                     test: /\\.css$/, \n                     use:ExtractTextPlugin.extract({ \n                        use: ['happypack/loader?id=css'],\n             }), \n        }, \n] },\n    plugins: [ \n        new HappyPack({ \n            // 用唯一的标识符 id 来代表当前的HappyPack 是用来处理一类特定的文件 \n        id: 'babel', \n            // 如何处理 .js 文件，用法和 Loader配置中一样 \n        loaders: ['babel-loader?cacheDirectory'],\n     }),\n        new HappyPack({ \n                id: 'css', \n                    // 如何处理 .css 文件，用法和Loader 配置中一样 \n                loaders: ['css-loader'], }), \n                new ExtractTextPlugin({ \n                    filename: `[name].css`, \n            }), \n        ],\n    };\n```\n\n以上代码有两点重要的修改：\n\n- 在 Loader 配置中，所有文件的处理都交给了 happypack/loader 去处理，使用紧跟其后的 querystring ?id=babel 去告诉 happypack/loader 去选择哪个 HappyPack 实例去处理文件。\n- 在 Plugin 配置中，新增了两个 HappyPack 实例分别用于告诉 happypack/loader 去如何处理 .js 和 .css 文件。选项中的 id 属性的值和上面 querystring 中的 ?id=babel 相对应，选项中的 loaders 属性和 Loader 配置中一样。\n\n接入 HappyPack 后，你需要给项目安装新的依赖：\n\n```js\nnpm i -D happypack\n```\n\n安装成功后重新执行构建，你就会看到以下由 HappyPack 输出的日志：\n\n```\nHappy[babel]: Version: 4.0.0-beta.5. Threads: 3\nHappy[babel]: All set; signaling webpack to proceed.Happy[css]: Version: 4.0.0-beta.5. Threads: 3Happy[css]: All set; signaling webpack to proceed.\n```\n\n说明你的 HappyPack 配置生效了，并且可以得知 HappyPack 分别启动了3个子进程去并行的处理任务。\n\n在整个 Webpack 构建流程中，最耗时的流程可能就是 Loader 对文件的转换操作了，因为要转换的文件数据巨多，而且这些转换操作都只能一个个挨着处理。 HappyPack 的核心原理就是把这部分任务分解到多个进程去并行处理，从而减少了总的构建时间。\n\n从前面的使用中可以看出所有需要通过 Loader 处理的文件都先交给了 happypack/loader 去处理，收集到了这些文件的处理权后 HappyPack 就好统一分配了。\n\n每通过 new HappyPack() 实例化一个 HappyPack 其实就是告诉 HappyPack 核心调度器如何通过一系列 Loader 去转换一类文件，并且可以指定如何给这类转换操作分配子进程。\n\n核心调度器的逻辑代码在主进程中，也就是运行着 Webpack 的进程中，核心调度器会把一个个任务分配给当前空闲的子进程，子进程处理完毕后把结果发送给核心调度器，它们之间的数据交换是通过进程间通信 API 实现的。\n\n核心调度器收到来自子进程处理完毕的结果后会通知 Webpack 该文件处理完毕。\n\n### 使用 ParallelUglifyPlugin\n\n在使用 Webpack 构建出用于发布到线上的代码时，都会有压缩代码这一流程。 最常见的 JavaScript 代码压缩工具是 UglifyJS，并且 Webpack 也内置了它。\n\n用过 UglifyJS 的你一定会发现在构建用于开发环境的代码时很快就能完成，但在构建用于线上的代码时构建一直卡在一个时间点迟迟没有反应，其实卡住的这个时候就是在进行代码压缩。\n\n由于压缩 JavaScript 代码需要先把代码解析成用 Object 抽象表示的 AST 语法树，再去应用各种规则分析和处理 AST，导致这个过程计算量巨大，耗时非常多。\n\n为什么不把多进程并行处理的思想也引入到代码压缩中呢？\n\nParallelUglifyPlugin 就做了这个事情。 当 Webpack 有多个 JavaScript 文件需要输出和压缩时，原本会使用 UglifyJS 去一个个挨着压缩再输出， 但是 ParallelUglifyPlugin 则会开启多个子进程，把对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行。 所以 ParallelUglifyPlugin 能更快的完成对多个文件的压缩工作。\n\n使用 ParallelUglifyPlugin 也非常简单，把原来 Webpack 配置文件中内置的 UglifyJsPlugin 去掉后，再替换成 ParallelUglifyPlugin，相关代码如下：\n\n```js\nconst path = require('path');\nconst  ParallelUglifyPlugin =  require('webpack-parallel-uglify-plugin');\nmodule.exports = { \n        plugins: [ \n            // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码\n            new ParallelUglifyPlugin({ \n                // 传递给 UglifyJS 的参数\n                uglifyJS: {\n                 }, \n            }), \n        ],\n    };\n```\n\n接入 ParallelUglifyPlugin 后，项目需要安装新的依赖：\n\n```bash\nnpm i -D webpack-parallel-uglify-plugin\n```\n\n安装成功后，重新执行构建你会发现速度变快了许多。如果设置 cacheDir 开启了缓存，在之后的构建中会变的更快。\n\n### 缩小文件搜索范围\n\nWebpack 启动后会从配置的 Entry 出发，解析出文件中的导入语句，再递归的解析。 在遇到导入语句时 Webpack 会做两件事情：\n\n1. 根据导入语句去寻找对应的要导入的文件。例如 require('react') 导入语句对应的文件是 ./node_modules/react/react.js，而require('./util')导入语句 对应的文件是 ./util.js。\n2. 根据找到的要导入文件的后缀，使用配置中的 Loader 去处理文件。例如使用 ES6 开发的 JavaScript 文件需要使用 babel-loader 去处理。\n\n以上两件事情虽然对于处理一个文件非常快，但是当项目大了以后文件量会变的非常多，这时候构建速度慢的问题就会暴露出来。 虽然以上两件事情无法避免，但需要尽量减少以上两件事情的发生，以提高速度。\n\n接下来一一介绍可以优化它们的途径。\n\n##### 缩小 resolve.modules 的范围\n\nWebpack的resolve.modules 用于配置 Webpack 去哪些目录下寻找第三方模块。\n\nresolve.modules 的默认值是 ['node_modules']，含义是先去当前目录下的 ./node_modules 目录下去找想找的模块，如果没找到就去上一级目录 ../node_modules 中找，再没有就去 ../../node_modules 中找，以此类推，这和 Node.js 的模块寻找机制很相似。\n\n当安装的第三方模块都放在项目根目录下的 ./node_modules 目录下时，没有必要按照默认的方式去一层层的寻找，可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：\n\n```js\nmodule.exports = {\n            resolve: {\n                // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤\n                // 其中 __dirname 表示当前工作目录，也就是项目根目录\n                modules: [path.resolve(__dirname, 'node_modules')]\n         },\n};\n```\n\n##### 缩小 Loader 的命中范围\n\n除此之外在使用 Loader 时可以通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件。 为了尽可能少的让文件被 Loader 处理，可以通过 include 去命中只有哪些文件需要被处理。\n\n以采用 ES6 的项目为例，在配置 babel-loader 时，可以这样：\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能\n        test: /\\.js$/,\n        // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启\n        use: ['babel-loader?cacheDirectory'],\n        // 只对项目根目录下的 src 目录中的文件采用 babel-loader\n        include: path.resolve(__dirname, 'src'),\n      },\n    ]\n  },\n};\n```\n\n你可以适当的调整项目的目录结构，以方便在配置 Loader 时通过 include 去缩小命中范围。\n\n\n\n##### 缩小 resolve.extensions 的数量\n\n在导入语句没带文件后缀时，Webpack 会自动带上后缀后去尝试询问文件是否存在。 Webpack 配置中的 resolve.extensions 用于配置在尝试过程中用到的后缀列表，默认是：\n\n```js\nextensions: ['.js', '.json']\n```\n\n也就是说当遇到 require('./data') 这样的导入语句时，Webpack 会先去寻找 ./data.js 文件，如果该文件不存在就去寻找 ./data.json 文件，如果还是找不到就报错。\n\n如果这个列表越长，或者正确的后缀在越后面，就会造成尝试的次数越多，所以 resolve.extensions 的配置也会影响到构建的性能。 在配置 resolve.extensions 时你需要遵守以下几点，以做到尽可能的优化构建性能：\n\n- 后缀尝试列表要尽可能的小，不要把项目中不可能存在的情况写到后缀尝试列表中。\n- 频率出现最高的文件后缀要优先放在最前面，以做到尽快的退出寻找过程。\n- 在源码中写导入语句时，要尽可能的带上后缀，从而可以避免寻找过程。例如在你确定的情况下把 require('./data') 写成 require('./data.json')。\n\n相关 Webpack 配置如下：\n\n```js\nmodule.exports = {\n  resolve: {\n    // 尽可能的减少后缀尝试的可能性\n    extensions: ['js'],\n  },\n};\n```\n\n##### 缩小 resolve.mainFields 的数量\n\nWebpack 配置中的 resolve.mainFields 用于配置第三方模块使用哪个入口文件。\n\n安装的第三方模块中都会有一个 package.json 文件用于描述这个模块的属性，其中有些字段用于描述入口文件在哪里，resolve.mainFields 用于配置采用哪个字段作为入口文件的描述。\n\n可以存在多个字段描述入口文件的原因是因为有些模块可以同时用在多个环境中，针对不同的运行环境需要使用不同的代码。 以 isomorphic-fetchfetch API 为例，它是 的一个实现，但可同时用于浏览器和 Node.js 环境。\n\n为了减少搜索步骤，在你明确第三方模块的入口文件描述字段时，你可以把它设置的尽量少。 由于大多数第三方模块都采用 main 字段去描述入口文件的位置，可以这样配置 Webpack：\n\n```js\nmodule.exports = {\n  resolve: {\n    // 只采用 main 字段作为入口文件描述字段，以减少搜索步骤\n    mainFields: ['main'],\n  },\n};\n```\n\n使用本方法优化时，你需要考虑到所有运行时依赖的第三方模块的入口文件描述字段，就算有一个模块搞错了都可能会造成构建出的代码无法正常运行。\n\n# 善用现存的文件\n\n### 通过 module.noParse 忽略文件\n\nWebpack 配置中的 module.noParse 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能。 原因是一些库，例如 jQuery 、ChartJS， 它们庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义。\n\n在上面的 *优化 resolve.alias 配置* 中讲到单独完整的 react.min.js 文件就没有采用模块化，让我们来通过配置 module.noParse 忽略对 react.min.js 文件的递归解析处理， 相关 Webpack 配置如下：\n\n```js\nmodule.exports = {\n  module: {\n    // 独完整的 `react.min.js` 文件就没有采用模块化，忽略对 `react.min.js` 文件的递归解析处理\n    noParse: [/react\\.min\\.js$/],\n  },\n};\n```\n\n注意被忽略掉的文件里不应该包含 import 、 require 、 define 等模块化语句，不然会导致构建出的代码中包含无法在浏览器环境下执行的模块化语句。\n\n### 通过 resolve.alias 映射文件\n\nWebpack 配置中的 resolve.alias 配置项通过别名来把原导入路径映射成一个新的导入路径。\n\n在实战项目中经常会依赖一些庞大的第三方模块，以 React 库为例，库中包含两套代码：\n\n- 一套是采用 CommonJS 规范的模块化代码，这些文件都放在 lib 目录下，以 package.json 中指定的入口文件 react.js 为模块的入口。\n- 一套是把 React 所有相关的代码打包好的完整代码放到一个单独的文件中，这些代码没有采用模块化可以直接执行。其中 dist/react.js 是用于开发环境，里面包含检查和警告的代码。dist/react.min.js 是用于线上环境，被最小化了。\n\n默认情况下 Webpack 会从入口文件 ./node_modules/react/react.js 开始递归的解析和处理依赖的几十个文件，这会时一个耗时的操作。 通过配置 resolve.alias 可以让 Webpack 在处理 React 库时，直接使用单独完整的 react.min.js 文件，从而跳过耗时的递归解析操作。\n\n相关 Webpack 配置如下：\n\n```js\nmodule.exports = {\n  resolve: {\n    // 使用 alias 把导入 react 的语句换成直接使用单独完整的 react.min.js 文件，\n    // 减少耗时的递归解析操作\n    alias: {\n      'react': path.resolve(__dirname, './node_modules/react/dist/react.min.js'),\n    }\n  },\n};\n```\n\n除了 React 库外，大多数库发布到 Npm 仓库中时都会包含打包好的完整文件，对于这些库你也可以对它们配置 alias。\n\n但是对于有些库使用本优化方法后会影响到后面要讲的使用 Tree-Shaking 去除无效代码的优化，因为打包好的完整文件中有部分代码你的项目可能永远用不上。 一般对整体性比较强的库采用本方法优化，因为完整文件中的代码是一个整体，每一行都是不可或缺的。 但是对于一些工具类的库，例如 [lodash](file:///h)，你的项目可能只用到了其中几个工具函数，你就不能使用本方法去优化，因为这会导致你的输出代码中包含很多永远不会执行的代码。\n\n# 使用 DllPlugin\n\n在介绍 DllPlugin 前先给大家介绍下 DLL。 用过 Windows 系统的人应该会经常看到以 .dll 为后缀的文件，这些文件称为**动态链接库**，在一个动态链接库中可以包含给其他模块调用的函数和数据。\n\n要给 Web 项目构建接入动态链接库的思想，需要完成以下事情：\n\n- 把网页依赖的基础模块抽离出来，打包到一个个单独的动态链接库中去。一个动态链接库中可以包含多个模块。\n- 当需要导入的模块存在于某个动态链接库中时，这个模块不能再次被打包，而是去动态链接库中获取。\n- 页面依赖的所有动态链接库需要被加载。\n\n为什么给 Web 项目构建接入动态链接库的思想后，会大大提升构建速度呢？ 原因在于包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码。 由于动态链接库中大多数包含的是常用的第三方模块，例如 react、react-dom，只要不升级这些模块的版本，动态链接库就不用重新编译。\n\n### 接入 Webpack\n\nWebpack 已经内置了对动态链接库的支持，需要通过2个内置的插件接入，它们分别是：\n\n- DllPlugin 插件：用于打包出一个个单独的动态链接库文件。\n- DllReferencePlugin 插件：用于在主要配置文件中去引入 DllPlugin 插件打包好的动态链接库文件。\n\n下面以基本的 React 项目为例，为其接入 DllPlugin，在开始前先来看下最终构建出的目录结构：\n\n```\n├── main.js\n├── polyfill.dll.js\n├── polyfill.manifest.json\n├── react.dll.js\n└── react.manifest.json\n```\n\n其中包含两个动态链接库文件，分别是：\n\n- polyfill.dll.js 里面包含项目所有依赖的 polyfill，例如 Promise、fetch 等 API。\n- react.dll.js 里面包含 React 的基础运行环境，也就是 react 和 react-dom 模块。\n\n以 react.dll.js 文件为例，其文件内容大致如下：\n\n```js\nvar _dll_react = (function(modules) {\n  // ... 此处省略 webpackBootstrap 函数代码\n}([\n  function(module, exports, __webpack_require__) {\n    // 模块 ID 为 0 的模块对应的代码\n  }\n  // ... 此处省略剩下的模块对应的代码 \n]));\n```\n\n可见一个动态链接库文件中包含了大量模块的代码，这些模块存放在一个数组里，用数组的索引号作为 ID。 并且还通过 _dll_react 变量把自己暴露在了全局中，也就是可以通过 window._dll_react 可以访问到它里面包含的模块。\n\n其中 polyfill.manifest.json 和 react.manifest.json 文件也是由 DllPlugin 生成，用于描述动态链接库文件中包含哪些模块， 以 react.manifest.json 文件为例，其文件内容大致如下：\n\n```js\n{\n  // 描述该动态链接库文件暴露在全局的变量名称\n  \"name\": \"_dll_react\",\n  \"content\": {\n    \"./node_modules/process/browser.js\": {\n      \"id\": 0,\n      \"meta\": {}\n    },\n    // ... 此处省略部分模块\n  }\n}\n```\n\n可见 manifest.json 文件清楚地描述了与其对应的 dll.js 文件中包含了哪些模块，以及每个模块的路径和 ID。\n\nmain.js 文件是编译出来的执行入口文件，当遇到其依赖的模块在 dll.js 文件中时，会直接通过 dll.js 文件暴露出的全局变量去获取打包在 dll.js 文件的模块。 所以在 index.html 文件中需要把依赖的两个 dll.js 文件给加载进去，index.html 内容如下：\n\n```html\n<!--导入依赖的动态链接库文件-->\n<script src=\"./dist/polyfill.dll.js\"></script>\n<script src=\"./dist/react.dll.js\"></script>\n<!--导入执行入口文件-->\n<script src=\"./dist/main.js\"></script>\n```\n\n以上就是所有接入 DllPlugin 后最终编译出来的代码，接下来教你如何实现。\n\n\n\n### 构建出动态链接库文件\n\n构建输出的以下这四个文件\n\n```\n├── polyfill.dll.js\n├── polyfill.manifest.json\n├── react.dll.js\n└── react.manifest.json\n```\n\n和以下这一个文件\n\n```\n├── main.js\n```\n\n是由两份不同的构建分别输出的。\n\n与动态链接库相关的文件需要由一个独立的构建输出，用于给主构建使用。新建一个 Webpack 配置文件 webpack_dll.config.js 专门用于构建它们，文件内容如下：\n\n```js\nconst path = require('path');\nconst DllPlugin = require('webpack/lib/DllPlugin');\n \nmodule.exports = {\n  // JS 执行入口文件\n  entry: {\n    // 把 React 相关模块的放到一个单独的动态链接库\n    react: ['react', 'react-dom'],\n    // 把项目需要所有的 polyfill 放到一个单独的动态链接库\n    polyfill: ['core-js/fn/object/assign', 'core-js/fn/promise', 'whatwg-fetch'],\n  },\n  output: {\n    // 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称，\n    // 也就是 entry 中配置的 react 和 polyfill\n    filename: '[name].dll.js',\n    // 输出的文件都放到 dist 目录下\n    path: path.resolve(__dirname, 'dist'),\n    // 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react\n    // 之所以在前面加上 _dll_ 是为了防止全局变量冲突\n    library: '_dll_[name]',\n  },\n  plugins: [\n    // 接入 DllPlugin\n    new DllPlugin({\n      // 动态链接库的全局变量名称，需要和 output.library 中保持一致\n      // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值\n      // 例如 react.manifest.json 中就有 \"name\": \"_dll_react\"\n      name: '_dll_[name]',\n      // 描述动态链接库的 manifest.json 文件输出时的文件名称\n      path: path.join(__dirname, 'dist', '[name].manifest.json'),\n    }),\n  ],\n};\n```\n\n### 使用动态链接库文件\n\n构建出的动态链接库文件用于在其它地方使用，在这里也就是给执行入口使用。\n\n用于输出 main.js 的主 Webpack 配置文件内容如下：\n\n```js\nconst DllReferencePlugin = require('webpack/lib/DllReferencePlugin');\n \nmodule.exports = {\n  plugins: [\n    // 告诉 Webpack 使用了哪些动态链接库\n    new DllReferencePlugin({\n      // 描述 react 动态链接库的文件内容\n      manifest: require('./dist/react.manifest.json'),\n    }),\n    new DllReferencePlugin({\n      // 描述 polyfill 动态链接库的文件内容\n      manifest: require('./dist/polyfill.manifest.json'),\n    }),\n  ],\n  devtool: 'source-map'\n};\n```\n\n> 注意：在 webpack_dll.config.js 文件中，DllPlugin 中的 name 参数必须和 output.library 中保持一致。 原因在于 DllPlugin 中的 name 参数会影响输出的 manifest.json 文件中 name 字段的值， 而在 webpack.config.js 文件中 DllReferencePlugin 会去 manifest.json 文件读取 name 字段的值， 把值的内容作为在从全局变量中获取动态链接库中内容时的全局变量名。\n\n### 执行构建\n\n在修改好以上两个 Webpack 配置文件后，需要重新执行构建。 重新执行构建时要注意的是需要先把动态链接库相关的文件编译出来，因为主 Webpack 配置文件中定义的 DllReferencePlugin 依赖这些文件。\n\n\n\n执行构建时流程如下：\n\n1. 如果动态链接库相关的文件还没有编译出来，就需要先把它们编译出来。方法是执行 webpack --config webpack_dll.config.js 命令。\n2. 在确保动态链接库存在的前提下，才能正常的编译出入口执行文件。方法是执行 webpack 命令。这时你会发现构建速度有了非常大的提升。\n\n相信给你的项目加上以上优化方法后，构建速度会大大提高，赶快去试试把！\n\n\n\n# 参考资源\n\n- [Web 开发中的利器 - Webpack](https://www.ibm.com/developerworks/cn/web/wa-lo-web-develop-edge-tool/index.html)\n- 查看[Webpack 迁移的研究](http://www.jianshu.com/p/e92ecf788c4f)，了解 Webpack 的具体配置方式","slug":"加速 Webpack","published":1,"updated":"2018-11-14T04:39:28.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjogs0kef000kg5tcbmx27w58","content":"<blockquote>\n<p>本文首发于<a href=\"https://www.ibm.com/developerworks/cn/web/wa-lo-expedite-webpack/index.html\" target=\"_blank\" rel=\"noopener\">IBM Dev社区</a></p>\n</blockquote>\n<p>Web 应用日益复杂，相关开发技术也百花齐放，这对前端构建工具提出了更高的要求。 Webpack 从众多构建工具中脱颖而出成为目前最流行的构建工具，几乎成为目前前端开发里的必备工具之一。 大多数人在使用 Webpack 的过程中都会遇到构建速度慢的问题，在项目大时显得尤为突出，这极大的影响了我们的开发体验，降低了我们的开发效率。</p>\n<p>本文将传授你一些加速 Webpack 构建的技巧，下面来一一介绍。</p>\n<h1 id=\"通过多进程并行处理\"><a href=\"#通过多进程并行处理\" class=\"headerlink\" title=\"通过多进程并行处理\"></a>通过多进程并行处理</h1><p>由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。 运行在 Node.js 之上的 Webpack 是单线程模型的，也就是说 Webpack 需要处理的任务需要一件件挨着做，不能多个事情一起做。</p>\n<p>文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？</p>\n<h3 id=\"使用-HappyPack\"><a href=\"#使用-HappyPack\" class=\"headerlink\" title=\"使用 HappyPack\"></a>使用 HappyPack</h3><p>HappyPack 就能让 Webpack 做到上面抛出的问题，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。</p>\n<p>接入 HappyPack 的相关代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span>  ExtractTextPlugin =  <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span>  HappyPack = <span class=\"built_in\">require</span>(<span class=\"string\">'happypack'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = &#123; </span><br><span class=\"line\">        <span class=\"built_in\">module</span>: &#123; </span><br><span class=\"line\">            rules: [ </span><br><span class=\"line\">                &#123;    <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>, </span><br><span class=\"line\">                    <span class=\"comment\">// 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例 </span></span><br><span class=\"line\">                    use:[<span class=\"string\">'happypack/loader?id=babel'</span>], </span><br><span class=\"line\">                    <span class=\"comment\">// 排除 node_modules 目录下的文件，node_modules目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换 </span></span><br><span class=\"line\">                    exclude: path.resolve(__dirname, <span class=\"string\">'node_modules'</span>),</span><br><span class=\"line\">                 &#125;, </span><br><span class=\"line\">                &#123; </span><br><span class=\"line\">                    <span class=\"comment\">// 把对 .css 文件的处理转交给 id 为 css 的 HappyPack 实例</span></span><br><span class=\"line\">                     test: <span class=\"regexp\">/\\.css$/</span>, </span><br><span class=\"line\">                     use:ExtractTextPlugin.extract(&#123; </span><br><span class=\"line\">                        use: [<span class=\"string\">'happypack/loader?id=css'</span>],</span><br><span class=\"line\">             &#125;), </span><br><span class=\"line\">        &#125;, </span><br><span class=\"line\">] &#125;,</span><br><span class=\"line\">    plugins: [ </span><br><span class=\"line\">        <span class=\"keyword\">new</span> HappyPack(&#123; </span><br><span class=\"line\">            <span class=\"comment\">// 用唯一的标识符 id 来代表当前的HappyPack 是用来处理一类特定的文件 </span></span><br><span class=\"line\">        id: <span class=\"string\">'babel'</span>, </span><br><span class=\"line\">            <span class=\"comment\">// 如何处理 .js 文件，用法和 Loader配置中一样 </span></span><br><span class=\"line\">        loaders: [<span class=\"string\">'babel-loader?cacheDirectory'</span>],</span><br><span class=\"line\">     &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> HappyPack(&#123; </span><br><span class=\"line\">                id: <span class=\"string\">'css'</span>, </span><br><span class=\"line\">                    <span class=\"comment\">// 如何处理 .css 文件，用法和Loader 配置中一样 </span></span><br><span class=\"line\">                loaders: [<span class=\"string\">'css-loader'</span>], &#125;), </span><br><span class=\"line\">                <span class=\"keyword\">new</span> ExtractTextPlugin(&#123; </span><br><span class=\"line\">                    filename: <span class=\"string\">`[name].css`</span>, </span><br><span class=\"line\">            &#125;), </span><br><span class=\"line\">        ],</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>以上代码有两点重要的修改：</p>\n<ul>\n<li>在 Loader 配置中，所有文件的处理都交给了 happypack/loader 去处理，使用紧跟其后的 querystring ?id=babel 去告诉 happypack/loader 去选择哪个 HappyPack 实例去处理文件。</li>\n<li>在 Plugin 配置中，新增了两个 HappyPack 实例分别用于告诉 happypack/loader 去如何处理 .js 和 .css 文件。选项中的 id 属性的值和上面 querystring 中的 ?id=babel 相对应，选项中的 loaders 属性和 Loader 配置中一样。</li>\n</ul>\n<p>接入 HappyPack 后，你需要给项目安装新的依赖：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -D happypack</span><br></pre></td></tr></table></figure>\n<p>安装成功后重新执行构建，你就会看到以下由 HappyPack 输出的日志：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Happy[babel]: Version: 4.0.0-beta.5. Threads: 3</span><br><span class=\"line\">Happy[babel]: All set; signaling webpack to proceed.Happy[css]: Version: 4.0.0-beta.5. Threads: 3Happy[css]: All set; signaling webpack to proceed.</span><br></pre></td></tr></table></figure>\n<p>说明你的 HappyPack 配置生效了，并且可以得知 HappyPack 分别启动了3个子进程去并行的处理任务。</p>\n<p>在整个 Webpack 构建流程中，最耗时的流程可能就是 Loader 对文件的转换操作了，因为要转换的文件数据巨多，而且这些转换操作都只能一个个挨着处理。 HappyPack 的核心原理就是把这部分任务分解到多个进程去并行处理，从而减少了总的构建时间。</p>\n<p>从前面的使用中可以看出所有需要通过 Loader 处理的文件都先交给了 happypack/loader 去处理，收集到了这些文件的处理权后 HappyPack 就好统一分配了。</p>\n<p>每通过 new HappyPack() 实例化一个 HappyPack 其实就是告诉 HappyPack 核心调度器如何通过一系列 Loader 去转换一类文件，并且可以指定如何给这类转换操作分配子进程。</p>\n<p>核心调度器的逻辑代码在主进程中，也就是运行着 Webpack 的进程中，核心调度器会把一个个任务分配给当前空闲的子进程，子进程处理完毕后把结果发送给核心调度器，它们之间的数据交换是通过进程间通信 API 实现的。</p>\n<p>核心调度器收到来自子进程处理完毕的结果后会通知 Webpack 该文件处理完毕。</p>\n<h3 id=\"使用-ParallelUglifyPlugin\"><a href=\"#使用-ParallelUglifyPlugin\" class=\"headerlink\" title=\"使用 ParallelUglifyPlugin\"></a>使用 ParallelUglifyPlugin</h3><p>在使用 Webpack 构建出用于发布到线上的代码时，都会有压缩代码这一流程。 最常见的 JavaScript 代码压缩工具是 UglifyJS，并且 Webpack 也内置了它。</p>\n<p>用过 UglifyJS 的你一定会发现在构建用于开发环境的代码时很快就能完成，但在构建用于线上的代码时构建一直卡在一个时间点迟迟没有反应，其实卡住的这个时候就是在进行代码压缩。</p>\n<p>由于压缩 JavaScript 代码需要先把代码解析成用 Object 抽象表示的 AST 语法树，再去应用各种规则分析和处理 AST，导致这个过程计算量巨大，耗时非常多。</p>\n<p>为什么不把多进程并行处理的思想也引入到代码压缩中呢？</p>\n<p>ParallelUglifyPlugin 就做了这个事情。 当 Webpack 有多个 JavaScript 文件需要输出和压缩时，原本会使用 UglifyJS 去一个个挨着压缩再输出， 但是 ParallelUglifyPlugin 则会开启多个子进程，把对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行。 所以 ParallelUglifyPlugin 能更快的完成对多个文件的压缩工作。</p>\n<p>使用 ParallelUglifyPlugin 也非常简单，把原来 Webpack 配置文件中内置的 UglifyJsPlugin 去掉后，再替换成 ParallelUglifyPlugin，相关代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span>  ParallelUglifyPlugin =  <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-parallel-uglify-plugin'</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123; </span><br><span class=\"line\">        plugins: [ </span><br><span class=\"line\">            <span class=\"comment\">// 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> ParallelUglifyPlugin(&#123; </span><br><span class=\"line\">                <span class=\"comment\">// 传递给 UglifyJS 的参数</span></span><br><span class=\"line\">                uglifyJS: &#123;</span><br><span class=\"line\">                 &#125;, </span><br><span class=\"line\">            &#125;), </span><br><span class=\"line\">        ],</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>接入 ParallelUglifyPlugin 后，项目需要安装新的依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -D webpack-parallel-uglify-plugin</span><br></pre></td></tr></table></figure>\n<p>安装成功后，重新执行构建你会发现速度变快了许多。如果设置 cacheDir 开启了缓存，在之后的构建中会变的更快。</p>\n<h3 id=\"缩小文件搜索范围\"><a href=\"#缩小文件搜索范围\" class=\"headerlink\" title=\"缩小文件搜索范围\"></a>缩小文件搜索范围</h3><p>Webpack 启动后会从配置的 Entry 出发，解析出文件中的导入语句，再递归的解析。 在遇到导入语句时 Webpack 会做两件事情：</p>\n<ol>\n<li>根据导入语句去寻找对应的要导入的文件。例如 require(‘react’) 导入语句对应的文件是 ./node_modules/react/react.js，而require(‘./util’)导入语句 对应的文件是 ./util.js。</li>\n<li>根据找到的要导入文件的后缀，使用配置中的 Loader 去处理文件。例如使用 ES6 开发的 JavaScript 文件需要使用 babel-loader 去处理。</li>\n</ol>\n<p>以上两件事情虽然对于处理一个文件非常快，但是当项目大了以后文件量会变的非常多，这时候构建速度慢的问题就会暴露出来。 虽然以上两件事情无法避免，但需要尽量减少以上两件事情的发生，以提高速度。</p>\n<p>接下来一一介绍可以优化它们的途径。</p>\n<h5 id=\"缩小-resolve-modules-的范围\"><a href=\"#缩小-resolve-modules-的范围\" class=\"headerlink\" title=\"缩小 resolve.modules 的范围\"></a>缩小 resolve.modules 的范围</h5><p>Webpack的resolve.modules 用于配置 Webpack 去哪些目录下寻找第三方模块。</p>\n<p>resolve.modules 的默认值是 [‘node_modules’]，含义是先去当前目录下的 ./node_modules 目录下去找想找的模块，如果没找到就去上一级目录 ../node_modules 中找，再没有就去 ../../node_modules 中找，以此类推，这和 Node.js 的模块寻找机制很相似。</p>\n<p>当安装的第三方模块都放在项目根目录下的 ./node_modules 目录下时，没有必要按照默认的方式去一层层的寻找，可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">            resolve: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</span></span><br><span class=\"line\">                <span class=\"comment\">// 其中 __dirname 表示当前工作目录，也就是项目根目录</span></span><br><span class=\"line\">                modules: [path.resolve(__dirname, <span class=\"string\">'node_modules'</span>)]</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"缩小-Loader-的命中范围\"><a href=\"#缩小-Loader-的命中范围\" class=\"headerlink\" title=\"缩小 Loader 的命中范围\"></a>缩小 Loader 的命中范围</h5><p>除此之外在使用 Loader 时可以通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件。 为了尽可能少的让文件被 Loader 处理，可以通过 include 去命中只有哪些文件需要被处理。</p>\n<p>以采用 ES6 的项目为例，在配置 babel-loader 时，可以这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能</span></span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启</span></span><br><span class=\"line\">        use: [<span class=\"string\">'babel-loader?cacheDirectory'</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 只对项目根目录下的 src 目录中的文件采用 babel-loader</span></span><br><span class=\"line\">        include: path.resolve(__dirname, <span class=\"string\">'src'</span>),</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>你可以适当的调整项目的目录结构，以方便在配置 Loader 时通过 include 去缩小命中范围。</p>\n<h5 id=\"缩小-resolve-extensions-的数量\"><a href=\"#缩小-resolve-extensions-的数量\" class=\"headerlink\" title=\"缩小 resolve.extensions 的数量\"></a>缩小 resolve.extensions 的数量</h5><p>在导入语句没带文件后缀时，Webpack 会自动带上后缀后去尝试询问文件是否存在。 Webpack 配置中的 resolve.extensions 用于配置在尝试过程中用到的后缀列表，默认是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extensions: [<span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>]</span><br></pre></td></tr></table></figure>\n<p>也就是说当遇到 require(‘./data’) 这样的导入语句时，Webpack 会先去寻找 ./data.js 文件，如果该文件不存在就去寻找 ./data.json 文件，如果还是找不到就报错。</p>\n<p>如果这个列表越长，或者正确的后缀在越后面，就会造成尝试的次数越多，所以 resolve.extensions 的配置也会影响到构建的性能。 在配置 resolve.extensions 时你需要遵守以下几点，以做到尽可能的优化构建性能：</p>\n<ul>\n<li>后缀尝试列表要尽可能的小，不要把项目中不可能存在的情况写到后缀尝试列表中。</li>\n<li>频率出现最高的文件后缀要优先放在最前面，以做到尽快的退出寻找过程。</li>\n<li>在源码中写导入语句时，要尽可能的带上后缀，从而可以避免寻找过程。例如在你确定的情况下把 require(‘./data’) 写成 require(‘./data.json’)。</li>\n</ul>\n<p>相关 Webpack 配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 尽可能的减少后缀尝试的可能性</span></span><br><span class=\"line\">    extensions: [<span class=\"string\">'js'</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"缩小-resolve-mainFields-的数量\"><a href=\"#缩小-resolve-mainFields-的数量\" class=\"headerlink\" title=\"缩小 resolve.mainFields 的数量\"></a>缩小 resolve.mainFields 的数量</h5><p>Webpack 配置中的 resolve.mainFields 用于配置第三方模块使用哪个入口文件。</p>\n<p>安装的第三方模块中都会有一个 package.json 文件用于描述这个模块的属性，其中有些字段用于描述入口文件在哪里，resolve.mainFields 用于配置采用哪个字段作为入口文件的描述。</p>\n<p>可以存在多个字段描述入口文件的原因是因为有些模块可以同时用在多个环境中，针对不同的运行环境需要使用不同的代码。 以 isomorphic-fetchfetch API 为例，它是 的一个实现，但可同时用于浏览器和 Node.js 环境。</p>\n<p>为了减少搜索步骤，在你明确第三方模块的入口文件描述字段时，你可以把它设置的尽量少。 由于大多数第三方模块都采用 main 字段去描述入口文件的位置，可以这样配置 Webpack：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 只采用 main 字段作为入口文件描述字段，以减少搜索步骤</span></span><br><span class=\"line\">    mainFields: [<span class=\"string\">'main'</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>使用本方法优化时，你需要考虑到所有运行时依赖的第三方模块的入口文件描述字段，就算有一个模块搞错了都可能会造成构建出的代码无法正常运行。</p>\n<h1 id=\"善用现存的文件\"><a href=\"#善用现存的文件\" class=\"headerlink\" title=\"善用现存的文件\"></a>善用现存的文件</h1><h3 id=\"通过-module-noParse-忽略文件\"><a href=\"#通过-module-noParse-忽略文件\" class=\"headerlink\" title=\"通过 module.noParse 忽略文件\"></a>通过 module.noParse 忽略文件</h3><p>Webpack 配置中的 module.noParse 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能。 原因是一些库，例如 jQuery 、ChartJS， 它们庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义。</p>\n<p>在上面的 <em>优化 resolve.alias 配置</em> 中讲到单独完整的 react.min.js 文件就没有采用模块化，让我们来通过配置 module.noParse 忽略对 react.min.js 文件的递归解析处理， 相关 Webpack 配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 独完整的 `react.min.js` 文件就没有采用模块化，忽略对 `react.min.js` 文件的递归解析处理</span></span><br><span class=\"line\">    noParse: [<span class=\"regexp\">/react\\.min\\.js$/</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意被忽略掉的文件里不应该包含 import 、 require 、 define 等模块化语句，不然会导致构建出的代码中包含无法在浏览器环境下执行的模块化语句。</p>\n<h3 id=\"通过-resolve-alias-映射文件\"><a href=\"#通过-resolve-alias-映射文件\" class=\"headerlink\" title=\"通过 resolve.alias 映射文件\"></a>通过 resolve.alias 映射文件</h3><p>Webpack 配置中的 resolve.alias 配置项通过别名来把原导入路径映射成一个新的导入路径。</p>\n<p>在实战项目中经常会依赖一些庞大的第三方模块，以 React 库为例，库中包含两套代码：</p>\n<ul>\n<li>一套是采用 CommonJS 规范的模块化代码，这些文件都放在 lib 目录下，以 package.json 中指定的入口文件 react.js 为模块的入口。</li>\n<li>一套是把 React 所有相关的代码打包好的完整代码放到一个单独的文件中，这些代码没有采用模块化可以直接执行。其中 dist/react.js 是用于开发环境，里面包含检查和警告的代码。dist/react.min.js 是用于线上环境，被最小化了。</li>\n</ul>\n<p>默认情况下 Webpack 会从入口文件 ./node_modules/react/react.js 开始递归的解析和处理依赖的几十个文件，这会时一个耗时的操作。 通过配置 resolve.alias 可以让 Webpack 在处理 React 库时，直接使用单独完整的 react.min.js 文件，从而跳过耗时的递归解析操作。</p>\n<p>相关 Webpack 配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 alias 把导入 react 的语句换成直接使用单独完整的 react.min.js 文件，</span></span><br><span class=\"line\">    <span class=\"comment\">// 减少耗时的递归解析操作</span></span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      <span class=\"string\">'react'</span>: path.resolve(__dirname, <span class=\"string\">'./node_modules/react/dist/react.min.js'</span>),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>除了 React 库外，大多数库发布到 Npm 仓库中时都会包含打包好的完整文件，对于这些库你也可以对它们配置 alias。</p>\n<p>但是对于有些库使用本优化方法后会影响到后面要讲的使用 Tree-Shaking 去除无效代码的优化，因为打包好的完整文件中有部分代码你的项目可能永远用不上。 一般对整体性比较强的库采用本方法优化，因为完整文件中的代码是一个整体，每一行都是不可或缺的。 但是对于一些工具类的库，例如 <a href=\"file:///h\" target=\"_blank\" rel=\"noopener\">lodash</a>，你的项目可能只用到了其中几个工具函数，你就不能使用本方法去优化，因为这会导致你的输出代码中包含很多永远不会执行的代码。</p>\n<h1 id=\"使用-DllPlugin\"><a href=\"#使用-DllPlugin\" class=\"headerlink\" title=\"使用 DllPlugin\"></a>使用 DllPlugin</h1><p>在介绍 DllPlugin 前先给大家介绍下 DLL。 用过 Windows 系统的人应该会经常看到以 .dll 为后缀的文件，这些文件称为<strong>动态链接库</strong>，在一个动态链接库中可以包含给其他模块调用的函数和数据。</p>\n<p>要给 Web 项目构建接入动态链接库的思想，需要完成以下事情：</p>\n<ul>\n<li>把网页依赖的基础模块抽离出来，打包到一个个单独的动态链接库中去。一个动态链接库中可以包含多个模块。</li>\n<li>当需要导入的模块存在于某个动态链接库中时，这个模块不能再次被打包，而是去动态链接库中获取。</li>\n<li>页面依赖的所有动态链接库需要被加载。</li>\n</ul>\n<p>为什么给 Web 项目构建接入动态链接库的思想后，会大大提升构建速度呢？ 原因在于包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码。 由于动态链接库中大多数包含的是常用的第三方模块，例如 react、react-dom，只要不升级这些模块的版本，动态链接库就不用重新编译。</p>\n<h3 id=\"接入-Webpack\"><a href=\"#接入-Webpack\" class=\"headerlink\" title=\"接入 Webpack\"></a>接入 Webpack</h3><p>Webpack 已经内置了对动态链接库的支持，需要通过2个内置的插件接入，它们分别是：</p>\n<ul>\n<li>DllPlugin 插件：用于打包出一个个单独的动态链接库文件。</li>\n<li>DllReferencePlugin 插件：用于在主要配置文件中去引入 DllPlugin 插件打包好的动态链接库文件。</li>\n</ul>\n<p>下面以基本的 React 项目为例，为其接入 DllPlugin，在开始前先来看下最终构建出的目录结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── main.js</span><br><span class=\"line\">├── polyfill.dll.js</span><br><span class=\"line\">├── polyfill.manifest.json</span><br><span class=\"line\">├── react.dll.js</span><br><span class=\"line\">└── react.manifest.json</span><br></pre></td></tr></table></figure>\n<p>其中包含两个动态链接库文件，分别是：</p>\n<ul>\n<li>polyfill.dll.js 里面包含项目所有依赖的 polyfill，例如 Promise、fetch 等 API。</li>\n<li>react.dll.js 里面包含 React 的基础运行环境，也就是 react 和 react-dom 模块。</li>\n</ul>\n<p>以 react.dll.js 文件为例，其文件内容大致如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _dll_react = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 此处省略 webpackBootstrap 函数代码</span></span><br><span class=\"line\">&#125;([</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 模块 ID 为 0 的模块对应的代码</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ... 此处省略剩下的模块对应的代码 </span></span><br><span class=\"line\">]));</span><br></pre></td></tr></table></figure>\n<p>可见一个动态链接库文件中包含了大量模块的代码，这些模块存放在一个数组里，用数组的索引号作为 ID。 并且还通过 _dll_react 变量把自己暴露在了全局中，也就是可以通过 window._dll_react 可以访问到它里面包含的模块。</p>\n<p>其中 polyfill.manifest.json 和 react.manifest.json 文件也是由 DllPlugin 生成，用于描述动态链接库文件中包含哪些模块， 以 react.manifest.json 文件为例，其文件内容大致如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 描述该动态链接库文件暴露在全局的变量名称</span></span><br><span class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"_dll_react\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"content\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/process/browser.js\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"id\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"string\">\"meta\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// ... 此处省略部分模块</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可见 manifest.json 文件清楚地描述了与其对应的 dll.js 文件中包含了哪些模块，以及每个模块的路径和 ID。</p>\n<p>main.js 文件是编译出来的执行入口文件，当遇到其依赖的模块在 dll.js 文件中时，会直接通过 dll.js 文件暴露出的全局变量去获取打包在 dll.js 文件的模块。 所以在 index.html 文件中需要把依赖的两个 dll.js 文件给加载进去，index.html 内容如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--导入依赖的动态链接库文件--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./dist/polyfill.dll.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./dist/react.dll.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--导入执行入口文件--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./dist/main.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>以上就是所有接入 DllPlugin 后最终编译出来的代码，接下来教你如何实现。</p>\n<h3 id=\"构建出动态链接库文件\"><a href=\"#构建出动态链接库文件\" class=\"headerlink\" title=\"构建出动态链接库文件\"></a>构建出动态链接库文件</h3><p>构建输出的以下这四个文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── polyfill.dll.js</span><br><span class=\"line\">├── polyfill.manifest.json</span><br><span class=\"line\">├── react.dll.js</span><br><span class=\"line\">└── react.manifest.json</span><br></pre></td></tr></table></figure>\n<p>和以下这一个文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── main.js</span><br></pre></td></tr></table></figure>\n<p>是由两份不同的构建分别输出的。</p>\n<p>与动态链接库相关的文件需要由一个独立的构建输出，用于给主构建使用。新建一个 Webpack 配置文件 webpack_dll.config.js 专门用于构建它们，文件内容如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> DllPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/DllPlugin'</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// JS 执行入口文件</span></span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把 React 相关模块的放到一个单独的动态链接库</span></span><br><span class=\"line\">    react: [<span class=\"string\">'react'</span>, <span class=\"string\">'react-dom'</span>],</span><br><span class=\"line\">    <span class=\"comment\">// 把项目需要所有的 polyfill 放到一个单独的动态链接库</span></span><br><span class=\"line\">    polyfill: [<span class=\"string\">'core-js/fn/object/assign'</span>, <span class=\"string\">'core-js/fn/promise'</span>, <span class=\"string\">'whatwg-fetch'</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称，</span></span><br><span class=\"line\">    <span class=\"comment\">// 也就是 entry 中配置的 react 和 polyfill</span></span><br><span class=\"line\">    filename: <span class=\"string\">'[name].dll.js'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 输出的文件都放到 dist 目录下</span></span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    <span class=\"comment\">// 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react</span></span><br><span class=\"line\">    <span class=\"comment\">// 之所以在前面加上 _dll_ 是为了防止全局变量冲突</span></span><br><span class=\"line\">    library: <span class=\"string\">'_dll_[name]'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// 接入 DllPlugin</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> DllPlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 动态链接库的全局变量名称，需要和 output.library 中保持一致</span></span><br><span class=\"line\">      <span class=\"comment\">// 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值</span></span><br><span class=\"line\">      <span class=\"comment\">// 例如 react.manifest.json 中就有 \"name\": \"_dll_react\"</span></span><br><span class=\"line\">      name: <span class=\"string\">'_dll_[name]'</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 描述动态链接库的 manifest.json 文件输出时的文件名称</span></span><br><span class=\"line\">      path: path.join(__dirname, <span class=\"string\">'dist'</span>, <span class=\"string\">'[name].manifest.json'</span>),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用动态链接库文件\"><a href=\"#使用动态链接库文件\" class=\"headerlink\" title=\"使用动态链接库文件\"></a>使用动态链接库文件</h3><p>构建出的动态链接库文件用于在其它地方使用，在这里也就是给执行入口使用。</p>\n<p>用于输出 main.js 的主 Webpack 配置文件内容如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> DllReferencePlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/DllReferencePlugin'</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// 告诉 Webpack 使用了哪些动态链接库</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> DllReferencePlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 描述 react 动态链接库的文件内容</span></span><br><span class=\"line\">      manifest: <span class=\"built_in\">require</span>(<span class=\"string\">'./dist/react.manifest.json'</span>),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> DllReferencePlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 描述 polyfill 动态链接库的文件内容</span></span><br><span class=\"line\">      manifest: <span class=\"built_in\">require</span>(<span class=\"string\">'./dist/polyfill.manifest.json'</span>),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  devtool: <span class=\"string\">'source-map'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：在 webpack_dll.config.js 文件中，DllPlugin 中的 name 参数必须和 output.library 中保持一致。 原因在于 DllPlugin 中的 name 参数会影响输出的 manifest.json 文件中 name 字段的值， 而在 webpack.config.js 文件中 DllReferencePlugin 会去 manifest.json 文件读取 name 字段的值， 把值的内容作为在从全局变量中获取动态链接库中内容时的全局变量名。</p>\n</blockquote>\n<h3 id=\"执行构建\"><a href=\"#执行构建\" class=\"headerlink\" title=\"执行构建\"></a>执行构建</h3><p>在修改好以上两个 Webpack 配置文件后，需要重新执行构建。 重新执行构建时要注意的是需要先把动态链接库相关的文件编译出来，因为主 Webpack 配置文件中定义的 DllReferencePlugin 依赖这些文件。</p>\n<p>执行构建时流程如下：</p>\n<ol>\n<li>如果动态链接库相关的文件还没有编译出来，就需要先把它们编译出来。方法是执行 webpack –config webpack_dll.config.js 命令。</li>\n<li>在确保动态链接库存在的前提下，才能正常的编译出入口执行文件。方法是执行 webpack 命令。这时你会发现构建速度有了非常大的提升。</li>\n</ol>\n<p>相信给你的项目加上以上优化方法后，构建速度会大大提高，赶快去试试把！</p>\n<h1 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h1><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/web/wa-lo-web-develop-edge-tool/index.html\" target=\"_blank\" rel=\"noopener\">Web 开发中的利器 - Webpack</a></li>\n<li>查看<a href=\"http://www.jianshu.com/p/e92ecf788c4f\" target=\"_blank\" rel=\"noopener\">Webpack 迁移的研究</a>，了解 Webpack 的具体配置方式</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文首发于<a href=\"https://www.ibm.com/developerworks/cn/web/wa-lo-expedite-webpack/index.html\" target=\"_blank\" rel=\"noopener\">IBM Dev社区</a></p>\n</blockquote>\n<p>Web 应用日益复杂，相关开发技术也百花齐放，这对前端构建工具提出了更高的要求。 Webpack 从众多构建工具中脱颖而出成为目前最流行的构建工具，几乎成为目前前端开发里的必备工具之一。 大多数人在使用 Webpack 的过程中都会遇到构建速度慢的问题，在项目大时显得尤为突出，这极大的影响了我们的开发体验，降低了我们的开发效率。</p>\n<p>本文将传授你一些加速 Webpack 构建的技巧，下面来一一介绍。</p>\n<h1 id=\"通过多进程并行处理\"><a href=\"#通过多进程并行处理\" class=\"headerlink\" title=\"通过多进程并行处理\"></a>通过多进程并行处理</h1><p>由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。 运行在 Node.js 之上的 Webpack 是单线程模型的，也就是说 Webpack 需要处理的任务需要一件件挨着做，不能多个事情一起做。</p>\n<p>文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？</p>\n<h3 id=\"使用-HappyPack\"><a href=\"#使用-HappyPack\" class=\"headerlink\" title=\"使用 HappyPack\"></a>使用 HappyPack</h3><p>HappyPack 就能让 Webpack 做到上面抛出的问题，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。</p>\n<p>接入 HappyPack 的相关代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span>  ExtractTextPlugin =  <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span>  HappyPack = <span class=\"built_in\">require</span>(<span class=\"string\">'happypack'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = &#123; </span><br><span class=\"line\">        <span class=\"built_in\">module</span>: &#123; </span><br><span class=\"line\">            rules: [ </span><br><span class=\"line\">                &#123;    <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>, </span><br><span class=\"line\">                    <span class=\"comment\">// 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例 </span></span><br><span class=\"line\">                    use:[<span class=\"string\">'happypack/loader?id=babel'</span>], </span><br><span class=\"line\">                    <span class=\"comment\">// 排除 node_modules 目录下的文件，node_modules目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换 </span></span><br><span class=\"line\">                    exclude: path.resolve(__dirname, <span class=\"string\">'node_modules'</span>),</span><br><span class=\"line\">                 &#125;, </span><br><span class=\"line\">                &#123; </span><br><span class=\"line\">                    <span class=\"comment\">// 把对 .css 文件的处理转交给 id 为 css 的 HappyPack 实例</span></span><br><span class=\"line\">                     test: <span class=\"regexp\">/\\.css$/</span>, </span><br><span class=\"line\">                     use:ExtractTextPlugin.extract(&#123; </span><br><span class=\"line\">                        use: [<span class=\"string\">'happypack/loader?id=css'</span>],</span><br><span class=\"line\">             &#125;), </span><br><span class=\"line\">        &#125;, </span><br><span class=\"line\">] &#125;,</span><br><span class=\"line\">    plugins: [ </span><br><span class=\"line\">        <span class=\"keyword\">new</span> HappyPack(&#123; </span><br><span class=\"line\">            <span class=\"comment\">// 用唯一的标识符 id 来代表当前的HappyPack 是用来处理一类特定的文件 </span></span><br><span class=\"line\">        id: <span class=\"string\">'babel'</span>, </span><br><span class=\"line\">            <span class=\"comment\">// 如何处理 .js 文件，用法和 Loader配置中一样 </span></span><br><span class=\"line\">        loaders: [<span class=\"string\">'babel-loader?cacheDirectory'</span>],</span><br><span class=\"line\">     &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> HappyPack(&#123; </span><br><span class=\"line\">                id: <span class=\"string\">'css'</span>, </span><br><span class=\"line\">                    <span class=\"comment\">// 如何处理 .css 文件，用法和Loader 配置中一样 </span></span><br><span class=\"line\">                loaders: [<span class=\"string\">'css-loader'</span>], &#125;), </span><br><span class=\"line\">                <span class=\"keyword\">new</span> ExtractTextPlugin(&#123; </span><br><span class=\"line\">                    filename: <span class=\"string\">`[name].css`</span>, </span><br><span class=\"line\">            &#125;), </span><br><span class=\"line\">        ],</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>以上代码有两点重要的修改：</p>\n<ul>\n<li>在 Loader 配置中，所有文件的处理都交给了 happypack/loader 去处理，使用紧跟其后的 querystring ?id=babel 去告诉 happypack/loader 去选择哪个 HappyPack 实例去处理文件。</li>\n<li>在 Plugin 配置中，新增了两个 HappyPack 实例分别用于告诉 happypack/loader 去如何处理 .js 和 .css 文件。选项中的 id 属性的值和上面 querystring 中的 ?id=babel 相对应，选项中的 loaders 属性和 Loader 配置中一样。</li>\n</ul>\n<p>接入 HappyPack 后，你需要给项目安装新的依赖：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -D happypack</span><br></pre></td></tr></table></figure>\n<p>安装成功后重新执行构建，你就会看到以下由 HappyPack 输出的日志：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Happy[babel]: Version: 4.0.0-beta.5. Threads: 3</span><br><span class=\"line\">Happy[babel]: All set; signaling webpack to proceed.Happy[css]: Version: 4.0.0-beta.5. Threads: 3Happy[css]: All set; signaling webpack to proceed.</span><br></pre></td></tr></table></figure>\n<p>说明你的 HappyPack 配置生效了，并且可以得知 HappyPack 分别启动了3个子进程去并行的处理任务。</p>\n<p>在整个 Webpack 构建流程中，最耗时的流程可能就是 Loader 对文件的转换操作了，因为要转换的文件数据巨多，而且这些转换操作都只能一个个挨着处理。 HappyPack 的核心原理就是把这部分任务分解到多个进程去并行处理，从而减少了总的构建时间。</p>\n<p>从前面的使用中可以看出所有需要通过 Loader 处理的文件都先交给了 happypack/loader 去处理，收集到了这些文件的处理权后 HappyPack 就好统一分配了。</p>\n<p>每通过 new HappyPack() 实例化一个 HappyPack 其实就是告诉 HappyPack 核心调度器如何通过一系列 Loader 去转换一类文件，并且可以指定如何给这类转换操作分配子进程。</p>\n<p>核心调度器的逻辑代码在主进程中，也就是运行着 Webpack 的进程中，核心调度器会把一个个任务分配给当前空闲的子进程，子进程处理完毕后把结果发送给核心调度器，它们之间的数据交换是通过进程间通信 API 实现的。</p>\n<p>核心调度器收到来自子进程处理完毕的结果后会通知 Webpack 该文件处理完毕。</p>\n<h3 id=\"使用-ParallelUglifyPlugin\"><a href=\"#使用-ParallelUglifyPlugin\" class=\"headerlink\" title=\"使用 ParallelUglifyPlugin\"></a>使用 ParallelUglifyPlugin</h3><p>在使用 Webpack 构建出用于发布到线上的代码时，都会有压缩代码这一流程。 最常见的 JavaScript 代码压缩工具是 UglifyJS，并且 Webpack 也内置了它。</p>\n<p>用过 UglifyJS 的你一定会发现在构建用于开发环境的代码时很快就能完成，但在构建用于线上的代码时构建一直卡在一个时间点迟迟没有反应，其实卡住的这个时候就是在进行代码压缩。</p>\n<p>由于压缩 JavaScript 代码需要先把代码解析成用 Object 抽象表示的 AST 语法树，再去应用各种规则分析和处理 AST，导致这个过程计算量巨大，耗时非常多。</p>\n<p>为什么不把多进程并行处理的思想也引入到代码压缩中呢？</p>\n<p>ParallelUglifyPlugin 就做了这个事情。 当 Webpack 有多个 JavaScript 文件需要输出和压缩时，原本会使用 UglifyJS 去一个个挨着压缩再输出， 但是 ParallelUglifyPlugin 则会开启多个子进程，把对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行。 所以 ParallelUglifyPlugin 能更快的完成对多个文件的压缩工作。</p>\n<p>使用 ParallelUglifyPlugin 也非常简单，把原来 Webpack 配置文件中内置的 UglifyJsPlugin 去掉后，再替换成 ParallelUglifyPlugin，相关代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span>  ParallelUglifyPlugin =  <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-parallel-uglify-plugin'</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123; </span><br><span class=\"line\">        plugins: [ </span><br><span class=\"line\">            <span class=\"comment\">// 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> ParallelUglifyPlugin(&#123; </span><br><span class=\"line\">                <span class=\"comment\">// 传递给 UglifyJS 的参数</span></span><br><span class=\"line\">                uglifyJS: &#123;</span><br><span class=\"line\">                 &#125;, </span><br><span class=\"line\">            &#125;), </span><br><span class=\"line\">        ],</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>接入 ParallelUglifyPlugin 后，项目需要安装新的依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -D webpack-parallel-uglify-plugin</span><br></pre></td></tr></table></figure>\n<p>安装成功后，重新执行构建你会发现速度变快了许多。如果设置 cacheDir 开启了缓存，在之后的构建中会变的更快。</p>\n<h3 id=\"缩小文件搜索范围\"><a href=\"#缩小文件搜索范围\" class=\"headerlink\" title=\"缩小文件搜索范围\"></a>缩小文件搜索范围</h3><p>Webpack 启动后会从配置的 Entry 出发，解析出文件中的导入语句，再递归的解析。 在遇到导入语句时 Webpack 会做两件事情：</p>\n<ol>\n<li>根据导入语句去寻找对应的要导入的文件。例如 require(‘react’) 导入语句对应的文件是 ./node_modules/react/react.js，而require(‘./util’)导入语句 对应的文件是 ./util.js。</li>\n<li>根据找到的要导入文件的后缀，使用配置中的 Loader 去处理文件。例如使用 ES6 开发的 JavaScript 文件需要使用 babel-loader 去处理。</li>\n</ol>\n<p>以上两件事情虽然对于处理一个文件非常快，但是当项目大了以后文件量会变的非常多，这时候构建速度慢的问题就会暴露出来。 虽然以上两件事情无法避免，但需要尽量减少以上两件事情的发生，以提高速度。</p>\n<p>接下来一一介绍可以优化它们的途径。</p>\n<h5 id=\"缩小-resolve-modules-的范围\"><a href=\"#缩小-resolve-modules-的范围\" class=\"headerlink\" title=\"缩小 resolve.modules 的范围\"></a>缩小 resolve.modules 的范围</h5><p>Webpack的resolve.modules 用于配置 Webpack 去哪些目录下寻找第三方模块。</p>\n<p>resolve.modules 的默认值是 [‘node_modules’]，含义是先去当前目录下的 ./node_modules 目录下去找想找的模块，如果没找到就去上一级目录 ../node_modules 中找，再没有就去 ../../node_modules 中找，以此类推，这和 Node.js 的模块寻找机制很相似。</p>\n<p>当安装的第三方模块都放在项目根目录下的 ./node_modules 目录下时，没有必要按照默认的方式去一层层的寻找，可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">            resolve: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</span></span><br><span class=\"line\">                <span class=\"comment\">// 其中 __dirname 表示当前工作目录，也就是项目根目录</span></span><br><span class=\"line\">                modules: [path.resolve(__dirname, <span class=\"string\">'node_modules'</span>)]</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"缩小-Loader-的命中范围\"><a href=\"#缩小-Loader-的命中范围\" class=\"headerlink\" title=\"缩小 Loader 的命中范围\"></a>缩小 Loader 的命中范围</h5><p>除此之外在使用 Loader 时可以通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件。 为了尽可能少的让文件被 Loader 处理，可以通过 include 去命中只有哪些文件需要被处理。</p>\n<p>以采用 ES6 的项目为例，在配置 babel-loader 时，可以这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能</span></span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启</span></span><br><span class=\"line\">        use: [<span class=\"string\">'babel-loader?cacheDirectory'</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 只对项目根目录下的 src 目录中的文件采用 babel-loader</span></span><br><span class=\"line\">        include: path.resolve(__dirname, <span class=\"string\">'src'</span>),</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>你可以适当的调整项目的目录结构，以方便在配置 Loader 时通过 include 去缩小命中范围。</p>\n<h5 id=\"缩小-resolve-extensions-的数量\"><a href=\"#缩小-resolve-extensions-的数量\" class=\"headerlink\" title=\"缩小 resolve.extensions 的数量\"></a>缩小 resolve.extensions 的数量</h5><p>在导入语句没带文件后缀时，Webpack 会自动带上后缀后去尝试询问文件是否存在。 Webpack 配置中的 resolve.extensions 用于配置在尝试过程中用到的后缀列表，默认是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extensions: [<span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>]</span><br></pre></td></tr></table></figure>\n<p>也就是说当遇到 require(‘./data’) 这样的导入语句时，Webpack 会先去寻找 ./data.js 文件，如果该文件不存在就去寻找 ./data.json 文件，如果还是找不到就报错。</p>\n<p>如果这个列表越长，或者正确的后缀在越后面，就会造成尝试的次数越多，所以 resolve.extensions 的配置也会影响到构建的性能。 在配置 resolve.extensions 时你需要遵守以下几点，以做到尽可能的优化构建性能：</p>\n<ul>\n<li>后缀尝试列表要尽可能的小，不要把项目中不可能存在的情况写到后缀尝试列表中。</li>\n<li>频率出现最高的文件后缀要优先放在最前面，以做到尽快的退出寻找过程。</li>\n<li>在源码中写导入语句时，要尽可能的带上后缀，从而可以避免寻找过程。例如在你确定的情况下把 require(‘./data’) 写成 require(‘./data.json’)。</li>\n</ul>\n<p>相关 Webpack 配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 尽可能的减少后缀尝试的可能性</span></span><br><span class=\"line\">    extensions: [<span class=\"string\">'js'</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"缩小-resolve-mainFields-的数量\"><a href=\"#缩小-resolve-mainFields-的数量\" class=\"headerlink\" title=\"缩小 resolve.mainFields 的数量\"></a>缩小 resolve.mainFields 的数量</h5><p>Webpack 配置中的 resolve.mainFields 用于配置第三方模块使用哪个入口文件。</p>\n<p>安装的第三方模块中都会有一个 package.json 文件用于描述这个模块的属性，其中有些字段用于描述入口文件在哪里，resolve.mainFields 用于配置采用哪个字段作为入口文件的描述。</p>\n<p>可以存在多个字段描述入口文件的原因是因为有些模块可以同时用在多个环境中，针对不同的运行环境需要使用不同的代码。 以 isomorphic-fetchfetch API 为例，它是 的一个实现，但可同时用于浏览器和 Node.js 环境。</p>\n<p>为了减少搜索步骤，在你明确第三方模块的入口文件描述字段时，你可以把它设置的尽量少。 由于大多数第三方模块都采用 main 字段去描述入口文件的位置，可以这样配置 Webpack：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 只采用 main 字段作为入口文件描述字段，以减少搜索步骤</span></span><br><span class=\"line\">    mainFields: [<span class=\"string\">'main'</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>使用本方法优化时，你需要考虑到所有运行时依赖的第三方模块的入口文件描述字段，就算有一个模块搞错了都可能会造成构建出的代码无法正常运行。</p>\n<h1 id=\"善用现存的文件\"><a href=\"#善用现存的文件\" class=\"headerlink\" title=\"善用现存的文件\"></a>善用现存的文件</h1><h3 id=\"通过-module-noParse-忽略文件\"><a href=\"#通过-module-noParse-忽略文件\" class=\"headerlink\" title=\"通过 module.noParse 忽略文件\"></a>通过 module.noParse 忽略文件</h3><p>Webpack 配置中的 module.noParse 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能。 原因是一些库，例如 jQuery 、ChartJS， 它们庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义。</p>\n<p>在上面的 <em>优化 resolve.alias 配置</em> 中讲到单独完整的 react.min.js 文件就没有采用模块化，让我们来通过配置 module.noParse 忽略对 react.min.js 文件的递归解析处理， 相关 Webpack 配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 独完整的 `react.min.js` 文件就没有采用模块化，忽略对 `react.min.js` 文件的递归解析处理</span></span><br><span class=\"line\">    noParse: [<span class=\"regexp\">/react\\.min\\.js$/</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意被忽略掉的文件里不应该包含 import 、 require 、 define 等模块化语句，不然会导致构建出的代码中包含无法在浏览器环境下执行的模块化语句。</p>\n<h3 id=\"通过-resolve-alias-映射文件\"><a href=\"#通过-resolve-alias-映射文件\" class=\"headerlink\" title=\"通过 resolve.alias 映射文件\"></a>通过 resolve.alias 映射文件</h3><p>Webpack 配置中的 resolve.alias 配置项通过别名来把原导入路径映射成一个新的导入路径。</p>\n<p>在实战项目中经常会依赖一些庞大的第三方模块，以 React 库为例，库中包含两套代码：</p>\n<ul>\n<li>一套是采用 CommonJS 规范的模块化代码，这些文件都放在 lib 目录下，以 package.json 中指定的入口文件 react.js 为模块的入口。</li>\n<li>一套是把 React 所有相关的代码打包好的完整代码放到一个单独的文件中，这些代码没有采用模块化可以直接执行。其中 dist/react.js 是用于开发环境，里面包含检查和警告的代码。dist/react.min.js 是用于线上环境，被最小化了。</li>\n</ul>\n<p>默认情况下 Webpack 会从入口文件 ./node_modules/react/react.js 开始递归的解析和处理依赖的几十个文件，这会时一个耗时的操作。 通过配置 resolve.alias 可以让 Webpack 在处理 React 库时，直接使用单独完整的 react.min.js 文件，从而跳过耗时的递归解析操作。</p>\n<p>相关 Webpack 配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 alias 把导入 react 的语句换成直接使用单独完整的 react.min.js 文件，</span></span><br><span class=\"line\">    <span class=\"comment\">// 减少耗时的递归解析操作</span></span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      <span class=\"string\">'react'</span>: path.resolve(__dirname, <span class=\"string\">'./node_modules/react/dist/react.min.js'</span>),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>除了 React 库外，大多数库发布到 Npm 仓库中时都会包含打包好的完整文件，对于这些库你也可以对它们配置 alias。</p>\n<p>但是对于有些库使用本优化方法后会影响到后面要讲的使用 Tree-Shaking 去除无效代码的优化，因为打包好的完整文件中有部分代码你的项目可能永远用不上。 一般对整体性比较强的库采用本方法优化，因为完整文件中的代码是一个整体，每一行都是不可或缺的。 但是对于一些工具类的库，例如 <a href=\"file:///h\" target=\"_blank\" rel=\"noopener\">lodash</a>，你的项目可能只用到了其中几个工具函数，你就不能使用本方法去优化，因为这会导致你的输出代码中包含很多永远不会执行的代码。</p>\n<h1 id=\"使用-DllPlugin\"><a href=\"#使用-DllPlugin\" class=\"headerlink\" title=\"使用 DllPlugin\"></a>使用 DllPlugin</h1><p>在介绍 DllPlugin 前先给大家介绍下 DLL。 用过 Windows 系统的人应该会经常看到以 .dll 为后缀的文件，这些文件称为<strong>动态链接库</strong>，在一个动态链接库中可以包含给其他模块调用的函数和数据。</p>\n<p>要给 Web 项目构建接入动态链接库的思想，需要完成以下事情：</p>\n<ul>\n<li>把网页依赖的基础模块抽离出来，打包到一个个单独的动态链接库中去。一个动态链接库中可以包含多个模块。</li>\n<li>当需要导入的模块存在于某个动态链接库中时，这个模块不能再次被打包，而是去动态链接库中获取。</li>\n<li>页面依赖的所有动态链接库需要被加载。</li>\n</ul>\n<p>为什么给 Web 项目构建接入动态链接库的思想后，会大大提升构建速度呢？ 原因在于包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码。 由于动态链接库中大多数包含的是常用的第三方模块，例如 react、react-dom，只要不升级这些模块的版本，动态链接库就不用重新编译。</p>\n<h3 id=\"接入-Webpack\"><a href=\"#接入-Webpack\" class=\"headerlink\" title=\"接入 Webpack\"></a>接入 Webpack</h3><p>Webpack 已经内置了对动态链接库的支持，需要通过2个内置的插件接入，它们分别是：</p>\n<ul>\n<li>DllPlugin 插件：用于打包出一个个单独的动态链接库文件。</li>\n<li>DllReferencePlugin 插件：用于在主要配置文件中去引入 DllPlugin 插件打包好的动态链接库文件。</li>\n</ul>\n<p>下面以基本的 React 项目为例，为其接入 DllPlugin，在开始前先来看下最终构建出的目录结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── main.js</span><br><span class=\"line\">├── polyfill.dll.js</span><br><span class=\"line\">├── polyfill.manifest.json</span><br><span class=\"line\">├── react.dll.js</span><br><span class=\"line\">└── react.manifest.json</span><br></pre></td></tr></table></figure>\n<p>其中包含两个动态链接库文件，分别是：</p>\n<ul>\n<li>polyfill.dll.js 里面包含项目所有依赖的 polyfill，例如 Promise、fetch 等 API。</li>\n<li>react.dll.js 里面包含 React 的基础运行环境，也就是 react 和 react-dom 模块。</li>\n</ul>\n<p>以 react.dll.js 文件为例，其文件内容大致如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _dll_react = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 此处省略 webpackBootstrap 函数代码</span></span><br><span class=\"line\">&#125;([</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 模块 ID 为 0 的模块对应的代码</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ... 此处省略剩下的模块对应的代码 </span></span><br><span class=\"line\">]));</span><br></pre></td></tr></table></figure>\n<p>可见一个动态链接库文件中包含了大量模块的代码，这些模块存放在一个数组里，用数组的索引号作为 ID。 并且还通过 _dll_react 变量把自己暴露在了全局中，也就是可以通过 window._dll_react 可以访问到它里面包含的模块。</p>\n<p>其中 polyfill.manifest.json 和 react.manifest.json 文件也是由 DllPlugin 生成，用于描述动态链接库文件中包含哪些模块， 以 react.manifest.json 文件为例，其文件内容大致如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 描述该动态链接库文件暴露在全局的变量名称</span></span><br><span class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"_dll_react\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"content\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/process/browser.js\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"id\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"string\">\"meta\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// ... 此处省略部分模块</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可见 manifest.json 文件清楚地描述了与其对应的 dll.js 文件中包含了哪些模块，以及每个模块的路径和 ID。</p>\n<p>main.js 文件是编译出来的执行入口文件，当遇到其依赖的模块在 dll.js 文件中时，会直接通过 dll.js 文件暴露出的全局变量去获取打包在 dll.js 文件的模块。 所以在 index.html 文件中需要把依赖的两个 dll.js 文件给加载进去，index.html 内容如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--导入依赖的动态链接库文件--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./dist/polyfill.dll.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./dist/react.dll.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--导入执行入口文件--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./dist/main.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>以上就是所有接入 DllPlugin 后最终编译出来的代码，接下来教你如何实现。</p>\n<h3 id=\"构建出动态链接库文件\"><a href=\"#构建出动态链接库文件\" class=\"headerlink\" title=\"构建出动态链接库文件\"></a>构建出动态链接库文件</h3><p>构建输出的以下这四个文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── polyfill.dll.js</span><br><span class=\"line\">├── polyfill.manifest.json</span><br><span class=\"line\">├── react.dll.js</span><br><span class=\"line\">└── react.manifest.json</span><br></pre></td></tr></table></figure>\n<p>和以下这一个文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── main.js</span><br></pre></td></tr></table></figure>\n<p>是由两份不同的构建分别输出的。</p>\n<p>与动态链接库相关的文件需要由一个独立的构建输出，用于给主构建使用。新建一个 Webpack 配置文件 webpack_dll.config.js 专门用于构建它们，文件内容如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> DllPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/DllPlugin'</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// JS 执行入口文件</span></span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把 React 相关模块的放到一个单独的动态链接库</span></span><br><span class=\"line\">    react: [<span class=\"string\">'react'</span>, <span class=\"string\">'react-dom'</span>],</span><br><span class=\"line\">    <span class=\"comment\">// 把项目需要所有的 polyfill 放到一个单独的动态链接库</span></span><br><span class=\"line\">    polyfill: [<span class=\"string\">'core-js/fn/object/assign'</span>, <span class=\"string\">'core-js/fn/promise'</span>, <span class=\"string\">'whatwg-fetch'</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称，</span></span><br><span class=\"line\">    <span class=\"comment\">// 也就是 entry 中配置的 react 和 polyfill</span></span><br><span class=\"line\">    filename: <span class=\"string\">'[name].dll.js'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 输出的文件都放到 dist 目录下</span></span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    <span class=\"comment\">// 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react</span></span><br><span class=\"line\">    <span class=\"comment\">// 之所以在前面加上 _dll_ 是为了防止全局变量冲突</span></span><br><span class=\"line\">    library: <span class=\"string\">'_dll_[name]'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// 接入 DllPlugin</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> DllPlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 动态链接库的全局变量名称，需要和 output.library 中保持一致</span></span><br><span class=\"line\">      <span class=\"comment\">// 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值</span></span><br><span class=\"line\">      <span class=\"comment\">// 例如 react.manifest.json 中就有 \"name\": \"_dll_react\"</span></span><br><span class=\"line\">      name: <span class=\"string\">'_dll_[name]'</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 描述动态链接库的 manifest.json 文件输出时的文件名称</span></span><br><span class=\"line\">      path: path.join(__dirname, <span class=\"string\">'dist'</span>, <span class=\"string\">'[name].manifest.json'</span>),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用动态链接库文件\"><a href=\"#使用动态链接库文件\" class=\"headerlink\" title=\"使用动态链接库文件\"></a>使用动态链接库文件</h3><p>构建出的动态链接库文件用于在其它地方使用，在这里也就是给执行入口使用。</p>\n<p>用于输出 main.js 的主 Webpack 配置文件内容如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> DllReferencePlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/DllReferencePlugin'</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// 告诉 Webpack 使用了哪些动态链接库</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> DllReferencePlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 描述 react 动态链接库的文件内容</span></span><br><span class=\"line\">      manifest: <span class=\"built_in\">require</span>(<span class=\"string\">'./dist/react.manifest.json'</span>),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> DllReferencePlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 描述 polyfill 动态链接库的文件内容</span></span><br><span class=\"line\">      manifest: <span class=\"built_in\">require</span>(<span class=\"string\">'./dist/polyfill.manifest.json'</span>),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  devtool: <span class=\"string\">'source-map'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：在 webpack_dll.config.js 文件中，DllPlugin 中的 name 参数必须和 output.library 中保持一致。 原因在于 DllPlugin 中的 name 参数会影响输出的 manifest.json 文件中 name 字段的值， 而在 webpack.config.js 文件中 DllReferencePlugin 会去 manifest.json 文件读取 name 字段的值， 把值的内容作为在从全局变量中获取动态链接库中内容时的全局变量名。</p>\n</blockquote>\n<h3 id=\"执行构建\"><a href=\"#执行构建\" class=\"headerlink\" title=\"执行构建\"></a>执行构建</h3><p>在修改好以上两个 Webpack 配置文件后，需要重新执行构建。 重新执行构建时要注意的是需要先把动态链接库相关的文件编译出来，因为主 Webpack 配置文件中定义的 DllReferencePlugin 依赖这些文件。</p>\n<p>执行构建时流程如下：</p>\n<ol>\n<li>如果动态链接库相关的文件还没有编译出来，就需要先把它们编译出来。方法是执行 webpack –config webpack_dll.config.js 命令。</li>\n<li>在确保动态链接库存在的前提下，才能正常的编译出入口执行文件。方法是执行 webpack 命令。这时你会发现构建速度有了非常大的提升。</li>\n</ol>\n<p>相信给你的项目加上以上优化方法后，构建速度会大大提高，赶快去试试把！</p>\n<h1 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h1><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/web/wa-lo-web-develop-edge-tool/index.html\" target=\"_blank\" rel=\"noopener\">Web 开发中的利器 - Webpack</a></li>\n<li>查看<a href=\"http://www.jianshu.com/p/e92ecf788c4f\" target=\"_blank\" rel=\"noopener\">Webpack 迁移的研究</a>，了解 Webpack 的具体配置方式</li>\n</ul>\n"},{"title":"基于HeadlessChrome的网页自动化测试系统-FinalTest","date":"2017-06-25T18:59:41.000Z","url":"https://github.com/gwuhaolin/blog/issues/7","_content":"\n**本文还未完成，还在不断补充中**\n\n> 你的团队是不是遇到过网页出故障了无法第一时间知道只能等用户反馈后才知道出现了问题？我曾因为一次疏忽导致产品的一个页面不可用被批评，这让我难受低沉了一个星期。\n\n我总是追求合理高效的方法来解决我所遇到的问题，于是我幻想要是有一个工具可以智能的监视网页一旦出现异常就提醒我们该多好。就在出故障的几天后chrome团队宣布chrome[支持headless模式](https://developers.google.com/web/updates/2017/04/headless-chrome)，这让我很兴奋因为它正是我在找的，于是我开始做[FinalTest]()（等成熟了再开源）。\n\n# HeadlessChrome介绍\nHeadlessChrome支持chrome所具有的所有功能只不过因为不显示界面而更快资源占用更小。相比于之前的[phantomjs](http://phantomjs.org)(作者因为HeadlessChrome的推出而宣布停止维护)chrome的优势在于它又一个很强的爹(google)会一直维护它优化它，并且chrome在用户量、体验、速度、稳定性都是第一的，所以我认为HeadlessChrome会渐渐替代之前所有的HeadlessBrowser方案。\n\n### 如何操控HeadlessChrome\n既然HeadlessChrome是以无界面模式运行的，那要怎么控制它和它交互？\nchrome提供了远程控制接口，目前可以通过[chrome-remote-interface](https://github.com/cyrus-and/chrome-remote-interface)来用js代码向chrome发送命令进行交互。在启动chrome的时候要开启远程控制接口，然后通过 chrome-remote-interface 连接到chrome后再通过协议控制chrome。具体操作见文档：\n- [以headless模式和远程控制模式启动chrome](https://developers.google.com/web/updates/2017/04/headless-chrome)\n- [连接到远程chrome控制它](https://github.com/cyrus-and/chrome-remote-interface#sample-api-usage)\n- [控制chrome时支持哪些操作具体怎么用](https://chromedevtools.github.io/devtools-protocol/)\n\n\n# FinalTest介绍\nFinalTest是一个自动化的网页功能异常检测工具。名称来源于它做了测试阶段的最后一环，也是最后一道质量保障。\n\n### FinalTest目标\n- 自己会定时去检测出网页的功能异常，第一时间通知相关人\n- 不需要对原网页产生任何改变就能使用\n- 任何类型的网页都可以接入，包括服务器渲染的和浏览器渲染的\n- 无需做太多工作就可接入已有网页，即便对于复杂场景要写单元测试注入运行，写单测的过程也是很轻松可调试的\n\n需要特别说明的是FinalTest只是用来检查网页的功能异常（无法正常使用）而不做浏览器兼容性检查。\n\n### 如何检测网页功能异常\n当发生以下情况时，FinalTest会认为网页是异常的：\n- 网页加载失败（后端服务挂了）\n- 网页运行时出现未捕获的异常（前端js有问题）\n- 控制台输出了error或warn日志（前端js有问题）\n- 网络请求异常（CDN出问题，文件丢失），或者请求成功但是返回结果异常（后端服务有问题）\n- 对于复杂的情况，可以为网页写测试脚本注入到浏览器里运行（一些交互性的功能无法使用）\n\n### FinalTest架构\n![FinalTest架构图](https://user-images.githubusercontent.com/5773264/27568503-cafec6b6-5b24-11e7-8855-79e85d0b6576.png)\n\n其中包含这些模块：\n- [chrome-runner](https://github.com/gwuhaolin/chrome-runner) 以控制模式启动系统上的chrome，并且守护着它保证chrome一直处于正常运行状态\n- [chrome-pool](https://github.com/gwuhaolin/chrome-pool) 来自于数据库连接池的概念，管理chrome tabs重复利用tab提高chrome执行效率减少资源占用\n- [chrome-tester](https://github.com/gwuhaolin/chrome-tester) 检测执行者，控制chrome运行网页找出出行的异常\n- 管理后台 是用与接入网页时录入和实时查看监测运行状态的网页，和录入警告相关人\n- reporter-web 是用于收集chrome-tester跑出的结果整理后通过[socket.io](https://socket.io/)传输给管理后台展示，SPA网页应用\n- reporter-notice 是用于收集chrome-tester跑出的结果判断是否要警告，发生警告给相关人\n\n### FinalTest难点\n- 部分页面依赖登入态，如何简单的保证在测试一个页面前有正确的登入态？虽然通过CGI模拟登入或者控制浏览器完成登入步骤是可行的，但是这样流程是不是有点繁琐？\n- 部分复杂功能可能需要进行一系列操作后才会进入，要测试这些功能目前好像只能通过写e2e测试脚本注入到浏览器里运行，但是写e2e测试会增加开发成本和维护成本。\n- 是不是可以跟踪页面dom的diff变化来作出异常判断？\n\n### 与其它类似方案对比\n- [Nightwatch.js](http://nightwatchjs.org)：采用Selenium控制phantomjs浏览器执行e2e测试，安装复杂执行效率低占用资源大，只适合本地开发时跑测试，不适合在服务器端批量高频运行。\n\n[阅读原文](http://wuhaolin.cn/2017/06/26/%E5%9F%BA%E4%BA%8EHeadlessChrome%E7%9A%84%E7%BD%91%E9%A1%B5%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E7%BB%9F-FinalTest/)","source":"_posts/基于HeadlessChrome的网页自动化测试系统-FinalTest.md","raw":"---\ntitle: 基于HeadlessChrome的网页自动化测试系统-FinalTest\ndate: 2017-06-26T02:59:41Z\nurl: https://github.com/gwuhaolin/blog/issues/7\ntags:\n    - chrome\n---\n\n**本文还未完成，还在不断补充中**\n\n> 你的团队是不是遇到过网页出故障了无法第一时间知道只能等用户反馈后才知道出现了问题？我曾因为一次疏忽导致产品的一个页面不可用被批评，这让我难受低沉了一个星期。\n\n我总是追求合理高效的方法来解决我所遇到的问题，于是我幻想要是有一个工具可以智能的监视网页一旦出现异常就提醒我们该多好。就在出故障的几天后chrome团队宣布chrome[支持headless模式](https://developers.google.com/web/updates/2017/04/headless-chrome)，这让我很兴奋因为它正是我在找的，于是我开始做[FinalTest]()（等成熟了再开源）。\n\n# HeadlessChrome介绍\nHeadlessChrome支持chrome所具有的所有功能只不过因为不显示界面而更快资源占用更小。相比于之前的[phantomjs](http://phantomjs.org)(作者因为HeadlessChrome的推出而宣布停止维护)chrome的优势在于它又一个很强的爹(google)会一直维护它优化它，并且chrome在用户量、体验、速度、稳定性都是第一的，所以我认为HeadlessChrome会渐渐替代之前所有的HeadlessBrowser方案。\n\n### 如何操控HeadlessChrome\n既然HeadlessChrome是以无界面模式运行的，那要怎么控制它和它交互？\nchrome提供了远程控制接口，目前可以通过[chrome-remote-interface](https://github.com/cyrus-and/chrome-remote-interface)来用js代码向chrome发送命令进行交互。在启动chrome的时候要开启远程控制接口，然后通过 chrome-remote-interface 连接到chrome后再通过协议控制chrome。具体操作见文档：\n- [以headless模式和远程控制模式启动chrome](https://developers.google.com/web/updates/2017/04/headless-chrome)\n- [连接到远程chrome控制它](https://github.com/cyrus-and/chrome-remote-interface#sample-api-usage)\n- [控制chrome时支持哪些操作具体怎么用](https://chromedevtools.github.io/devtools-protocol/)\n\n\n# FinalTest介绍\nFinalTest是一个自动化的网页功能异常检测工具。名称来源于它做了测试阶段的最后一环，也是最后一道质量保障。\n\n### FinalTest目标\n- 自己会定时去检测出网页的功能异常，第一时间通知相关人\n- 不需要对原网页产生任何改变就能使用\n- 任何类型的网页都可以接入，包括服务器渲染的和浏览器渲染的\n- 无需做太多工作就可接入已有网页，即便对于复杂场景要写单元测试注入运行，写单测的过程也是很轻松可调试的\n\n需要特别说明的是FinalTest只是用来检查网页的功能异常（无法正常使用）而不做浏览器兼容性检查。\n\n### 如何检测网页功能异常\n当发生以下情况时，FinalTest会认为网页是异常的：\n- 网页加载失败（后端服务挂了）\n- 网页运行时出现未捕获的异常（前端js有问题）\n- 控制台输出了error或warn日志（前端js有问题）\n- 网络请求异常（CDN出问题，文件丢失），或者请求成功但是返回结果异常（后端服务有问题）\n- 对于复杂的情况，可以为网页写测试脚本注入到浏览器里运行（一些交互性的功能无法使用）\n\n### FinalTest架构\n![FinalTest架构图](https://user-images.githubusercontent.com/5773264/27568503-cafec6b6-5b24-11e7-8855-79e85d0b6576.png)\n\n其中包含这些模块：\n- [chrome-runner](https://github.com/gwuhaolin/chrome-runner) 以控制模式启动系统上的chrome，并且守护着它保证chrome一直处于正常运行状态\n- [chrome-pool](https://github.com/gwuhaolin/chrome-pool) 来自于数据库连接池的概念，管理chrome tabs重复利用tab提高chrome执行效率减少资源占用\n- [chrome-tester](https://github.com/gwuhaolin/chrome-tester) 检测执行者，控制chrome运行网页找出出行的异常\n- 管理后台 是用与接入网页时录入和实时查看监测运行状态的网页，和录入警告相关人\n- reporter-web 是用于收集chrome-tester跑出的结果整理后通过[socket.io](https://socket.io/)传输给管理后台展示，SPA网页应用\n- reporter-notice 是用于收集chrome-tester跑出的结果判断是否要警告，发生警告给相关人\n\n### FinalTest难点\n- 部分页面依赖登入态，如何简单的保证在测试一个页面前有正确的登入态？虽然通过CGI模拟登入或者控制浏览器完成登入步骤是可行的，但是这样流程是不是有点繁琐？\n- 部分复杂功能可能需要进行一系列操作后才会进入，要测试这些功能目前好像只能通过写e2e测试脚本注入到浏览器里运行，但是写e2e测试会增加开发成本和维护成本。\n- 是不是可以跟踪页面dom的diff变化来作出异常判断？\n\n### 与其它类似方案对比\n- [Nightwatch.js](http://nightwatchjs.org)：采用Selenium控制phantomjs浏览器执行e2e测试，安装复杂执行效率低占用资源大，只适合本地开发时跑测试，不适合在服务器端批量高频运行。\n\n[阅读原文](http://wuhaolin.cn/2017/06/26/%E5%9F%BA%E4%BA%8EHeadlessChrome%E7%9A%84%E7%BD%91%E9%A1%B5%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E7%BB%9F-FinalTest/)","slug":"基于HeadlessChrome的网页自动化测试系统-FinalTest","published":1,"updated":"2018-11-14T04:39:28.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjogs0keg000mg5tcfl66lwzf","content":"<p><strong>本文还未完成，还在不断补充中</strong></p>\n<blockquote>\n<p>你的团队是不是遇到过网页出故障了无法第一时间知道只能等用户反馈后才知道出现了问题？我曾因为一次疏忽导致产品的一个页面不可用被批评，这让我难受低沉了一个星期。</p>\n</blockquote>\n<p>我总是追求合理高效的方法来解决我所遇到的问题，于是我幻想要是有一个工具可以智能的监视网页一旦出现异常就提醒我们该多好。就在出故障的几天后chrome团队宣布chrome<a href=\"https://developers.google.com/web/updates/2017/04/headless-chrome\" target=\"_blank\" rel=\"noopener\">支持headless模式</a>，这让我很兴奋因为它正是我在找的，于是我开始做<a href=\"\">FinalTest</a>（等成熟了再开源）。</p>\n<h1 id=\"HeadlessChrome介绍\"><a href=\"#HeadlessChrome介绍\" class=\"headerlink\" title=\"HeadlessChrome介绍\"></a>HeadlessChrome介绍</h1><p>HeadlessChrome支持chrome所具有的所有功能只不过因为不显示界面而更快资源占用更小。相比于之前的<a href=\"http://phantomjs.org\" target=\"_blank\" rel=\"noopener\">phantomjs</a>(作者因为HeadlessChrome的推出而宣布停止维护)chrome的优势在于它又一个很强的爹(google)会一直维护它优化它，并且chrome在用户量、体验、速度、稳定性都是第一的，所以我认为HeadlessChrome会渐渐替代之前所有的HeadlessBrowser方案。</p>\n<h3 id=\"如何操控HeadlessChrome\"><a href=\"#如何操控HeadlessChrome\" class=\"headerlink\" title=\"如何操控HeadlessChrome\"></a>如何操控HeadlessChrome</h3><p>既然HeadlessChrome是以无界面模式运行的，那要怎么控制它和它交互？<br>chrome提供了远程控制接口，目前可以通过<a href=\"https://github.com/cyrus-and/chrome-remote-interface\" target=\"_blank\" rel=\"noopener\">chrome-remote-interface</a>来用js代码向chrome发送命令进行交互。在启动chrome的时候要开启远程控制接口，然后通过 chrome-remote-interface 连接到chrome后再通过协议控制chrome。具体操作见文档：</p>\n<ul>\n<li><a href=\"https://developers.google.com/web/updates/2017/04/headless-chrome\" target=\"_blank\" rel=\"noopener\">以headless模式和远程控制模式启动chrome</a></li>\n<li><a href=\"https://github.com/cyrus-and/chrome-remote-interface#sample-api-usage\" target=\"_blank\" rel=\"noopener\">连接到远程chrome控制它</a></li>\n<li><a href=\"https://chromedevtools.github.io/devtools-protocol/\" target=\"_blank\" rel=\"noopener\">控制chrome时支持哪些操作具体怎么用</a></li>\n</ul>\n<h1 id=\"FinalTest介绍\"><a href=\"#FinalTest介绍\" class=\"headerlink\" title=\"FinalTest介绍\"></a>FinalTest介绍</h1><p>FinalTest是一个自动化的网页功能异常检测工具。名称来源于它做了测试阶段的最后一环，也是最后一道质量保障。</p>\n<h3 id=\"FinalTest目标\"><a href=\"#FinalTest目标\" class=\"headerlink\" title=\"FinalTest目标\"></a>FinalTest目标</h3><ul>\n<li>自己会定时去检测出网页的功能异常，第一时间通知相关人</li>\n<li>不需要对原网页产生任何改变就能使用</li>\n<li>任何类型的网页都可以接入，包括服务器渲染的和浏览器渲染的</li>\n<li>无需做太多工作就可接入已有网页，即便对于复杂场景要写单元测试注入运行，写单测的过程也是很轻松可调试的</li>\n</ul>\n<p>需要特别说明的是FinalTest只是用来检查网页的功能异常（无法正常使用）而不做浏览器兼容性检查。</p>\n<h3 id=\"如何检测网页功能异常\"><a href=\"#如何检测网页功能异常\" class=\"headerlink\" title=\"如何检测网页功能异常\"></a>如何检测网页功能异常</h3><p>当发生以下情况时，FinalTest会认为网页是异常的：</p>\n<ul>\n<li>网页加载失败（后端服务挂了）</li>\n<li>网页运行时出现未捕获的异常（前端js有问题）</li>\n<li>控制台输出了error或warn日志（前端js有问题）</li>\n<li>网络请求异常（CDN出问题，文件丢失），或者请求成功但是返回结果异常（后端服务有问题）</li>\n<li>对于复杂的情况，可以为网页写测试脚本注入到浏览器里运行（一些交互性的功能无法使用）</li>\n</ul>\n<h3 id=\"FinalTest架构\"><a href=\"#FinalTest架构\" class=\"headerlink\" title=\"FinalTest架构\"></a>FinalTest架构</h3><p><img src=\"https://user-images.githubusercontent.com/5773264/27568503-cafec6b6-5b24-11e7-8855-79e85d0b6576.png\" alt=\"FinalTest架构图\"></p>\n<p>其中包含这些模块：</p>\n<ul>\n<li><a href=\"https://github.com/gwuhaolin/chrome-runner\" target=\"_blank\" rel=\"noopener\">chrome-runner</a> 以控制模式启动系统上的chrome，并且守护着它保证chrome一直处于正常运行状态</li>\n<li><a href=\"https://github.com/gwuhaolin/chrome-pool\" target=\"_blank\" rel=\"noopener\">chrome-pool</a> 来自于数据库连接池的概念，管理chrome tabs重复利用tab提高chrome执行效率减少资源占用</li>\n<li><a href=\"https://github.com/gwuhaolin/chrome-tester\" target=\"_blank\" rel=\"noopener\">chrome-tester</a> 检测执行者，控制chrome运行网页找出出行的异常</li>\n<li>管理后台 是用与接入网页时录入和实时查看监测运行状态的网页，和录入警告相关人</li>\n<li>reporter-web 是用于收集chrome-tester跑出的结果整理后通过<a href=\"https://socket.io/\" target=\"_blank\" rel=\"noopener\">socket.io</a>传输给管理后台展示，SPA网页应用</li>\n<li>reporter-notice 是用于收集chrome-tester跑出的结果判断是否要警告，发生警告给相关人</li>\n</ul>\n<h3 id=\"FinalTest难点\"><a href=\"#FinalTest难点\" class=\"headerlink\" title=\"FinalTest难点\"></a>FinalTest难点</h3><ul>\n<li>部分页面依赖登入态，如何简单的保证在测试一个页面前有正确的登入态？虽然通过CGI模拟登入或者控制浏览器完成登入步骤是可行的，但是这样流程是不是有点繁琐？</li>\n<li>部分复杂功能可能需要进行一系列操作后才会进入，要测试这些功能目前好像只能通过写e2e测试脚本注入到浏览器里运行，但是写e2e测试会增加开发成本和维护成本。</li>\n<li>是不是可以跟踪页面dom的diff变化来作出异常判断？</li>\n</ul>\n<h3 id=\"与其它类似方案对比\"><a href=\"#与其它类似方案对比\" class=\"headerlink\" title=\"与其它类似方案对比\"></a>与其它类似方案对比</h3><ul>\n<li><a href=\"http://nightwatchjs.org\" target=\"_blank\" rel=\"noopener\">Nightwatch.js</a>：采用Selenium控制phantomjs浏览器执行e2e测试，安装复杂执行效率低占用资源大，只适合本地开发时跑测试，不适合在服务器端批量高频运行。</li>\n</ul>\n<p><a href=\"http://wuhaolin.cn/2017/06/26/%E5%9F%BA%E4%BA%8EHeadlessChrome%E7%9A%84%E7%BD%91%E9%A1%B5%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E7%BB%9F-FinalTest/\">阅读原文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>本文还未完成，还在不断补充中</strong></p>\n<blockquote>\n<p>你的团队是不是遇到过网页出故障了无法第一时间知道只能等用户反馈后才知道出现了问题？我曾因为一次疏忽导致产品的一个页面不可用被批评，这让我难受低沉了一个星期。</p>\n</blockquote>\n<p>我总是追求合理高效的方法来解决我所遇到的问题，于是我幻想要是有一个工具可以智能的监视网页一旦出现异常就提醒我们该多好。就在出故障的几天后chrome团队宣布chrome<a href=\"https://developers.google.com/web/updates/2017/04/headless-chrome\" target=\"_blank\" rel=\"noopener\">支持headless模式</a>，这让我很兴奋因为它正是我在找的，于是我开始做<a href=\"\">FinalTest</a>（等成熟了再开源）。</p>\n<h1 id=\"HeadlessChrome介绍\"><a href=\"#HeadlessChrome介绍\" class=\"headerlink\" title=\"HeadlessChrome介绍\"></a>HeadlessChrome介绍</h1><p>HeadlessChrome支持chrome所具有的所有功能只不过因为不显示界面而更快资源占用更小。相比于之前的<a href=\"http://phantomjs.org\" target=\"_blank\" rel=\"noopener\">phantomjs</a>(作者因为HeadlessChrome的推出而宣布停止维护)chrome的优势在于它又一个很强的爹(google)会一直维护它优化它，并且chrome在用户量、体验、速度、稳定性都是第一的，所以我认为HeadlessChrome会渐渐替代之前所有的HeadlessBrowser方案。</p>\n<h3 id=\"如何操控HeadlessChrome\"><a href=\"#如何操控HeadlessChrome\" class=\"headerlink\" title=\"如何操控HeadlessChrome\"></a>如何操控HeadlessChrome</h3><p>既然HeadlessChrome是以无界面模式运行的，那要怎么控制它和它交互？<br>chrome提供了远程控制接口，目前可以通过<a href=\"https://github.com/cyrus-and/chrome-remote-interface\" target=\"_blank\" rel=\"noopener\">chrome-remote-interface</a>来用js代码向chrome发送命令进行交互。在启动chrome的时候要开启远程控制接口，然后通过 chrome-remote-interface 连接到chrome后再通过协议控制chrome。具体操作见文档：</p>\n<ul>\n<li><a href=\"https://developers.google.com/web/updates/2017/04/headless-chrome\" target=\"_blank\" rel=\"noopener\">以headless模式和远程控制模式启动chrome</a></li>\n<li><a href=\"https://github.com/cyrus-and/chrome-remote-interface#sample-api-usage\" target=\"_blank\" rel=\"noopener\">连接到远程chrome控制它</a></li>\n<li><a href=\"https://chromedevtools.github.io/devtools-protocol/\" target=\"_blank\" rel=\"noopener\">控制chrome时支持哪些操作具体怎么用</a></li>\n</ul>\n<h1 id=\"FinalTest介绍\"><a href=\"#FinalTest介绍\" class=\"headerlink\" title=\"FinalTest介绍\"></a>FinalTest介绍</h1><p>FinalTest是一个自动化的网页功能异常检测工具。名称来源于它做了测试阶段的最后一环，也是最后一道质量保障。</p>\n<h3 id=\"FinalTest目标\"><a href=\"#FinalTest目标\" class=\"headerlink\" title=\"FinalTest目标\"></a>FinalTest目标</h3><ul>\n<li>自己会定时去检测出网页的功能异常，第一时间通知相关人</li>\n<li>不需要对原网页产生任何改变就能使用</li>\n<li>任何类型的网页都可以接入，包括服务器渲染的和浏览器渲染的</li>\n<li>无需做太多工作就可接入已有网页，即便对于复杂场景要写单元测试注入运行，写单测的过程也是很轻松可调试的</li>\n</ul>\n<p>需要特别说明的是FinalTest只是用来检查网页的功能异常（无法正常使用）而不做浏览器兼容性检查。</p>\n<h3 id=\"如何检测网页功能异常\"><a href=\"#如何检测网页功能异常\" class=\"headerlink\" title=\"如何检测网页功能异常\"></a>如何检测网页功能异常</h3><p>当发生以下情况时，FinalTest会认为网页是异常的：</p>\n<ul>\n<li>网页加载失败（后端服务挂了）</li>\n<li>网页运行时出现未捕获的异常（前端js有问题）</li>\n<li>控制台输出了error或warn日志（前端js有问题）</li>\n<li>网络请求异常（CDN出问题，文件丢失），或者请求成功但是返回结果异常（后端服务有问题）</li>\n<li>对于复杂的情况，可以为网页写测试脚本注入到浏览器里运行（一些交互性的功能无法使用）</li>\n</ul>\n<h3 id=\"FinalTest架构\"><a href=\"#FinalTest架构\" class=\"headerlink\" title=\"FinalTest架构\"></a>FinalTest架构</h3><p><img src=\"https://user-images.githubusercontent.com/5773264/27568503-cafec6b6-5b24-11e7-8855-79e85d0b6576.png\" alt=\"FinalTest架构图\"></p>\n<p>其中包含这些模块：</p>\n<ul>\n<li><a href=\"https://github.com/gwuhaolin/chrome-runner\" target=\"_blank\" rel=\"noopener\">chrome-runner</a> 以控制模式启动系统上的chrome，并且守护着它保证chrome一直处于正常运行状态</li>\n<li><a href=\"https://github.com/gwuhaolin/chrome-pool\" target=\"_blank\" rel=\"noopener\">chrome-pool</a> 来自于数据库连接池的概念，管理chrome tabs重复利用tab提高chrome执行效率减少资源占用</li>\n<li><a href=\"https://github.com/gwuhaolin/chrome-tester\" target=\"_blank\" rel=\"noopener\">chrome-tester</a> 检测执行者，控制chrome运行网页找出出行的异常</li>\n<li>管理后台 是用与接入网页时录入和实时查看监测运行状态的网页，和录入警告相关人</li>\n<li>reporter-web 是用于收集chrome-tester跑出的结果整理后通过<a href=\"https://socket.io/\" target=\"_blank\" rel=\"noopener\">socket.io</a>传输给管理后台展示，SPA网页应用</li>\n<li>reporter-notice 是用于收集chrome-tester跑出的结果判断是否要警告，发生警告给相关人</li>\n</ul>\n<h3 id=\"FinalTest难点\"><a href=\"#FinalTest难点\" class=\"headerlink\" title=\"FinalTest难点\"></a>FinalTest难点</h3><ul>\n<li>部分页面依赖登入态，如何简单的保证在测试一个页面前有正确的登入态？虽然通过CGI模拟登入或者控制浏览器完成登入步骤是可行的，但是这样流程是不是有点繁琐？</li>\n<li>部分复杂功能可能需要进行一系列操作后才会进入，要测试这些功能目前好像只能通过写e2e测试脚本注入到浏览器里运行，但是写e2e测试会增加开发成本和维护成本。</li>\n<li>是不是可以跟踪页面dom的diff变化来作出异常判断？</li>\n</ul>\n<h3 id=\"与其它类似方案对比\"><a href=\"#与其它类似方案对比\" class=\"headerlink\" title=\"与其它类似方案对比\"></a>与其它类似方案对比</h3><ul>\n<li><a href=\"http://nightwatchjs.org\" target=\"_blank\" rel=\"noopener\">Nightwatch.js</a>：采用Selenium控制phantomjs浏览器执行e2e测试，安装复杂执行效率低占用资源大，只适合本地开发时跑测试，不适合在服务器端批量高频运行。</li>\n</ul>\n<p><a href=\"http://wuhaolin.cn/2017/06/26/%E5%9F%BA%E4%BA%8EHeadlessChrome%E7%9A%84%E7%BD%91%E9%A1%B5%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E7%BB%9F-FinalTest/\">阅读原文</a></p>\n"},{"title":"流媒体加密","date":"2017-08-01T04:05:30.000Z","url":"https://github.com/gwuhaolin/blog/issues/10","_content":"\n> 本文只讨论应用于浏览器环境的流媒体协议的加密\n\n## 为什么要加密视频\n付费观看视频的模式是很多平台的核心业务，如果视频被录制并非法传播，付费业务将受到严重威胁。因此对视频服务进行加密的技术变得尤为重要。\n\n本文所指的视频加密是为了让要保护的视频不能轻易被下载，即使下载到了也是加密后的内容，其它人解开加密后的内容需要付出非常大的代价。\n\n无法做到严格的让要保护的视频不被录制，原因在于你需要在客户端播放出视频的原内容，解密的流程在客户端的话不法分子就能模拟整个流程，最保守也能用屏幕录制软件录制到视频的原内容(可以通过加水印的方法缓解下)。我们的目标是让他获取原内容的代价更大。\n\n## 常见视频加密技术\n视频加密技术分为两种：\n1. 防盗链：通过验证的用户才能访问到没有加密的视频内容，这种方案存在视频很容易就被下载的风险，严格来说这不属于加密。这种方式其实是资源访问授权，它实现起来简单。\n2. 加密视频本身：通过对称加密算法加密视频内容本身，用户获得加密后的视频内容，通过验证的用户可以获取解密视频的密钥，在客户端解密后播放。这种方式实现起来流程复杂会带来更多的计算量。\n\n一般结合这两种技术一起用，第1种技术很成熟也有很多教程就不再复述，本文主要介绍第2种加密技术。\n\n## 流媒体加密技术原理\n看视频分为两种，看点播和看录播。\n要看点播可以通过下载完整个视频后再看，或者通过流媒体边下边看。\n看直播只能通过流媒体看最新的画面。\n\n加密整个视频的技术很简单，把视频看成一个文件采用加密文件的技术，这种技术太多就不介绍了。\n加密流媒体的技术很少，也很难找到学习资料，本文主要介绍流媒体加密技术。\n\n常见的应用与浏览器播放的流媒体传输协议有：\n- HLS：Apple 推出的基于 HTTP 协议的 MP4 分片传输协议，可用于点播和直播场景。每下载一个分片都需要发生一次 HTTP 请求，所以严格来说 HLS 不能称为流媒体传输协议。\n- HTTP-FLV：基于 HTTP 长连接的 FLV 分块 tag 传输协议，可用于点播和直播场景。\n- RTMP：基于 TCP 的 FLV 分块 message 传输协议，用于 Flash 客户端。\n\n#### 流媒体加密原理\n可以看出一个规律这些流媒体传输协议都必须把视频流拆分成连续的小块之后再被传送，只不过分块的大小和视频容器的格式不一样而已。\n\n**流媒体加密技术的核心就在于对这每一小块视频分别使用对称加密算法，在服务端加密客户端解密，通过权限验证的用户才能拿到解密一小块视频的密钥。**\n\n#### 为什么不用  HTTPS 加密\n可能有人会问为什么不用 HTTPS 加密？原因是 HTTPS 在网络传输层进行非对称加密，目的是为了防止中间人窃听劫持，任何人都可以和我们的服务器建立 HTTPS 链接获取到原数据。而视频加密的目的不是为了防止有中间人窃听我们的视频数据，而是要让视频数据本身被加密。\n\n#### 为什么选择对称加密\n现代成熟的加密技术分为对称加密算法和公钥密码算法(非对称加密)。之所以选择对称加密是因为流媒体要求很强的实时性，数据量又很大。公钥密码算法的计算都比较复杂，效率较低，适合对少量数据进行加密。对称加密效率相对较高，所以流媒体加密首选对称加密。例如在 SSH 登入的时候会先通过公钥密码算法传输一个密钥，再用这个密钥用作对称加密算法的密钥，在数据传输过程中使用对称加密算法来提示数据传输效率。\n\n## HLS 加密\nHLS 是目前最成熟的支持流媒体加密的能应用在浏览器里的流媒体传输协议，HLS 原生支持加密，下面来详细介绍它。\n\n在介绍如何加密 HLS 先了解下 HLS 相比于其它流媒体传输协议的优缺点。\n优点在于：\n- 建立在 HTTP 之上，使用简单，接入代价小。\n- 分片技术有利于 CDN 加速技术的实施。\n- 部分浏览器原生支持，支持点播和录播。\n\n缺点在于：\n- 用作直播时延迟太大。\n- 移动端支持还好，PC端只有 Safari 原生支持。\n\n#### HLS 加密原理\nHLS 由两部分构成，一个是 .m3u8 文件，一个是 .ts 视频文件（TS 是视频文件格式的一种）。整个过程是，浏览器会首先去请求 .m3u8 的索引文件，然后解析 m3u8，找出对应的 .ts 文件链接，并开始下载。\n![hls](https://user-images.githubusercontent.com/5773264/28862374-6f2bcb24-7797-11e7-9671-4a7a471dfb8a.png)\n\nm3u8 文件是一个文本文件，在开启 HLS 加密时，内容大致如下：\n```\n#EXTM3U\n#EXT-X-VERSION:6\n#EXT-X-TARGETDURATION:10\n#EXT-X-MEDIA-SEQUENCE:26\n#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.do?k=1\"\n#EXTINF:9.901,\nhttp://media.example.com/segment26.ts\n#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.do?k=2\"\n#EXTINF:9.501,\nhttp://media.example.com/segment28.ts\n```\n这个文件描述了每个 TS 分片的 URL ，但这些分片都是加密后的内容，要还原出原内容需要从\n```\n#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.do?k=1\"\n```\n中解析出获取解密密钥的URL `https://priv.example.com/key.do` 和对称加密算法 `AES-128` 。\n获取到密钥后再在客户端解密出原内容。\n可以看出启用 HLS 加密后会多出更多的事情：\n- 针对每个 TS 需要去请求获取密钥。\n- 需要多提供一个给客户端获取密钥的鉴权服务。\n- 针对每个 TS 需要去执行对称加密的解密计算。\n\n这会带来更多的网络请求和计算量，可能会对延迟和性能造成一定的不良影响。\n\n#### HLS 加密实战\n支持 HLS 的客户端都原生支持加密，所以要开启 HLS 加密你只需要修改你的服务端：\n- 修改 HLS 视频服务，对 TS 加密，往 m3u8 中加入 `EXT-X-KEY` 字段。\n- 提供给客户端获取密钥的鉴权服务，即上面的 `https://priv.example.com/key.do?k=1` 所指向的服务。\n\n目前大多数云服务都支持 HLS 加密服务，如果你想直接搭建 HLS 加密服务可以使用 [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module/wiki/Directives#hls_keys)。\n\n#### HLS 兼容方案\n目前 HLS 存在兼容性问题：\n- 针对桌面端低版本浏览器例如 IE，可以使用 Flash 技术来播放 HLS ，详细使用见开源项目 [flashls](https://github.com/mangui/flashls)。\n- 针对非Safari高版本浏览器例如 Chrome ，可以使用 Media Source Extensions API 去实现播放  HLS，详细使用见开源项目 [hls.js](https://github.com/video-dev/hls.js)。\n- 针对即不原生支持 HLS又不支持 Media Source Extensions 也不支持 Flash 的浏览器，常见于部分低版本移动端浏览器，我也找不到什么好办法。\n\nflashls 和 hls.js 都支持 HLS 加密技术。\n\n#### 破解 HLS 加密\n有加密就有破解，在明白 HLS 加密原理后，你想过如何去破解它吗？先定义下破解成功是指：获取到视频加密前的完整原文件。我想到的方法是：\n1. 先付费买一个可正常观看受保护视频的账号。\n2. 用抓包工具抓下所有网络请求(可以筛选下限制到只保存 HLS 和 获取key 的请求，防止保存太多垃圾数据)。\n3. 第2步保存下来了加密后的 TS 分片和加密分片所需要的密钥。\n4. 写一个脚本以 m3u8 为索引一一解密出加密后的 TS 分片的原文件，再把 TS 拼接成完整的视频原文件。\n\n似乎破解的难度也不会很复杂。\n\n## 总结\n目前流媒体加密技术还不成熟，除了 HLS 协议提供了方便成熟的方案外，其它协议的加密技术还不成熟。\n\nRTMP 协议提供了一个变种版 RTMPE 可以加密流媒体，原理和 HLS 加密类似，但是我还找不到合适的服务端去支持 RTMPE 协议。\n\n[阅读原文](http://wuhaolin.cn/2017/08/01/%E6%B5%81%E5%AA%92%E4%BD%93%E5%8A%A0%E5%AF%86/)","source":"_posts/流媒体加密.md","raw":"---\ntitle: 流媒体加密\ndate: 2017-08-01T12:05:30Z\nurl: https://github.com/gwuhaolin/blog/issues/10\ntags:\n    - 音视频\n---\n\n> 本文只讨论应用于浏览器环境的流媒体协议的加密\n\n## 为什么要加密视频\n付费观看视频的模式是很多平台的核心业务，如果视频被录制并非法传播，付费业务将受到严重威胁。因此对视频服务进行加密的技术变得尤为重要。\n\n本文所指的视频加密是为了让要保护的视频不能轻易被下载，即使下载到了也是加密后的内容，其它人解开加密后的内容需要付出非常大的代价。\n\n无法做到严格的让要保护的视频不被录制，原因在于你需要在客户端播放出视频的原内容，解密的流程在客户端的话不法分子就能模拟整个流程，最保守也能用屏幕录制软件录制到视频的原内容(可以通过加水印的方法缓解下)。我们的目标是让他获取原内容的代价更大。\n\n## 常见视频加密技术\n视频加密技术分为两种：\n1. 防盗链：通过验证的用户才能访问到没有加密的视频内容，这种方案存在视频很容易就被下载的风险，严格来说这不属于加密。这种方式其实是资源访问授权，它实现起来简单。\n2. 加密视频本身：通过对称加密算法加密视频内容本身，用户获得加密后的视频内容，通过验证的用户可以获取解密视频的密钥，在客户端解密后播放。这种方式实现起来流程复杂会带来更多的计算量。\n\n一般结合这两种技术一起用，第1种技术很成熟也有很多教程就不再复述，本文主要介绍第2种加密技术。\n\n## 流媒体加密技术原理\n看视频分为两种，看点播和看录播。\n要看点播可以通过下载完整个视频后再看，或者通过流媒体边下边看。\n看直播只能通过流媒体看最新的画面。\n\n加密整个视频的技术很简单，把视频看成一个文件采用加密文件的技术，这种技术太多就不介绍了。\n加密流媒体的技术很少，也很难找到学习资料，本文主要介绍流媒体加密技术。\n\n常见的应用与浏览器播放的流媒体传输协议有：\n- HLS：Apple 推出的基于 HTTP 协议的 MP4 分片传输协议，可用于点播和直播场景。每下载一个分片都需要发生一次 HTTP 请求，所以严格来说 HLS 不能称为流媒体传输协议。\n- HTTP-FLV：基于 HTTP 长连接的 FLV 分块 tag 传输协议，可用于点播和直播场景。\n- RTMP：基于 TCP 的 FLV 分块 message 传输协议，用于 Flash 客户端。\n\n#### 流媒体加密原理\n可以看出一个规律这些流媒体传输协议都必须把视频流拆分成连续的小块之后再被传送，只不过分块的大小和视频容器的格式不一样而已。\n\n**流媒体加密技术的核心就在于对这每一小块视频分别使用对称加密算法，在服务端加密客户端解密，通过权限验证的用户才能拿到解密一小块视频的密钥。**\n\n#### 为什么不用  HTTPS 加密\n可能有人会问为什么不用 HTTPS 加密？原因是 HTTPS 在网络传输层进行非对称加密，目的是为了防止中间人窃听劫持，任何人都可以和我们的服务器建立 HTTPS 链接获取到原数据。而视频加密的目的不是为了防止有中间人窃听我们的视频数据，而是要让视频数据本身被加密。\n\n#### 为什么选择对称加密\n现代成熟的加密技术分为对称加密算法和公钥密码算法(非对称加密)。之所以选择对称加密是因为流媒体要求很强的实时性，数据量又很大。公钥密码算法的计算都比较复杂，效率较低，适合对少量数据进行加密。对称加密效率相对较高，所以流媒体加密首选对称加密。例如在 SSH 登入的时候会先通过公钥密码算法传输一个密钥，再用这个密钥用作对称加密算法的密钥，在数据传输过程中使用对称加密算法来提示数据传输效率。\n\n## HLS 加密\nHLS 是目前最成熟的支持流媒体加密的能应用在浏览器里的流媒体传输协议，HLS 原生支持加密，下面来详细介绍它。\n\n在介绍如何加密 HLS 先了解下 HLS 相比于其它流媒体传输协议的优缺点。\n优点在于：\n- 建立在 HTTP 之上，使用简单，接入代价小。\n- 分片技术有利于 CDN 加速技术的实施。\n- 部分浏览器原生支持，支持点播和录播。\n\n缺点在于：\n- 用作直播时延迟太大。\n- 移动端支持还好，PC端只有 Safari 原生支持。\n\n#### HLS 加密原理\nHLS 由两部分构成，一个是 .m3u8 文件，一个是 .ts 视频文件（TS 是视频文件格式的一种）。整个过程是，浏览器会首先去请求 .m3u8 的索引文件，然后解析 m3u8，找出对应的 .ts 文件链接，并开始下载。\n![hls](https://user-images.githubusercontent.com/5773264/28862374-6f2bcb24-7797-11e7-9671-4a7a471dfb8a.png)\n\nm3u8 文件是一个文本文件，在开启 HLS 加密时，内容大致如下：\n```\n#EXTM3U\n#EXT-X-VERSION:6\n#EXT-X-TARGETDURATION:10\n#EXT-X-MEDIA-SEQUENCE:26\n#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.do?k=1\"\n#EXTINF:9.901,\nhttp://media.example.com/segment26.ts\n#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.do?k=2\"\n#EXTINF:9.501,\nhttp://media.example.com/segment28.ts\n```\n这个文件描述了每个 TS 分片的 URL ，但这些分片都是加密后的内容，要还原出原内容需要从\n```\n#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.do?k=1\"\n```\n中解析出获取解密密钥的URL `https://priv.example.com/key.do` 和对称加密算法 `AES-128` 。\n获取到密钥后再在客户端解密出原内容。\n可以看出启用 HLS 加密后会多出更多的事情：\n- 针对每个 TS 需要去请求获取密钥。\n- 需要多提供一个给客户端获取密钥的鉴权服务。\n- 针对每个 TS 需要去执行对称加密的解密计算。\n\n这会带来更多的网络请求和计算量，可能会对延迟和性能造成一定的不良影响。\n\n#### HLS 加密实战\n支持 HLS 的客户端都原生支持加密，所以要开启 HLS 加密你只需要修改你的服务端：\n- 修改 HLS 视频服务，对 TS 加密，往 m3u8 中加入 `EXT-X-KEY` 字段。\n- 提供给客户端获取密钥的鉴权服务，即上面的 `https://priv.example.com/key.do?k=1` 所指向的服务。\n\n目前大多数云服务都支持 HLS 加密服务，如果你想直接搭建 HLS 加密服务可以使用 [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module/wiki/Directives#hls_keys)。\n\n#### HLS 兼容方案\n目前 HLS 存在兼容性问题：\n- 针对桌面端低版本浏览器例如 IE，可以使用 Flash 技术来播放 HLS ，详细使用见开源项目 [flashls](https://github.com/mangui/flashls)。\n- 针对非Safari高版本浏览器例如 Chrome ，可以使用 Media Source Extensions API 去实现播放  HLS，详细使用见开源项目 [hls.js](https://github.com/video-dev/hls.js)。\n- 针对即不原生支持 HLS又不支持 Media Source Extensions 也不支持 Flash 的浏览器，常见于部分低版本移动端浏览器，我也找不到什么好办法。\n\nflashls 和 hls.js 都支持 HLS 加密技术。\n\n#### 破解 HLS 加密\n有加密就有破解，在明白 HLS 加密原理后，你想过如何去破解它吗？先定义下破解成功是指：获取到视频加密前的完整原文件。我想到的方法是：\n1. 先付费买一个可正常观看受保护视频的账号。\n2. 用抓包工具抓下所有网络请求(可以筛选下限制到只保存 HLS 和 获取key 的请求，防止保存太多垃圾数据)。\n3. 第2步保存下来了加密后的 TS 分片和加密分片所需要的密钥。\n4. 写一个脚本以 m3u8 为索引一一解密出加密后的 TS 分片的原文件，再把 TS 拼接成完整的视频原文件。\n\n似乎破解的难度也不会很复杂。\n\n## 总结\n目前流媒体加密技术还不成熟，除了 HLS 协议提供了方便成熟的方案外，其它协议的加密技术还不成熟。\n\nRTMP 协议提供了一个变种版 RTMPE 可以加密流媒体，原理和 HLS 加密类似，但是我还找不到合适的服务端去支持 RTMPE 协议。\n\n[阅读原文](http://wuhaolin.cn/2017/08/01/%E6%B5%81%E5%AA%92%E4%BD%93%E5%8A%A0%E5%AF%86/)","slug":"流媒体加密","published":1,"updated":"2018-11-14T04:39:28.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjogs0keh000og5tchwaem1lr","content":"<blockquote>\n<p>本文只讨论应用于浏览器环境的流媒体协议的加密</p>\n</blockquote>\n<h2 id=\"为什么要加密视频\"><a href=\"#为什么要加密视频\" class=\"headerlink\" title=\"为什么要加密视频\"></a>为什么要加密视频</h2><p>付费观看视频的模式是很多平台的核心业务，如果视频被录制并非法传播，付费业务将受到严重威胁。因此对视频服务进行加密的技术变得尤为重要。</p>\n<p>本文所指的视频加密是为了让要保护的视频不能轻易被下载，即使下载到了也是加密后的内容，其它人解开加密后的内容需要付出非常大的代价。</p>\n<p>无法做到严格的让要保护的视频不被录制，原因在于你需要在客户端播放出视频的原内容，解密的流程在客户端的话不法分子就能模拟整个流程，最保守也能用屏幕录制软件录制到视频的原内容(可以通过加水印的方法缓解下)。我们的目标是让他获取原内容的代价更大。</p>\n<h2 id=\"常见视频加密技术\"><a href=\"#常见视频加密技术\" class=\"headerlink\" title=\"常见视频加密技术\"></a>常见视频加密技术</h2><p>视频加密技术分为两种：</p>\n<ol>\n<li>防盗链：通过验证的用户才能访问到没有加密的视频内容，这种方案存在视频很容易就被下载的风险，严格来说这不属于加密。这种方式其实是资源访问授权，它实现起来简单。</li>\n<li>加密视频本身：通过对称加密算法加密视频内容本身，用户获得加密后的视频内容，通过验证的用户可以获取解密视频的密钥，在客户端解密后播放。这种方式实现起来流程复杂会带来更多的计算量。</li>\n</ol>\n<p>一般结合这两种技术一起用，第1种技术很成熟也有很多教程就不再复述，本文主要介绍第2种加密技术。</p>\n<h2 id=\"流媒体加密技术原理\"><a href=\"#流媒体加密技术原理\" class=\"headerlink\" title=\"流媒体加密技术原理\"></a>流媒体加密技术原理</h2><p>看视频分为两种，看点播和看录播。<br>要看点播可以通过下载完整个视频后再看，或者通过流媒体边下边看。<br>看直播只能通过流媒体看最新的画面。</p>\n<p>加密整个视频的技术很简单，把视频看成一个文件采用加密文件的技术，这种技术太多就不介绍了。<br>加密流媒体的技术很少，也很难找到学习资料，本文主要介绍流媒体加密技术。</p>\n<p>常见的应用与浏览器播放的流媒体传输协议有：</p>\n<ul>\n<li>HLS：Apple 推出的基于 HTTP 协议的 MP4 分片传输协议，可用于点播和直播场景。每下载一个分片都需要发生一次 HTTP 请求，所以严格来说 HLS 不能称为流媒体传输协议。</li>\n<li>HTTP-FLV：基于 HTTP 长连接的 FLV 分块 tag 传输协议，可用于点播和直播场景。</li>\n<li>RTMP：基于 TCP 的 FLV 分块 message 传输协议，用于 Flash 客户端。</li>\n</ul>\n<h4 id=\"流媒体加密原理\"><a href=\"#流媒体加密原理\" class=\"headerlink\" title=\"流媒体加密原理\"></a>流媒体加密原理</h4><p>可以看出一个规律这些流媒体传输协议都必须把视频流拆分成连续的小块之后再被传送，只不过分块的大小和视频容器的格式不一样而已。</p>\n<p><strong>流媒体加密技术的核心就在于对这每一小块视频分别使用对称加密算法，在服务端加密客户端解密，通过权限验证的用户才能拿到解密一小块视频的密钥。</strong></p>\n<h4 id=\"为什么不用-HTTPS-加密\"><a href=\"#为什么不用-HTTPS-加密\" class=\"headerlink\" title=\"为什么不用  HTTPS 加密\"></a>为什么不用  HTTPS 加密</h4><p>可能有人会问为什么不用 HTTPS 加密？原因是 HTTPS 在网络传输层进行非对称加密，目的是为了防止中间人窃听劫持，任何人都可以和我们的服务器建立 HTTPS 链接获取到原数据。而视频加密的目的不是为了防止有中间人窃听我们的视频数据，而是要让视频数据本身被加密。</p>\n<h4 id=\"为什么选择对称加密\"><a href=\"#为什么选择对称加密\" class=\"headerlink\" title=\"为什么选择对称加密\"></a>为什么选择对称加密</h4><p>现代成熟的加密技术分为对称加密算法和公钥密码算法(非对称加密)。之所以选择对称加密是因为流媒体要求很强的实时性，数据量又很大。公钥密码算法的计算都比较复杂，效率较低，适合对少量数据进行加密。对称加密效率相对较高，所以流媒体加密首选对称加密。例如在 SSH 登入的时候会先通过公钥密码算法传输一个密钥，再用这个密钥用作对称加密算法的密钥，在数据传输过程中使用对称加密算法来提示数据传输效率。</p>\n<h2 id=\"HLS-加密\"><a href=\"#HLS-加密\" class=\"headerlink\" title=\"HLS 加密\"></a>HLS 加密</h2><p>HLS 是目前最成熟的支持流媒体加密的能应用在浏览器里的流媒体传输协议，HLS 原生支持加密，下面来详细介绍它。</p>\n<p>在介绍如何加密 HLS 先了解下 HLS 相比于其它流媒体传输协议的优缺点。<br>优点在于：</p>\n<ul>\n<li>建立在 HTTP 之上，使用简单，接入代价小。</li>\n<li>分片技术有利于 CDN 加速技术的实施。</li>\n<li>部分浏览器原生支持，支持点播和录播。</li>\n</ul>\n<p>缺点在于：</p>\n<ul>\n<li>用作直播时延迟太大。</li>\n<li>移动端支持还好，PC端只有 Safari 原生支持。</li>\n</ul>\n<h4 id=\"HLS-加密原理\"><a href=\"#HLS-加密原理\" class=\"headerlink\" title=\"HLS 加密原理\"></a>HLS 加密原理</h4><p>HLS 由两部分构成，一个是 .m3u8 文件，一个是 .ts 视频文件（TS 是视频文件格式的一种）。整个过程是，浏览器会首先去请求 .m3u8 的索引文件，然后解析 m3u8，找出对应的 .ts 文件链接，并开始下载。<br><img src=\"https://user-images.githubusercontent.com/5773264/28862374-6f2bcb24-7797-11e7-9671-4a7a471dfb8a.png\" alt=\"hls\"></p>\n<p>m3u8 文件是一个文本文件，在开启 HLS 加密时，内容大致如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#EXTM3U</span><br><span class=\"line\">#EXT-X-VERSION:6</span><br><span class=\"line\">#EXT-X-TARGETDURATION:10</span><br><span class=\"line\">#EXT-X-MEDIA-SEQUENCE:26</span><br><span class=\"line\">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://priv.example.com/key.do?k=1&quot;</span><br><span class=\"line\">#EXTINF:9.901,</span><br><span class=\"line\">http://media.example.com/segment26.ts</span><br><span class=\"line\">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://priv.example.com/key.do?k=2&quot;</span><br><span class=\"line\">#EXTINF:9.501,</span><br><span class=\"line\">http://media.example.com/segment28.ts</span><br></pre></td></tr></table></figure></p>\n<p>这个文件描述了每个 TS 分片的 URL ，但这些分片都是加密后的内容，要还原出原内容需要从<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://priv.example.com/key.do?k=1&quot;</span><br></pre></td></tr></table></figure></p>\n<p>中解析出获取解密密钥的URL <code>https://priv.example.com/key.do</code> 和对称加密算法 <code>AES-128</code> 。<br>获取到密钥后再在客户端解密出原内容。<br>可以看出启用 HLS 加密后会多出更多的事情：</p>\n<ul>\n<li>针对每个 TS 需要去请求获取密钥。</li>\n<li>需要多提供一个给客户端获取密钥的鉴权服务。</li>\n<li>针对每个 TS 需要去执行对称加密的解密计算。</li>\n</ul>\n<p>这会带来更多的网络请求和计算量，可能会对延迟和性能造成一定的不良影响。</p>\n<h4 id=\"HLS-加密实战\"><a href=\"#HLS-加密实战\" class=\"headerlink\" title=\"HLS 加密实战\"></a>HLS 加密实战</h4><p>支持 HLS 的客户端都原生支持加密，所以要开启 HLS 加密你只需要修改你的服务端：</p>\n<ul>\n<li>修改 HLS 视频服务，对 TS 加密，往 m3u8 中加入 <code>EXT-X-KEY</code> 字段。</li>\n<li>提供给客户端获取密钥的鉴权服务，即上面的 <code>https://priv.example.com/key.do?k=1</code> 所指向的服务。</li>\n</ul>\n<p>目前大多数云服务都支持 HLS 加密服务，如果你想直接搭建 HLS 加密服务可以使用 <a href=\"https://github.com/arut/nginx-rtmp-module/wiki/Directives#hls_keys\" target=\"_blank\" rel=\"noopener\">nginx-rtmp-module</a>。</p>\n<h4 id=\"HLS-兼容方案\"><a href=\"#HLS-兼容方案\" class=\"headerlink\" title=\"HLS 兼容方案\"></a>HLS 兼容方案</h4><p>目前 HLS 存在兼容性问题：</p>\n<ul>\n<li>针对桌面端低版本浏览器例如 IE，可以使用 Flash 技术来播放 HLS ，详细使用见开源项目 <a href=\"https://github.com/mangui/flashls\" target=\"_blank\" rel=\"noopener\">flashls</a>。</li>\n<li>针对非Safari高版本浏览器例如 Chrome ，可以使用 Media Source Extensions API 去实现播放  HLS，详细使用见开源项目 <a href=\"https://github.com/video-dev/hls.js\" target=\"_blank\" rel=\"noopener\">hls.js</a>。</li>\n<li>针对即不原生支持 HLS又不支持 Media Source Extensions 也不支持 Flash 的浏览器，常见于部分低版本移动端浏览器，我也找不到什么好办法。</li>\n</ul>\n<p>flashls 和 hls.js 都支持 HLS 加密技术。</p>\n<h4 id=\"破解-HLS-加密\"><a href=\"#破解-HLS-加密\" class=\"headerlink\" title=\"破解 HLS 加密\"></a>破解 HLS 加密</h4><p>有加密就有破解，在明白 HLS 加密原理后，你想过如何去破解它吗？先定义下破解成功是指：获取到视频加密前的完整原文件。我想到的方法是：</p>\n<ol>\n<li>先付费买一个可正常观看受保护视频的账号。</li>\n<li>用抓包工具抓下所有网络请求(可以筛选下限制到只保存 HLS 和 获取key 的请求，防止保存太多垃圾数据)。</li>\n<li>第2步保存下来了加密后的 TS 分片和加密分片所需要的密钥。</li>\n<li>写一个脚本以 m3u8 为索引一一解密出加密后的 TS 分片的原文件，再把 TS 拼接成完整的视频原文件。</li>\n</ol>\n<p>似乎破解的难度也不会很复杂。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>目前流媒体加密技术还不成熟，除了 HLS 协议提供了方便成熟的方案外，其它协议的加密技术还不成熟。</p>\n<p>RTMP 协议提供了一个变种版 RTMPE 可以加密流媒体，原理和 HLS 加密类似，但是我还找不到合适的服务端去支持 RTMPE 协议。</p>\n<p><a href=\"http://wuhaolin.cn/2017/08/01/%E6%B5%81%E5%AA%92%E4%BD%93%E5%8A%A0%E5%AF%86/\">阅读原文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文只讨论应用于浏览器环境的流媒体协议的加密</p>\n</blockquote>\n<h2 id=\"为什么要加密视频\"><a href=\"#为什么要加密视频\" class=\"headerlink\" title=\"为什么要加密视频\"></a>为什么要加密视频</h2><p>付费观看视频的模式是很多平台的核心业务，如果视频被录制并非法传播，付费业务将受到严重威胁。因此对视频服务进行加密的技术变得尤为重要。</p>\n<p>本文所指的视频加密是为了让要保护的视频不能轻易被下载，即使下载到了也是加密后的内容，其它人解开加密后的内容需要付出非常大的代价。</p>\n<p>无法做到严格的让要保护的视频不被录制，原因在于你需要在客户端播放出视频的原内容，解密的流程在客户端的话不法分子就能模拟整个流程，最保守也能用屏幕录制软件录制到视频的原内容(可以通过加水印的方法缓解下)。我们的目标是让他获取原内容的代价更大。</p>\n<h2 id=\"常见视频加密技术\"><a href=\"#常见视频加密技术\" class=\"headerlink\" title=\"常见视频加密技术\"></a>常见视频加密技术</h2><p>视频加密技术分为两种：</p>\n<ol>\n<li>防盗链：通过验证的用户才能访问到没有加密的视频内容，这种方案存在视频很容易就被下载的风险，严格来说这不属于加密。这种方式其实是资源访问授权，它实现起来简单。</li>\n<li>加密视频本身：通过对称加密算法加密视频内容本身，用户获得加密后的视频内容，通过验证的用户可以获取解密视频的密钥，在客户端解密后播放。这种方式实现起来流程复杂会带来更多的计算量。</li>\n</ol>\n<p>一般结合这两种技术一起用，第1种技术很成熟也有很多教程就不再复述，本文主要介绍第2种加密技术。</p>\n<h2 id=\"流媒体加密技术原理\"><a href=\"#流媒体加密技术原理\" class=\"headerlink\" title=\"流媒体加密技术原理\"></a>流媒体加密技术原理</h2><p>看视频分为两种，看点播和看录播。<br>要看点播可以通过下载完整个视频后再看，或者通过流媒体边下边看。<br>看直播只能通过流媒体看最新的画面。</p>\n<p>加密整个视频的技术很简单，把视频看成一个文件采用加密文件的技术，这种技术太多就不介绍了。<br>加密流媒体的技术很少，也很难找到学习资料，本文主要介绍流媒体加密技术。</p>\n<p>常见的应用与浏览器播放的流媒体传输协议有：</p>\n<ul>\n<li>HLS：Apple 推出的基于 HTTP 协议的 MP4 分片传输协议，可用于点播和直播场景。每下载一个分片都需要发生一次 HTTP 请求，所以严格来说 HLS 不能称为流媒体传输协议。</li>\n<li>HTTP-FLV：基于 HTTP 长连接的 FLV 分块 tag 传输协议，可用于点播和直播场景。</li>\n<li>RTMP：基于 TCP 的 FLV 分块 message 传输协议，用于 Flash 客户端。</li>\n</ul>\n<h4 id=\"流媒体加密原理\"><a href=\"#流媒体加密原理\" class=\"headerlink\" title=\"流媒体加密原理\"></a>流媒体加密原理</h4><p>可以看出一个规律这些流媒体传输协议都必须把视频流拆分成连续的小块之后再被传送，只不过分块的大小和视频容器的格式不一样而已。</p>\n<p><strong>流媒体加密技术的核心就在于对这每一小块视频分别使用对称加密算法，在服务端加密客户端解密，通过权限验证的用户才能拿到解密一小块视频的密钥。</strong></p>\n<h4 id=\"为什么不用-HTTPS-加密\"><a href=\"#为什么不用-HTTPS-加密\" class=\"headerlink\" title=\"为什么不用  HTTPS 加密\"></a>为什么不用  HTTPS 加密</h4><p>可能有人会问为什么不用 HTTPS 加密？原因是 HTTPS 在网络传输层进行非对称加密，目的是为了防止中间人窃听劫持，任何人都可以和我们的服务器建立 HTTPS 链接获取到原数据。而视频加密的目的不是为了防止有中间人窃听我们的视频数据，而是要让视频数据本身被加密。</p>\n<h4 id=\"为什么选择对称加密\"><a href=\"#为什么选择对称加密\" class=\"headerlink\" title=\"为什么选择对称加密\"></a>为什么选择对称加密</h4><p>现代成熟的加密技术分为对称加密算法和公钥密码算法(非对称加密)。之所以选择对称加密是因为流媒体要求很强的实时性，数据量又很大。公钥密码算法的计算都比较复杂，效率较低，适合对少量数据进行加密。对称加密效率相对较高，所以流媒体加密首选对称加密。例如在 SSH 登入的时候会先通过公钥密码算法传输一个密钥，再用这个密钥用作对称加密算法的密钥，在数据传输过程中使用对称加密算法来提示数据传输效率。</p>\n<h2 id=\"HLS-加密\"><a href=\"#HLS-加密\" class=\"headerlink\" title=\"HLS 加密\"></a>HLS 加密</h2><p>HLS 是目前最成熟的支持流媒体加密的能应用在浏览器里的流媒体传输协议，HLS 原生支持加密，下面来详细介绍它。</p>\n<p>在介绍如何加密 HLS 先了解下 HLS 相比于其它流媒体传输协议的优缺点。<br>优点在于：</p>\n<ul>\n<li>建立在 HTTP 之上，使用简单，接入代价小。</li>\n<li>分片技术有利于 CDN 加速技术的实施。</li>\n<li>部分浏览器原生支持，支持点播和录播。</li>\n</ul>\n<p>缺点在于：</p>\n<ul>\n<li>用作直播时延迟太大。</li>\n<li>移动端支持还好，PC端只有 Safari 原生支持。</li>\n</ul>\n<h4 id=\"HLS-加密原理\"><a href=\"#HLS-加密原理\" class=\"headerlink\" title=\"HLS 加密原理\"></a>HLS 加密原理</h4><p>HLS 由两部分构成，一个是 .m3u8 文件，一个是 .ts 视频文件（TS 是视频文件格式的一种）。整个过程是，浏览器会首先去请求 .m3u8 的索引文件，然后解析 m3u8，找出对应的 .ts 文件链接，并开始下载。<br><img src=\"https://user-images.githubusercontent.com/5773264/28862374-6f2bcb24-7797-11e7-9671-4a7a471dfb8a.png\" alt=\"hls\"></p>\n<p>m3u8 文件是一个文本文件，在开启 HLS 加密时，内容大致如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#EXTM3U</span><br><span class=\"line\">#EXT-X-VERSION:6</span><br><span class=\"line\">#EXT-X-TARGETDURATION:10</span><br><span class=\"line\">#EXT-X-MEDIA-SEQUENCE:26</span><br><span class=\"line\">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://priv.example.com/key.do?k=1&quot;</span><br><span class=\"line\">#EXTINF:9.901,</span><br><span class=\"line\">http://media.example.com/segment26.ts</span><br><span class=\"line\">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://priv.example.com/key.do?k=2&quot;</span><br><span class=\"line\">#EXTINF:9.501,</span><br><span class=\"line\">http://media.example.com/segment28.ts</span><br></pre></td></tr></table></figure></p>\n<p>这个文件描述了每个 TS 分片的 URL ，但这些分片都是加密后的内容，要还原出原内容需要从<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://priv.example.com/key.do?k=1&quot;</span><br></pre></td></tr></table></figure></p>\n<p>中解析出获取解密密钥的URL <code>https://priv.example.com/key.do</code> 和对称加密算法 <code>AES-128</code> 。<br>获取到密钥后再在客户端解密出原内容。<br>可以看出启用 HLS 加密后会多出更多的事情：</p>\n<ul>\n<li>针对每个 TS 需要去请求获取密钥。</li>\n<li>需要多提供一个给客户端获取密钥的鉴权服务。</li>\n<li>针对每个 TS 需要去执行对称加密的解密计算。</li>\n</ul>\n<p>这会带来更多的网络请求和计算量，可能会对延迟和性能造成一定的不良影响。</p>\n<h4 id=\"HLS-加密实战\"><a href=\"#HLS-加密实战\" class=\"headerlink\" title=\"HLS 加密实战\"></a>HLS 加密实战</h4><p>支持 HLS 的客户端都原生支持加密，所以要开启 HLS 加密你只需要修改你的服务端：</p>\n<ul>\n<li>修改 HLS 视频服务，对 TS 加密，往 m3u8 中加入 <code>EXT-X-KEY</code> 字段。</li>\n<li>提供给客户端获取密钥的鉴权服务，即上面的 <code>https://priv.example.com/key.do?k=1</code> 所指向的服务。</li>\n</ul>\n<p>目前大多数云服务都支持 HLS 加密服务，如果你想直接搭建 HLS 加密服务可以使用 <a href=\"https://github.com/arut/nginx-rtmp-module/wiki/Directives#hls_keys\" target=\"_blank\" rel=\"noopener\">nginx-rtmp-module</a>。</p>\n<h4 id=\"HLS-兼容方案\"><a href=\"#HLS-兼容方案\" class=\"headerlink\" title=\"HLS 兼容方案\"></a>HLS 兼容方案</h4><p>目前 HLS 存在兼容性问题：</p>\n<ul>\n<li>针对桌面端低版本浏览器例如 IE，可以使用 Flash 技术来播放 HLS ，详细使用见开源项目 <a href=\"https://github.com/mangui/flashls\" target=\"_blank\" rel=\"noopener\">flashls</a>。</li>\n<li>针对非Safari高版本浏览器例如 Chrome ，可以使用 Media Source Extensions API 去实现播放  HLS，详细使用见开源项目 <a href=\"https://github.com/video-dev/hls.js\" target=\"_blank\" rel=\"noopener\">hls.js</a>。</li>\n<li>针对即不原生支持 HLS又不支持 Media Source Extensions 也不支持 Flash 的浏览器，常见于部分低版本移动端浏览器，我也找不到什么好办法。</li>\n</ul>\n<p>flashls 和 hls.js 都支持 HLS 加密技术。</p>\n<h4 id=\"破解-HLS-加密\"><a href=\"#破解-HLS-加密\" class=\"headerlink\" title=\"破解 HLS 加密\"></a>破解 HLS 加密</h4><p>有加密就有破解，在明白 HLS 加密原理后，你想过如何去破解它吗？先定义下破解成功是指：获取到视频加密前的完整原文件。我想到的方法是：</p>\n<ol>\n<li>先付费买一个可正常观看受保护视频的账号。</li>\n<li>用抓包工具抓下所有网络请求(可以筛选下限制到只保存 HLS 和 获取key 的请求，防止保存太多垃圾数据)。</li>\n<li>第2步保存下来了加密后的 TS 分片和加密分片所需要的密钥。</li>\n<li>写一个脚本以 m3u8 为索引一一解密出加密后的 TS 分片的原文件，再把 TS 拼接成完整的视频原文件。</li>\n</ol>\n<p>似乎破解的难度也不会很复杂。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>目前流媒体加密技术还不成熟，除了 HLS 协议提供了方便成熟的方案外，其它协议的加密技术还不成熟。</p>\n<p>RTMP 协议提供了一个变种版 RTMPE 可以加密流媒体，原理和 HLS 加密类似，但是我还找不到合适的服务端去支持 RTMPE 协议。</p>\n<p><a href=\"http://wuhaolin.cn/2017/08/01/%E6%B5%81%E5%AA%92%E4%BD%93%E5%8A%A0%E5%AF%86/\">阅读原文</a></p>\n"},{"title":"调试利器-SSH隧道","date":"2017-11-02T21:24:21.000Z","url":"https://github.com/gwuhaolin/blog/issues/11","_content":"\n> 在开发微信公众号或小程序的时候，由于微信平台规则的限制，部分接口需要通过线上域名才能正常访问。但我们一般都会在本地开发，因为这能快速的看到源码修改后的运行结果。但当涉及到需要调用微信接口时，由于不和你在同一个局域网中的用户是无法访问你的本地开发机的，就必须把修改后的代码重新发布到线上域名所在的服务器才能去验证结果。每次修改都重新发布很繁琐也很浪费时间。\n\n本文将教你如何通过 SSH 隧道把本地服务映射到外网，以方便调试，通常把这种方法叫内网穿透。\n\n阅读完本文后，你能解决以下常见问题：\n- 开发微信公众号等应用时把本地服务映射到外网，加速调试流程；\n- 把你正在开发的本地服务分享给互联网上其它人访问体验；\n- 在任何地方通过互联网控制你家中在局域网里的电脑；\n\n## 最终目的\n把运行在本地开发机上的 HTTP 服务映射到外网，让全世界都能通过外网 IP 服务到你本地开发机上的 HTTP 服务。例如你本地的 HTTP 服务监听在 `127.0.0.1:8080`，你有一台公网 IP 为 `12.34.56.78` 的服务器，通过本文介绍的方法，可以让全世界的用户通过 `http://12.34.56.78:8080` 访问到你本地开发机上的 HTTP 服务。\n\n总结成一句话就是：把内网端口映射到外网。\n\n## 前提条件\n为了把内网服务映射到外网，以下资源为必须的：\n1. 一台有外网 IP 的服务器；\n2. 能在本地开发机上通过 `ssh` 登入到外网服务器。\n\n要满足以上条件很简单：\n- 对于条件1：购买一台低配 Linux 服务器，推荐国外的 [DigitalOcean](https://m.do.co/c/a5125bfaad87)；\n- 对于条件2：对于 Mac、Linux 开发机是内置了 ssh 客户端的，对于 Windows 可以安装 [Cygwin](https://www.cygwin.com/)。\n\n## 实现原理\n要实现把内网端口映射到外网，最简单的方式就是通过 SSH 隧道。\n\nSSH 隧道就像一根管道，能把任何2台机器连接在一起，把发送到其中一台机器的数据通过管道传输到另一台机器。假如已经通过 SSH 隧道把本地开发机和外网服务器连接在了一起，外网服务器端监听在 `12.34.56.78:8080`，那么所有发给 `12.34.56.78:8080` 的数据都会通过 SSH 隧道原封不动地传输给本地开发机的 `127.0.0.1:8080`，如图所示：\n\n![SSH隧道](https://user-images.githubusercontent.com/5773264/32361022-caa26dde-c029-11e7-8ac3-eda5c4f75529.png)\n\n也就是说，去访问 `12.34.56.78:8080` 就像是访问本地开发机的 `127.0.0.1:8080`，本地开发机上的 8080 端口被映射到了外网服务器上的 8080 端口。\n\n如果你的外网服务器 IP 配置了域名解析，例如 `yourdomin.com` 会通过 DNS 解析为 `12.34.56.78`，那么也可以通过 `yourdomin.com:8080` 去访问本地开发机上的服务。\n这样就做到了访问外网地址时其实是本地服务返回的结果。\n\n> 通过 SSH 隧道传输数据时，数据会被加密，就算中间被劫持，黑客也无法得到数据的原内容。\n> 所以 SSH 隧道还有一个功能就是保证数据传输的安全性。\n\n## 实现步骤\n把本地开机和外网服务器通过 SSH 隧道连接起来就和在本地开发机 SSH 登入远程登入到外网服务器一样简单。\n\n先来回顾以下 SSH 远程登入命令，假如想在本地远程登入到 `12.34.56.78`，可以在本地开发机上执行以下命令：\n```bash\nssh username@12.34.56.78\n```\n而实现 SSH 隧道只需在本地开发机上执行：\n```bash\nssh -R 8080:127.0.0.1:8080 username@12.34.56.78\n```\n如果想同时映射多个端口则可以执行：\n```bash\nssh username@12.34.56.78 -R 8080:127.0.0.1:8080 -R 8081:127.0.0.1:8081\n```\n\n可以看出实现 SSH 隧道的命令相对于 SSH 登入多出来 `-R 8080:127.0.0.1:8080`，多出的这部分的含义是：\n在远程机器(`12.34.56.78`)上启动 TCP 8080端口监听着，再把远程机器(`12.34.56.78`)上8080端口映射到本地的`127.0.0.1:8080`。\n执行完以上命令后，就可以通过 `12.34.56.78:8080` 去访问本地的 `127.0.0.1:8080` 了。\n\n通常把这种技术叫做 SSH 远程端口转发(remote forwarding)。\n\n其实不限于只能把本地开发机上运行的服务映射到外网服务器上去，还可以把任何本地开发机可以访问的服务映射到外网服务器上去。例如在本地开发机上能访问 `github.com:80`，在本地开发机上执行：\n```bash\nssh -R 8080:github.com:80 username@12.34.56.78\n```\n就能通过 `12.34.56.78:8080` 去访问 `github.com:80` 了。\n\n## 保持运行\n在执行完上面介绍的 SSH 隧道命令后，你会发现登入到了外网服务器上去了，如果你登出外网服务器，就会发现 `12.34.56.78:8080` 无法访问了。导致这个问题的原因是你登出外网服务器时，在外网服务器上本次操作对应的 SSH 进程也跟着退出了，而这个退出的进程曾负责监听在 8080 端口进行转发操作。\n\n为了让 SSH 隧道一直保持在后台执行，有以下方法。\n\n#### 通过 SSH 自带的参数\nSSH 还支持这些参数：\n- N参数：表示只连接远程主机，不打开远程shell；\n- T参数：表示不为这个连接分配TTY；\n- f参数：表示连接成功后，转入后台运行；\n\n因此要让 SSH 隧道一直保持在后台执行，可以通过以下命令：\n```bash\nssh -NTf -R 8080:127.0.0.1:8080 username@12.34.56.78\n```\n\n#### 通过 [AutoSSH](http://www.harding.motd.ca/autossh/)\nSSH 隧道是不稳定的，在网络恶劣的情况下可能随时断开。如果断开就需要手动去本地开发机再次向外网服务器发起连接。\nAutoSSH 能让 SSH 隧道一直保持执行，他会启动一个 SSH 进程，并监控该进程的健康状况；当 SSH 进程崩溃或停止通信时，AutoSSH 将重启动 SSH 进程。\n\n使用AutoSSH 只需在本地开发机上安装 AutoSSH ，方法如下：\n- Mac 系统：`brew install autossh`；\n- Linux 系统：`apt-get install autossh`；\n\n安装成功后，在本地开发机上执行：\n```bash\nautossh -N -R 8080:127.0.0.1:8080 username@12.34.56.78\n```\n就能完成和上面一样的效果，但本方法能保持 SSH 隧道一直运行。\n可以看出这行命令和上面的区别在于把 `ssh` 换成了 `autossh`，并且少了 `-f` 参数，原因是 autossh 默认会转入后台运行。\n\n## 常见问题\n如果你遇到通过以上方法成功启动 SSH 隧道后，还是无法访问 `12.34.56.78:8080`，那么很有可能是外网服务器上的 SSH 没有配置对。为此你需要去外网服务器上修改  `/etc/ssh/sshd_config` 文件如下：\n```\nGatewayPorts yes\n```\n这个选项的意思是，SSH 隧道监听的服务的 IP 是对外开放的 0.0.0.0，而不是只对本机的 127.0.0.1。不开 GatewayPorts 的后果是不能通过 `12.34.56.78:8080` 访问，只能在外网服务器上通过 `127.0.0.1:8080` 服务到本地开发机的服务。\n\n修改好配置文件后，你还需要重启 sshd 服务来加载新的配置，命令如下：\n```bash\nservice sshd restart\n```\n\n如果使用以上方法还是无法访问 `12.34.56.78:8080`，请检查你外网服务器的防火墙配置，确保 8080 端口是对外开放的。\n\n\n## 其它代替方案\n除了 SSH 隧道能实现内网穿透外，还有以下常用方法。\n\n#### [frp](https://github.com/fatedier/frp/blob/master/README_zh.md)\nfrp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。\nfrp 有以下特性：\n- frp 比 SSH 隧道功能更多，配置项更多；\n- frp 也需要一台外网服务器，并且需要在外网服务器上安装 frps，在本地开发机上安装 frpc；\n\n#### [ngrok](https://ngrok.com)\nngrok 是一个商用的内网穿透工具，它有以下特点：\n- 不需要有外网服务器，因为 ngrok 会为你提供；\n- 只需要在本地开发机安装 ngrok 客户端，和注册 ngrok 账户；\n- 按照服务收费；\n\n这些代替方案的缺点在于都需要再额外安装其它工具，没有 SSH 隧道来的直接。\n想了解更多可以访问它们的主页。\n\n[阅读原文](http://wuhaolin.cn/2017/11/03/%E8%B0%83%E8%AF%95%E5%88%A9%E5%99%A8-SSH%E9%9A%A7%E9%81%93/)","source":"_posts/调试利器-SSH隧道.md","raw":"---\ntitle: 调试利器-SSH隧道\ndate: 2017-11-03T05:24:21Z\nurl: https://github.com/gwuhaolin/blog/issues/11\ntags:\n    - 网络\n---\n\n> 在开发微信公众号或小程序的时候，由于微信平台规则的限制，部分接口需要通过线上域名才能正常访问。但我们一般都会在本地开发，因为这能快速的看到源码修改后的运行结果。但当涉及到需要调用微信接口时，由于不和你在同一个局域网中的用户是无法访问你的本地开发机的，就必须把修改后的代码重新发布到线上域名所在的服务器才能去验证结果。每次修改都重新发布很繁琐也很浪费时间。\n\n本文将教你如何通过 SSH 隧道把本地服务映射到外网，以方便调试，通常把这种方法叫内网穿透。\n\n阅读完本文后，你能解决以下常见问题：\n- 开发微信公众号等应用时把本地服务映射到外网，加速调试流程；\n- 把你正在开发的本地服务分享给互联网上其它人访问体验；\n- 在任何地方通过互联网控制你家中在局域网里的电脑；\n\n## 最终目的\n把运行在本地开发机上的 HTTP 服务映射到外网，让全世界都能通过外网 IP 服务到你本地开发机上的 HTTP 服务。例如你本地的 HTTP 服务监听在 `127.0.0.1:8080`，你有一台公网 IP 为 `12.34.56.78` 的服务器，通过本文介绍的方法，可以让全世界的用户通过 `http://12.34.56.78:8080` 访问到你本地开发机上的 HTTP 服务。\n\n总结成一句话就是：把内网端口映射到外网。\n\n## 前提条件\n为了把内网服务映射到外网，以下资源为必须的：\n1. 一台有外网 IP 的服务器；\n2. 能在本地开发机上通过 `ssh` 登入到外网服务器。\n\n要满足以上条件很简单：\n- 对于条件1：购买一台低配 Linux 服务器，推荐国外的 [DigitalOcean](https://m.do.co/c/a5125bfaad87)；\n- 对于条件2：对于 Mac、Linux 开发机是内置了 ssh 客户端的，对于 Windows 可以安装 [Cygwin](https://www.cygwin.com/)。\n\n## 实现原理\n要实现把内网端口映射到外网，最简单的方式就是通过 SSH 隧道。\n\nSSH 隧道就像一根管道，能把任何2台机器连接在一起，把发送到其中一台机器的数据通过管道传输到另一台机器。假如已经通过 SSH 隧道把本地开发机和外网服务器连接在了一起，外网服务器端监听在 `12.34.56.78:8080`，那么所有发给 `12.34.56.78:8080` 的数据都会通过 SSH 隧道原封不动地传输给本地开发机的 `127.0.0.1:8080`，如图所示：\n\n![SSH隧道](https://user-images.githubusercontent.com/5773264/32361022-caa26dde-c029-11e7-8ac3-eda5c4f75529.png)\n\n也就是说，去访问 `12.34.56.78:8080` 就像是访问本地开发机的 `127.0.0.1:8080`，本地开发机上的 8080 端口被映射到了外网服务器上的 8080 端口。\n\n如果你的外网服务器 IP 配置了域名解析，例如 `yourdomin.com` 会通过 DNS 解析为 `12.34.56.78`，那么也可以通过 `yourdomin.com:8080` 去访问本地开发机上的服务。\n这样就做到了访问外网地址时其实是本地服务返回的结果。\n\n> 通过 SSH 隧道传输数据时，数据会被加密，就算中间被劫持，黑客也无法得到数据的原内容。\n> 所以 SSH 隧道还有一个功能就是保证数据传输的安全性。\n\n## 实现步骤\n把本地开机和外网服务器通过 SSH 隧道连接起来就和在本地开发机 SSH 登入远程登入到外网服务器一样简单。\n\n先来回顾以下 SSH 远程登入命令，假如想在本地远程登入到 `12.34.56.78`，可以在本地开发机上执行以下命令：\n```bash\nssh username@12.34.56.78\n```\n而实现 SSH 隧道只需在本地开发机上执行：\n```bash\nssh -R 8080:127.0.0.1:8080 username@12.34.56.78\n```\n如果想同时映射多个端口则可以执行：\n```bash\nssh username@12.34.56.78 -R 8080:127.0.0.1:8080 -R 8081:127.0.0.1:8081\n```\n\n可以看出实现 SSH 隧道的命令相对于 SSH 登入多出来 `-R 8080:127.0.0.1:8080`，多出的这部分的含义是：\n在远程机器(`12.34.56.78`)上启动 TCP 8080端口监听着，再把远程机器(`12.34.56.78`)上8080端口映射到本地的`127.0.0.1:8080`。\n执行完以上命令后，就可以通过 `12.34.56.78:8080` 去访问本地的 `127.0.0.1:8080` 了。\n\n通常把这种技术叫做 SSH 远程端口转发(remote forwarding)。\n\n其实不限于只能把本地开发机上运行的服务映射到外网服务器上去，还可以把任何本地开发机可以访问的服务映射到外网服务器上去。例如在本地开发机上能访问 `github.com:80`，在本地开发机上执行：\n```bash\nssh -R 8080:github.com:80 username@12.34.56.78\n```\n就能通过 `12.34.56.78:8080` 去访问 `github.com:80` 了。\n\n## 保持运行\n在执行完上面介绍的 SSH 隧道命令后，你会发现登入到了外网服务器上去了，如果你登出外网服务器，就会发现 `12.34.56.78:8080` 无法访问了。导致这个问题的原因是你登出外网服务器时，在外网服务器上本次操作对应的 SSH 进程也跟着退出了，而这个退出的进程曾负责监听在 8080 端口进行转发操作。\n\n为了让 SSH 隧道一直保持在后台执行，有以下方法。\n\n#### 通过 SSH 自带的参数\nSSH 还支持这些参数：\n- N参数：表示只连接远程主机，不打开远程shell；\n- T参数：表示不为这个连接分配TTY；\n- f参数：表示连接成功后，转入后台运行；\n\n因此要让 SSH 隧道一直保持在后台执行，可以通过以下命令：\n```bash\nssh -NTf -R 8080:127.0.0.1:8080 username@12.34.56.78\n```\n\n#### 通过 [AutoSSH](http://www.harding.motd.ca/autossh/)\nSSH 隧道是不稳定的，在网络恶劣的情况下可能随时断开。如果断开就需要手动去本地开发机再次向外网服务器发起连接。\nAutoSSH 能让 SSH 隧道一直保持执行，他会启动一个 SSH 进程，并监控该进程的健康状况；当 SSH 进程崩溃或停止通信时，AutoSSH 将重启动 SSH 进程。\n\n使用AutoSSH 只需在本地开发机上安装 AutoSSH ，方法如下：\n- Mac 系统：`brew install autossh`；\n- Linux 系统：`apt-get install autossh`；\n\n安装成功后，在本地开发机上执行：\n```bash\nautossh -N -R 8080:127.0.0.1:8080 username@12.34.56.78\n```\n就能完成和上面一样的效果，但本方法能保持 SSH 隧道一直运行。\n可以看出这行命令和上面的区别在于把 `ssh` 换成了 `autossh`，并且少了 `-f` 参数，原因是 autossh 默认会转入后台运行。\n\n## 常见问题\n如果你遇到通过以上方法成功启动 SSH 隧道后，还是无法访问 `12.34.56.78:8080`，那么很有可能是外网服务器上的 SSH 没有配置对。为此你需要去外网服务器上修改  `/etc/ssh/sshd_config` 文件如下：\n```\nGatewayPorts yes\n```\n这个选项的意思是，SSH 隧道监听的服务的 IP 是对外开放的 0.0.0.0，而不是只对本机的 127.0.0.1。不开 GatewayPorts 的后果是不能通过 `12.34.56.78:8080` 访问，只能在外网服务器上通过 `127.0.0.1:8080` 服务到本地开发机的服务。\n\n修改好配置文件后，你还需要重启 sshd 服务来加载新的配置，命令如下：\n```bash\nservice sshd restart\n```\n\n如果使用以上方法还是无法访问 `12.34.56.78:8080`，请检查你外网服务器的防火墙配置，确保 8080 端口是对外开放的。\n\n\n## 其它代替方案\n除了 SSH 隧道能实现内网穿透外，还有以下常用方法。\n\n#### [frp](https://github.com/fatedier/frp/blob/master/README_zh.md)\nfrp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。\nfrp 有以下特性：\n- frp 比 SSH 隧道功能更多，配置项更多；\n- frp 也需要一台外网服务器，并且需要在外网服务器上安装 frps，在本地开发机上安装 frpc；\n\n#### [ngrok](https://ngrok.com)\nngrok 是一个商用的内网穿透工具，它有以下特点：\n- 不需要有外网服务器，因为 ngrok 会为你提供；\n- 只需要在本地开发机安装 ngrok 客户端，和注册 ngrok 账户；\n- 按照服务收费；\n\n这些代替方案的缺点在于都需要再额外安装其它工具，没有 SSH 隧道来的直接。\n想了解更多可以访问它们的主页。\n\n[阅读原文](http://wuhaolin.cn/2017/11/03/%E8%B0%83%E8%AF%95%E5%88%A9%E5%99%A8-SSH%E9%9A%A7%E9%81%93/)","slug":"调试利器-SSH隧道","published":1,"updated":"2018-11-14T04:39:28.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjogs0kff0010g5tcsbsgsv0r","content":"<blockquote>\n<p>在开发微信公众号或小程序的时候，由于微信平台规则的限制，部分接口需要通过线上域名才能正常访问。但我们一般都会在本地开发，因为这能快速的看到源码修改后的运行结果。但当涉及到需要调用微信接口时，由于不和你在同一个局域网中的用户是无法访问你的本地开发机的，就必须把修改后的代码重新发布到线上域名所在的服务器才能去验证结果。每次修改都重新发布很繁琐也很浪费时间。</p>\n</blockquote>\n<p>本文将教你如何通过 SSH 隧道把本地服务映射到外网，以方便调试，通常把这种方法叫内网穿透。</p>\n<p>阅读完本文后，你能解决以下常见问题：</p>\n<ul>\n<li>开发微信公众号等应用时把本地服务映射到外网，加速调试流程；</li>\n<li>把你正在开发的本地服务分享给互联网上其它人访问体验；</li>\n<li>在任何地方通过互联网控制你家中在局域网里的电脑；</li>\n</ul>\n<h2 id=\"最终目的\"><a href=\"#最终目的\" class=\"headerlink\" title=\"最终目的\"></a>最终目的</h2><p>把运行在本地开发机上的 HTTP 服务映射到外网，让全世界都能通过外网 IP 服务到你本地开发机上的 HTTP 服务。例如你本地的 HTTP 服务监听在 <code>127.0.0.1:8080</code>，你有一台公网 IP 为 <code>12.34.56.78</code> 的服务器，通过本文介绍的方法，可以让全世界的用户通过 <code>http://12.34.56.78:8080</code> 访问到你本地开发机上的 HTTP 服务。</p>\n<p>总结成一句话就是：把内网端口映射到外网。</p>\n<h2 id=\"前提条件\"><a href=\"#前提条件\" class=\"headerlink\" title=\"前提条件\"></a>前提条件</h2><p>为了把内网服务映射到外网，以下资源为必须的：</p>\n<ol>\n<li>一台有外网 IP 的服务器；</li>\n<li>能在本地开发机上通过 <code>ssh</code> 登入到外网服务器。</li>\n</ol>\n<p>要满足以上条件很简单：</p>\n<ul>\n<li>对于条件1：购买一台低配 Linux 服务器，推荐国外的 <a href=\"https://m.do.co/c/a5125bfaad87\" target=\"_blank\" rel=\"noopener\">DigitalOcean</a>；</li>\n<li>对于条件2：对于 Mac、Linux 开发机是内置了 ssh 客户端的，对于 Windows 可以安装 <a href=\"https://www.cygwin.com/\" target=\"_blank\" rel=\"noopener\">Cygwin</a>。</li>\n</ul>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><p>要实现把内网端口映射到外网，最简单的方式就是通过 SSH 隧道。</p>\n<p>SSH 隧道就像一根管道，能把任何2台机器连接在一起，把发送到其中一台机器的数据通过管道传输到另一台机器。假如已经通过 SSH 隧道把本地开发机和外网服务器连接在了一起，外网服务器端监听在 <code>12.34.56.78:8080</code>，那么所有发给 <code>12.34.56.78:8080</code> 的数据都会通过 SSH 隧道原封不动地传输给本地开发机的 <code>127.0.0.1:8080</code>，如图所示：</p>\n<p><img src=\"https://user-images.githubusercontent.com/5773264/32361022-caa26dde-c029-11e7-8ac3-eda5c4f75529.png\" alt=\"SSH隧道\"></p>\n<p>也就是说，去访问 <code>12.34.56.78:8080</code> 就像是访问本地开发机的 <code>127.0.0.1:8080</code>，本地开发机上的 8080 端口被映射到了外网服务器上的 8080 端口。</p>\n<p>如果你的外网服务器 IP 配置了域名解析，例如 <code>yourdomin.com</code> 会通过 DNS 解析为 <code>12.34.56.78</code>，那么也可以通过 <code>yourdomin.com:8080</code> 去访问本地开发机上的服务。<br>这样就做到了访问外网地址时其实是本地服务返回的结果。</p>\n<blockquote>\n<p>通过 SSH 隧道传输数据时，数据会被加密，就算中间被劫持，黑客也无法得到数据的原内容。<br>所以 SSH 隧道还有一个功能就是保证数据传输的安全性。</p>\n</blockquote>\n<h2 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><p>把本地开机和外网服务器通过 SSH 隧道连接起来就和在本地开发机 SSH 登入远程登入到外网服务器一样简单。</p>\n<p>先来回顾以下 SSH 远程登入命令，假如想在本地远程登入到 <code>12.34.56.78</code>，可以在本地开发机上执行以下命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh username@12.34.56.78</span><br></pre></td></tr></table></figure></p>\n<p>而实现 SSH 隧道只需在本地开发机上执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -R 8080:127.0.0.1:8080 username@12.34.56.78</span><br></pre></td></tr></table></figure></p>\n<p>如果想同时映射多个端口则可以执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh username@12.34.56.78 -R 8080:127.0.0.1:8080 -R 8081:127.0.0.1:8081</span><br></pre></td></tr></table></figure></p>\n<p>可以看出实现 SSH 隧道的命令相对于 SSH 登入多出来 <code>-R 8080:127.0.0.1:8080</code>，多出的这部分的含义是：<br>在远程机器(<code>12.34.56.78</code>)上启动 TCP 8080端口监听着，再把远程机器(<code>12.34.56.78</code>)上8080端口映射到本地的<code>127.0.0.1:8080</code>。<br>执行完以上命令后，就可以通过 <code>12.34.56.78:8080</code> 去访问本地的 <code>127.0.0.1:8080</code> 了。</p>\n<p>通常把这种技术叫做 SSH 远程端口转发(remote forwarding)。</p>\n<p>其实不限于只能把本地开发机上运行的服务映射到外网服务器上去，还可以把任何本地开发机可以访问的服务映射到外网服务器上去。例如在本地开发机上能访问 <code>github.com:80</code>，在本地开发机上执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -R 8080:github.com:80 username@12.34.56.78</span><br></pre></td></tr></table></figure></p>\n<p>就能通过 <code>12.34.56.78:8080</code> 去访问 <code>github.com:80</code> 了。</p>\n<h2 id=\"保持运行\"><a href=\"#保持运行\" class=\"headerlink\" title=\"保持运行\"></a>保持运行</h2><p>在执行完上面介绍的 SSH 隧道命令后，你会发现登入到了外网服务器上去了，如果你登出外网服务器，就会发现 <code>12.34.56.78:8080</code> 无法访问了。导致这个问题的原因是你登出外网服务器时，在外网服务器上本次操作对应的 SSH 进程也跟着退出了，而这个退出的进程曾负责监听在 8080 端口进行转发操作。</p>\n<p>为了让 SSH 隧道一直保持在后台执行，有以下方法。</p>\n<h4 id=\"通过-SSH-自带的参数\"><a href=\"#通过-SSH-自带的参数\" class=\"headerlink\" title=\"通过 SSH 自带的参数\"></a>通过 SSH 自带的参数</h4><p>SSH 还支持这些参数：</p>\n<ul>\n<li>N参数：表示只连接远程主机，不打开远程shell；</li>\n<li>T参数：表示不为这个连接分配TTY；</li>\n<li>f参数：表示连接成功后，转入后台运行；</li>\n</ul>\n<p>因此要让 SSH 隧道一直保持在后台执行，可以通过以下命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -NTf -R 8080:127.0.0.1:8080 username@12.34.56.78</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"通过-AutoSSH\"><a href=\"#通过-AutoSSH\" class=\"headerlink\" title=\"通过 AutoSSH\"></a>通过 <a href=\"http://www.harding.motd.ca/autossh/\" target=\"_blank\" rel=\"noopener\">AutoSSH</a></h4><p>SSH 隧道是不稳定的，在网络恶劣的情况下可能随时断开。如果断开就需要手动去本地开发机再次向外网服务器发起连接。<br>AutoSSH 能让 SSH 隧道一直保持执行，他会启动一个 SSH 进程，并监控该进程的健康状况；当 SSH 进程崩溃或停止通信时，AutoSSH 将重启动 SSH 进程。</p>\n<p>使用AutoSSH 只需在本地开发机上安装 AutoSSH ，方法如下：</p>\n<ul>\n<li>Mac 系统：<code>brew install autossh</code>；</li>\n<li>Linux 系统：<code>apt-get install autossh</code>；</li>\n</ul>\n<p>安装成功后，在本地开发机上执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">autossh -N -R 8080:127.0.0.1:8080 username@12.34.56.78</span><br></pre></td></tr></table></figure></p>\n<p>就能完成和上面一样的效果，但本方法能保持 SSH 隧道一直运行。<br>可以看出这行命令和上面的区别在于把 <code>ssh</code> 换成了 <code>autossh</code>，并且少了 <code>-f</code> 参数，原因是 autossh 默认会转入后台运行。</p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><p>如果你遇到通过以上方法成功启动 SSH 隧道后，还是无法访问 <code>12.34.56.78:8080</code>，那么很有可能是外网服务器上的 SSH 没有配置对。为此你需要去外网服务器上修改  <code>/etc/ssh/sshd_config</code> 文件如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GatewayPorts yes</span><br></pre></td></tr></table></figure></p>\n<p>这个选项的意思是，SSH 隧道监听的服务的 IP 是对外开放的 0.0.0.0，而不是只对本机的 127.0.0.1。不开 GatewayPorts 的后果是不能通过 <code>12.34.56.78:8080</code> 访问，只能在外网服务器上通过 <code>127.0.0.1:8080</code> 服务到本地开发机的服务。</p>\n<p>修改好配置文件后，你还需要重启 sshd 服务来加载新的配置，命令如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service sshd restart</span><br></pre></td></tr></table></figure></p>\n<p>如果使用以上方法还是无法访问 <code>12.34.56.78:8080</code>，请检查你外网服务器的防火墙配置，确保 8080 端口是对外开放的。</p>\n<h2 id=\"其它代替方案\"><a href=\"#其它代替方案\" class=\"headerlink\" title=\"其它代替方案\"></a>其它代替方案</h2><p>除了 SSH 隧道能实现内网穿透外，还有以下常用方法。</p>\n<h4 id=\"frp\"><a href=\"#frp\" class=\"headerlink\" title=\"frp\"></a><a href=\"https://github.com/fatedier/frp/blob/master/README_zh.md\" target=\"_blank\" rel=\"noopener\">frp</a></h4><p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。<br>frp 有以下特性：</p>\n<ul>\n<li>frp 比 SSH 隧道功能更多，配置项更多；</li>\n<li>frp 也需要一台外网服务器，并且需要在外网服务器上安装 frps，在本地开发机上安装 frpc；</li>\n</ul>\n<h4 id=\"ngrok\"><a href=\"#ngrok\" class=\"headerlink\" title=\"ngrok\"></a><a href=\"https://ngrok.com\" target=\"_blank\" rel=\"noopener\">ngrok</a></h4><p>ngrok 是一个商用的内网穿透工具，它有以下特点：</p>\n<ul>\n<li>不需要有外网服务器，因为 ngrok 会为你提供；</li>\n<li>只需要在本地开发机安装 ngrok 客户端，和注册 ngrok 账户；</li>\n<li>按照服务收费；</li>\n</ul>\n<p>这些代替方案的缺点在于都需要再额外安装其它工具，没有 SSH 隧道来的直接。<br>想了解更多可以访问它们的主页。</p>\n<p><a href=\"http://wuhaolin.cn/2017/11/03/%E8%B0%83%E8%AF%95%E5%88%A9%E5%99%A8-SSH%E9%9A%A7%E9%81%93/\">阅读原文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在开发微信公众号或小程序的时候，由于微信平台规则的限制，部分接口需要通过线上域名才能正常访问。但我们一般都会在本地开发，因为这能快速的看到源码修改后的运行结果。但当涉及到需要调用微信接口时，由于不和你在同一个局域网中的用户是无法访问你的本地开发机的，就必须把修改后的代码重新发布到线上域名所在的服务器才能去验证结果。每次修改都重新发布很繁琐也很浪费时间。</p>\n</blockquote>\n<p>本文将教你如何通过 SSH 隧道把本地服务映射到外网，以方便调试，通常把这种方法叫内网穿透。</p>\n<p>阅读完本文后，你能解决以下常见问题：</p>\n<ul>\n<li>开发微信公众号等应用时把本地服务映射到外网，加速调试流程；</li>\n<li>把你正在开发的本地服务分享给互联网上其它人访问体验；</li>\n<li>在任何地方通过互联网控制你家中在局域网里的电脑；</li>\n</ul>\n<h2 id=\"最终目的\"><a href=\"#最终目的\" class=\"headerlink\" title=\"最终目的\"></a>最终目的</h2><p>把运行在本地开发机上的 HTTP 服务映射到外网，让全世界都能通过外网 IP 服务到你本地开发机上的 HTTP 服务。例如你本地的 HTTP 服务监听在 <code>127.0.0.1:8080</code>，你有一台公网 IP 为 <code>12.34.56.78</code> 的服务器，通过本文介绍的方法，可以让全世界的用户通过 <code>http://12.34.56.78:8080</code> 访问到你本地开发机上的 HTTP 服务。</p>\n<p>总结成一句话就是：把内网端口映射到外网。</p>\n<h2 id=\"前提条件\"><a href=\"#前提条件\" class=\"headerlink\" title=\"前提条件\"></a>前提条件</h2><p>为了把内网服务映射到外网，以下资源为必须的：</p>\n<ol>\n<li>一台有外网 IP 的服务器；</li>\n<li>能在本地开发机上通过 <code>ssh</code> 登入到外网服务器。</li>\n</ol>\n<p>要满足以上条件很简单：</p>\n<ul>\n<li>对于条件1：购买一台低配 Linux 服务器，推荐国外的 <a href=\"https://m.do.co/c/a5125bfaad87\" target=\"_blank\" rel=\"noopener\">DigitalOcean</a>；</li>\n<li>对于条件2：对于 Mac、Linux 开发机是内置了 ssh 客户端的，对于 Windows 可以安装 <a href=\"https://www.cygwin.com/\" target=\"_blank\" rel=\"noopener\">Cygwin</a>。</li>\n</ul>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><p>要实现把内网端口映射到外网，最简单的方式就是通过 SSH 隧道。</p>\n<p>SSH 隧道就像一根管道，能把任何2台机器连接在一起，把发送到其中一台机器的数据通过管道传输到另一台机器。假如已经通过 SSH 隧道把本地开发机和外网服务器连接在了一起，外网服务器端监听在 <code>12.34.56.78:8080</code>，那么所有发给 <code>12.34.56.78:8080</code> 的数据都会通过 SSH 隧道原封不动地传输给本地开发机的 <code>127.0.0.1:8080</code>，如图所示：</p>\n<p><img src=\"https://user-images.githubusercontent.com/5773264/32361022-caa26dde-c029-11e7-8ac3-eda5c4f75529.png\" alt=\"SSH隧道\"></p>\n<p>也就是说，去访问 <code>12.34.56.78:8080</code> 就像是访问本地开发机的 <code>127.0.0.1:8080</code>，本地开发机上的 8080 端口被映射到了外网服务器上的 8080 端口。</p>\n<p>如果你的外网服务器 IP 配置了域名解析，例如 <code>yourdomin.com</code> 会通过 DNS 解析为 <code>12.34.56.78</code>，那么也可以通过 <code>yourdomin.com:8080</code> 去访问本地开发机上的服务。<br>这样就做到了访问外网地址时其实是本地服务返回的结果。</p>\n<blockquote>\n<p>通过 SSH 隧道传输数据时，数据会被加密，就算中间被劫持，黑客也无法得到数据的原内容。<br>所以 SSH 隧道还有一个功能就是保证数据传输的安全性。</p>\n</blockquote>\n<h2 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><p>把本地开机和外网服务器通过 SSH 隧道连接起来就和在本地开发机 SSH 登入远程登入到外网服务器一样简单。</p>\n<p>先来回顾以下 SSH 远程登入命令，假如想在本地远程登入到 <code>12.34.56.78</code>，可以在本地开发机上执行以下命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh username@12.34.56.78</span><br></pre></td></tr></table></figure></p>\n<p>而实现 SSH 隧道只需在本地开发机上执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -R 8080:127.0.0.1:8080 username@12.34.56.78</span><br></pre></td></tr></table></figure></p>\n<p>如果想同时映射多个端口则可以执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh username@12.34.56.78 -R 8080:127.0.0.1:8080 -R 8081:127.0.0.1:8081</span><br></pre></td></tr></table></figure></p>\n<p>可以看出实现 SSH 隧道的命令相对于 SSH 登入多出来 <code>-R 8080:127.0.0.1:8080</code>，多出的这部分的含义是：<br>在远程机器(<code>12.34.56.78</code>)上启动 TCP 8080端口监听着，再把远程机器(<code>12.34.56.78</code>)上8080端口映射到本地的<code>127.0.0.1:8080</code>。<br>执行完以上命令后，就可以通过 <code>12.34.56.78:8080</code> 去访问本地的 <code>127.0.0.1:8080</code> 了。</p>\n<p>通常把这种技术叫做 SSH 远程端口转发(remote forwarding)。</p>\n<p>其实不限于只能把本地开发机上运行的服务映射到外网服务器上去，还可以把任何本地开发机可以访问的服务映射到外网服务器上去。例如在本地开发机上能访问 <code>github.com:80</code>，在本地开发机上执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -R 8080:github.com:80 username@12.34.56.78</span><br></pre></td></tr></table></figure></p>\n<p>就能通过 <code>12.34.56.78:8080</code> 去访问 <code>github.com:80</code> 了。</p>\n<h2 id=\"保持运行\"><a href=\"#保持运行\" class=\"headerlink\" title=\"保持运行\"></a>保持运行</h2><p>在执行完上面介绍的 SSH 隧道命令后，你会发现登入到了外网服务器上去了，如果你登出外网服务器，就会发现 <code>12.34.56.78:8080</code> 无法访问了。导致这个问题的原因是你登出外网服务器时，在外网服务器上本次操作对应的 SSH 进程也跟着退出了，而这个退出的进程曾负责监听在 8080 端口进行转发操作。</p>\n<p>为了让 SSH 隧道一直保持在后台执行，有以下方法。</p>\n<h4 id=\"通过-SSH-自带的参数\"><a href=\"#通过-SSH-自带的参数\" class=\"headerlink\" title=\"通过 SSH 自带的参数\"></a>通过 SSH 自带的参数</h4><p>SSH 还支持这些参数：</p>\n<ul>\n<li>N参数：表示只连接远程主机，不打开远程shell；</li>\n<li>T参数：表示不为这个连接分配TTY；</li>\n<li>f参数：表示连接成功后，转入后台运行；</li>\n</ul>\n<p>因此要让 SSH 隧道一直保持在后台执行，可以通过以下命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -NTf -R 8080:127.0.0.1:8080 username@12.34.56.78</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"通过-AutoSSH\"><a href=\"#通过-AutoSSH\" class=\"headerlink\" title=\"通过 AutoSSH\"></a>通过 <a href=\"http://www.harding.motd.ca/autossh/\" target=\"_blank\" rel=\"noopener\">AutoSSH</a></h4><p>SSH 隧道是不稳定的，在网络恶劣的情况下可能随时断开。如果断开就需要手动去本地开发机再次向外网服务器发起连接。<br>AutoSSH 能让 SSH 隧道一直保持执行，他会启动一个 SSH 进程，并监控该进程的健康状况；当 SSH 进程崩溃或停止通信时，AutoSSH 将重启动 SSH 进程。</p>\n<p>使用AutoSSH 只需在本地开发机上安装 AutoSSH ，方法如下：</p>\n<ul>\n<li>Mac 系统：<code>brew install autossh</code>；</li>\n<li>Linux 系统：<code>apt-get install autossh</code>；</li>\n</ul>\n<p>安装成功后，在本地开发机上执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">autossh -N -R 8080:127.0.0.1:8080 username@12.34.56.78</span><br></pre></td></tr></table></figure></p>\n<p>就能完成和上面一样的效果，但本方法能保持 SSH 隧道一直运行。<br>可以看出这行命令和上面的区别在于把 <code>ssh</code> 换成了 <code>autossh</code>，并且少了 <code>-f</code> 参数，原因是 autossh 默认会转入后台运行。</p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><p>如果你遇到通过以上方法成功启动 SSH 隧道后，还是无法访问 <code>12.34.56.78:8080</code>，那么很有可能是外网服务器上的 SSH 没有配置对。为此你需要去外网服务器上修改  <code>/etc/ssh/sshd_config</code> 文件如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GatewayPorts yes</span><br></pre></td></tr></table></figure></p>\n<p>这个选项的意思是，SSH 隧道监听的服务的 IP 是对外开放的 0.0.0.0，而不是只对本机的 127.0.0.1。不开 GatewayPorts 的后果是不能通过 <code>12.34.56.78:8080</code> 访问，只能在外网服务器上通过 <code>127.0.0.1:8080</code> 服务到本地开发机的服务。</p>\n<p>修改好配置文件后，你还需要重启 sshd 服务来加载新的配置，命令如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service sshd restart</span><br></pre></td></tr></table></figure></p>\n<p>如果使用以上方法还是无法访问 <code>12.34.56.78:8080</code>，请检查你外网服务器的防火墙配置，确保 8080 端口是对外开放的。</p>\n<h2 id=\"其它代替方案\"><a href=\"#其它代替方案\" class=\"headerlink\" title=\"其它代替方案\"></a>其它代替方案</h2><p>除了 SSH 隧道能实现内网穿透外，还有以下常用方法。</p>\n<h4 id=\"frp\"><a href=\"#frp\" class=\"headerlink\" title=\"frp\"></a><a href=\"https://github.com/fatedier/frp/blob/master/README_zh.md\" target=\"_blank\" rel=\"noopener\">frp</a></h4><p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。<br>frp 有以下特性：</p>\n<ul>\n<li>frp 比 SSH 隧道功能更多，配置项更多；</li>\n<li>frp 也需要一台外网服务器，并且需要在外网服务器上安装 frps，在本地开发机上安装 frpc；</li>\n</ul>\n<h4 id=\"ngrok\"><a href=\"#ngrok\" class=\"headerlink\" title=\"ngrok\"></a><a href=\"https://ngrok.com\" target=\"_blank\" rel=\"noopener\">ngrok</a></h4><p>ngrok 是一个商用的内网穿透工具，它有以下特点：</p>\n<ul>\n<li>不需要有外网服务器，因为 ngrok 会为你提供；</li>\n<li>只需要在本地开发机安装 ngrok 客户端，和注册 ngrok 账户；</li>\n<li>按照服务收费；</li>\n</ul>\n<p>这些代替方案的缺点在于都需要再额外安装其它工具，没有 SSH 隧道来的直接。<br>想了解更多可以访问它们的主页。</p>\n<p><a href=\"http://wuhaolin.cn/2017/11/03/%E8%B0%83%E8%AF%95%E5%88%A9%E5%99%A8-SSH%E9%9A%A7%E9%81%93/\">阅读原文</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjogs0kds0001g5tc31zpbenn","tag_id":"cjogs0ke10003g5tc42zvrpgz","_id":"cjogs0ke60008g5tcm8xvt5ht"},{"post_id":"cjogs0ke50006g5tcibju4y26","tag_id":"cjogs0ke10003g5tc42zvrpgz","_id":"cjogs0ke7000ag5tcpnpflgp9"},{"post_id":"cjogs0kdy0002g5tchsposa0z","tag_id":"cjogs0ke60007g5tcmtxpwfqs","_id":"cjogs0keb000eg5tcfbvpi89f"},{"post_id":"cjogs0kea000dg5tcms20r3pp","tag_id":"cjogs0ke60007g5tcmtxpwfqs","_id":"cjogs0kee000hg5tchdw5e09h"},{"post_id":"cjogs0ke20004g5tcae7st4bx","tag_id":"cjogs0ke10003g5tc42zvrpgz","_id":"cjogs0kef000jg5tcglbj153b"},{"post_id":"cjogs0ke40005g5tcdbypald1","tag_id":"cjogs0ked000gg5tcm2ib15qq","_id":"cjogs0keh000ng5tcy5tdine8"},{"post_id":"cjogs0kef000kg5tcbmx27w58","tag_id":"cjogs0ke10003g5tc42zvrpgz","_id":"cjogs0kei000pg5tc0wpwf0gy"},{"post_id":"cjogs0keg000mg5tcfl66lwzf","tag_id":"cjogs0keg000lg5tcddgmxfbh","_id":"cjogs0kej000rg5tclxq8luaa"},{"post_id":"cjogs0ke60009g5tclurrlu10","tag_id":"cjogs0keg000lg5tcddgmxfbh","_id":"cjogs0kej000sg5tcxnn4vtlf"},{"post_id":"cjogs0ke8000bg5tcuwu7z0rv","tag_id":"cjogs0kei000qg5tcyma0ho9t","_id":"cjogs0kej000ug5tcbywktv9x"},{"post_id":"cjogs0keb000fg5tc4oi0l301","tag_id":"cjogs0kej000tg5tcd4nlvuzv","_id":"cjogs0kek000wg5tclov0ghs2"},{"post_id":"cjogs0kee000ig5tc8l66u6w1","tag_id":"cjogs0kej000tg5tcd4nlvuzv","_id":"cjogs0kek000yg5tcopev6tg3"},{"post_id":"cjogs0keh000og5tchwaem1lr","tag_id":"cjogs0kej000tg5tcd4nlvuzv","_id":"cjogs0kek000zg5tcb52j4qzz"},{"post_id":"cjogs0kff0010g5tcsbsgsv0r","tag_id":"cjogs0kei000qg5tcyma0ho9t","_id":"cjogs0kfi0013g5tca2nm9qrd"}],"Tag":[{"name":"webpack","_id":"cjogs0ke10003g5tc42zvrpgz"},{"name":"react","_id":"cjogs0ke60007g5tcmtxpwfqs"},{"name":"编程语言","_id":"cjogs0ked000gg5tcm2ib15qq"},{"name":"chrome","_id":"cjogs0keg000lg5tcddgmxfbh"},{"name":"网络","_id":"cjogs0kei000qg5tcyma0ho9t"},{"name":"音视频","_id":"cjogs0kej000tg5tcd4nlvuzv"}]}}